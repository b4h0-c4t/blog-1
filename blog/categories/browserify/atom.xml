<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: browserify | blog.koba04.com]]></title>
  <link href="http://blog.koba04.com/blog/categories/browserify/atom.xml" rel="self"/>
  <link href="http://blog.koba04.com/"/>
  <updated>2016-03-09T13:30:21+09:00</updated>
  <id>http://blog.koba04.com/</id>
  <author>
    <name><![CDATA[koba04]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Setting up minimum single page application]]></title>
    <link href="http://blog.koba04.com/post/2015/03/19/setting-up-minimum-single-page-application/"/>
    <updated>2015-03-19T18:54:49+09:00</updated>
    <id>http://blog.koba04.com/post/2015/03/19/setting-up-minimum-single-page-application</id>
    <content type="html"><![CDATA[<p>React.jsなどを試そうとするときに、browserify? gulp? grunt? webpack? どれ使えばいいのとか、テストは何を使えばいいのかとかよくわからないというのをたまに聞くので、最低限の設定だけどES6で書けたりautobuildやlivereloadが出来る構成のサンプルを作ってみました。</p>

<p>あと、テストはkarma + mocha + power-assertでchromeでテスト出来るようにしています。</p>

<!-- more -->


<p>本当はpackage.jsonだけにしたかったのですがkarmaの設定だけは別ファイルになってます&hellip;。
テストが必要ない場合は、package.jsonの指定だけで大丈夫です。</p>

<ul>
<li><a href="https://github.com/koba04/minimum-spa-boilerplate">https://github.com/koba04/minimum-spa-boilerplate</a></li>
</ul>


<p>git cloneして<code>npm install</code>して<code>npm start</code>すればいいだけの設定になっています。</p>

<p><code>
git clone git@github.com:koba04/minimum-spa-boilerplate.git
npm install
npm start
</code></p>

<p><img src="http://i.gyazo.com/f906464bfb325437c5c905f80a5b976d.gif" alt="gif" /></p>

<h2>概要</h2>

<h3>tree</h3>

<p><code>
➜  tree -L 1
.
├── README.md
├── index.js         // エントリーポイント
├── karma.conf.js    // karmaの設定
├── lib              // ソース
├── node_modules
├── package.json     // 設定はこの中
├── public           // document root
└── test             // テスト
</code></p>

<h3>package.json</h3>

<p>基本的には<code>npm init</code>で作ったものに色々インストールしてnpm scriptの設定をしているだけです。</p>

<p>```json
  &ldquo;scripts&rdquo;: {</p>

<pre><code>"build": "NODE_ENV=production browserify index.js -t babelify | uglifyjs &gt; public/bundle.js",
"watch": "watchify -d index.js -t babelify -o public/bundle.js -v",
"server": "browser-sync start --server public --files public/**/*",
"test": "karma start",
"start": "npm run watch &amp; npm run server &amp; npm test"
</code></pre>

<p>  },</p>

<p>  &ldquo;dependencies&rdquo;: {</p>

<pre><code>"react": "^0.13.1"
</code></pre>

<p>  },
  &ldquo;devDependencies&rdquo;: {</p>

<pre><code>"babelify": "^5.0.4",
"browser-sync": "^2.3.1",
"browserify": "^9.0.3",
"espowerify": "^0.10.0",
"karma": "^0.12.31",
"karma-browserify": "^4.0.0",
"karma-chrome-launcher": "^0.1.7",
"karma-cli": "0.0.4",
"karma-mocha": "^0.1.10",
"mocha": "^2.2.1",
"power-assert": "^0.10.2",
"uglify-js": "^2.4.17",
"watchify": "^2.4.0"
</code></pre>

<p>  }
```
<a href="https://github.com/koba04/minimum-spa-boilerplate/blob/master/package.json">https://github.com/koba04/minimum-spa-boilerplate/blob/master/package.json</a></p>

<ul>
<li><code>npm run build</code></li>
</ul>


<p>これはReactに依存したビルドになっているのですが、production用にビルドされたファイルを生成することを想定しています。</p>

<ul>
<li><code>npm run watch</code></li>
</ul>


<p>watchifyによってファイルが変更されたら自動的にbrowserifyのビルドが走るようになっています。
watchifyはキャッシュするので二回目以降のビルドが高速化されるのもポイントです。</p>

<ul>
<li><code>npm run server</code></li>
</ul>


<p>BrowserSyncによって<code>public</code>をrootにしたserverを立ちあげつつ、<code>public</code>以下のファイルを監視してlivereloadするようになっています。</p>

<ul>
<li><code>npm test</code></li>
</ul>


<p>テストはkarmaを使うので<code>karma start</code>しているだけです。<code>karma</code>の設定は<code>karma.conf.js</code>にあります。</p>

<ul>
<li><code>npm start</code></li>
</ul>


<p>上記のweatchとbrowserとtestをまとめて実行するコマンドで、これだけ実行すれば開発を始められるようになっています。</p>

<h3>karma</h3>

<p>karmaは<code>karma init</code>で対話的に作成出来る<code>karma.conf.js</code>にbrowserifyの設定を追加したくらいです。</p>

<p>```js
// frameworks to use
// available frameworks: <a href="https://npmjs.org/browse/keyword/karma-adapter">https://npmjs.org/browse/keyword/karma-adapter</a>
frameworks: [&lsquo;mocha&rsquo;, &lsquo;browserify&rsquo;],</p>

<p>// list of files / patterns to load in the browser
files: [
  &lsquo;test/<em>*/</em>.js&rsquo;
],</p>

<p>// list of files to exclude
exclude: [
],</p>

<p>// preprocess matching files before serving them to the browser
// available preprocessors: <a href="https://npmjs.org/browse/keyword/karma-preprocessor">https://npmjs.org/browse/keyword/karma-preprocessor</a>
preprocessors: {
  &lsquo;test/<em>*/</em>.js&rsquo;: &lsquo;browserify&rsquo;
},</p>

<p>browserify: {
  debug: true,
  transform: [</p>

<pre><code>"babelify",
"espowerify"
</code></pre>

<p>  ]
},
```</p>

<p>karmaについては以前にも書いたのでそちらも。</p>

<ul>
<li><a href="http://blog.koba04.com/post/2014/06/23/karma-for-javascript-test-runner/">http://blog.koba04.com/post/2014/06/23/karma-for-javascript-test-runner/</a></li>
</ul>


<p>今回はカジュアルさを優先したので設定していませんが、travis-ciを使いたい場合は、<code>karma-phantomjs-launcher</code>を入れて<code>npm test</code>でPhantomJSで実行出来るようにすればOKだと思います。</p>

<h3>Code</h3>

<p>コードはこんな感じで書けます。</p>

<p>```js
import React from &lsquo;react&rsquo;;</p>

<p>export default class App extends React.Component {
  render() {</p>

<pre><code>return &lt;div&gt;Hello World&lt;/div&gt;;
</code></pre>

<p>  }
}
```
<a href="https://github.com/koba04/minimum-spa-boilerplate/blob/master/lib/components/app.js">https://github.com/koba04/minimum-spa-boilerplate/blob/master/lib/components/app.js</a></p>

<h3>Test</h3>

<p>テストはこんな感じ</p>

<p>```js
import assert from &lsquo;power-assert&rsquo;;
import React from &lsquo;react/addons&rsquo;;
import App from &lsquo;../../lib/components/app&rsquo;;</p>

<p>const {TestUtils} = React.addons;</p>

<p>describe(&ldquo;App&rdquo;, () => {
  let component;</p>

<p>  beforeEach(() => {</p>

<pre><code>component = TestUtils.renderIntoDocument(&lt;App /&gt;);
</code></pre>

<p>  });</p>

<p>  it(&ldquo;returns Hello World in div&rdquo;, () => {</p>

<pre><code>const div = TestUtils.findRenderedDOMComponentWithTag(component, 'div');
assert(
  React.findDOMNode(div).textContent
  ===
  'Hello World'
);
</code></pre>

<p>  });
});
```</p>

<h2>おまけ</h2>

<h3>karma-browserify + power-assert + babel</h3>

<p>npm scriptでbrowserifyとwatchifyの引数に<code>babelify</code>を指定していますが、本当は↓のようにbrowserifyのtransformフィールドにだけ指定してkarmaには<code>espowerify</code>だけを指定したいところなのですが、<code>karma-browserify</code>に指定するtransformはbrowserifyにoptionとしてそのまま渡されるのではなくて事前にtransformするので、<code>espowerify</code>が<code>babelify</code>される前のコードを対象としてしまいエラーになります&hellip;。</p>

<p>なのでここでは、それぞれに個別に設定する形になっています&hellip;。
レアケースですがなんとかしたいなぁと思いつつ&hellip;。</p>

<p>```
&ldquo;browserify&rdquo;: {
  &ldquo;transform&rdquo;: [</p>

<pre><code>["babelify"]
</code></pre>

<p>  ]
}
```</p>

<hr />

<p>そこそこカジュアルな感じになっているかなぁと思います。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[vueifyでcomponent化]]></title>
    <link href="http://blog.koba04.com/post/2014/10/07/component-by-vueify/"/>
    <updated>2014-10-07T15:29:06+09:00</updated>
    <id>http://blog.koba04.com/post/2014/10/07/component-by-vueify</id>
    <content type="html"><![CDATA[<p><a href="https://github.com/vuejs/vueify">https://github.com/vuejs/vueify</a></p>

<p>vueifyというVue.js用のbrowserifyのtransformが出てたので紹介。</p>

<!-- more -->


<p>以前にpartialifyやstylify、coffeeify、insert-cssなどを組み合わせてHTML、JavaScript、CSSをComponent化する方法を紹介しましたがそれをさらに進めて1つのファイルで完結することが出来るようになっています。</p>

<p><a href="http://blog.koba04.com/post/2014/04/17/reusable-components-by-vuejs-and-browserify/">http://blog.koba04.com/post/2014/04/17/reusable-components-by-vuejs-and-browserify/</a></p>

<h2>使い方</h2>

<p>vueifyを使うと1つのファイルにHTMLとJavaScriptとCSSを全部まとめて書くようになり、1ファイルが1Componentという形になります。</p>

<ul>
<li>src/app.vue
```</li>
</ul>


<script lang="coffee">
  module.exports =
    data: ->
      view: "top"
</script>


<p><template>
  <div v-component="{{view}}" v-transition></div>
</template></p>



<p>```</p>

<p><code>
➜  tree src
src
├── app.vue
├── artist.vue
├── country.vue
├── footer.vue
├── index.js
├── input-artist.vue
├── nav.vue
├── select-country.vue
├── top.vue
└── tracks.vue
</code></p>

<p><a href="https://github.com/koba04/vue-boilerplate/tree/master/src">https://github.com/koba04/vue-boilerplate/tree/master/src</a></p>

<p>coffeescriptとstylus以外にも、less、scss(node-sass)、jadeなどを指定することが出来ます。</p>

<h2>syntax highlight</h2>

<p>1つにまとめて、vueっていう拡張子付けたりするとシンタックスハイライトどうするのかという問題になりますが、SublimeTextだとこれで大丈夫なようです
(使ってないのでわからないですが)</p>

<p><a href="https://gist.github.com/yyx990803/9194f92d96546cebd033">https://gist.github.com/yyx990803/9194f92d96546cebd033</a></p>

<p>vimとかの場合は&hellip;</p>

<p>まぁ、ちょっとしたものを作るときにvueify使ってみるのもいいのではないでしょうか。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Reusable components by Vue.js and Browserify]]></title>
    <link href="http://blog.koba04.com/post/2014/04/17/reusable-components-by-vuejs-and-browserify/"/>
    <updated>2014-04-17T01:27:24+09:00</updated>
    <id>http://blog.koba04.com/post/2014/04/17/reusable-components-by-vuejs-and-browserify</id>
    <content type="html"><![CDATA[<p>最近Vue.jsについて調べたり試したりしていて、browserifyと組み合わせたexampleがなかなか興味深かったので参考に自分でも作ってみました。</p>

<p>参考</p>

<ul>
<li><a href="https://github.com/vuejs/vue-browserify-example">https://github.com/vuejs/vue-browserify-example</a></li>
</ul>


<p>作ったサンプル</p>

<ul>
<li><a href="https://github.com/koba04/vue-boilerplate">https://github.com/koba04/vue-boilerplate</a></li>
<li><a href="http://koba04.com/vue-boilerplate/">http://koba04.com/vue-boilerplate/</a></li>
</ul>


<!-- more -->


<h2>browserify</h2>

<p>Vue.js自体はビルドに<a href="https://github.com/component/component">Compoment</a>を使っているのですが、ここでは個人的な好みによりbrowserifyを使っています。</p>

<p>上記のexampleではbrowserifyにプラスしてwatchifyとpartialifyを使っていたのですが、今回はlivereloadもしたかったのでwatchifyではなくて<a href="https://github.com/chrisdickinson/beefy">beefy</a>にして、さらにcoffeeifyとstylifyも使ってcoffeescriptとstylusのcompileも任せることにしました。</p>

<p>その結果の起動scriptはこんな感じで、<strong>npm run dev</strong>するとlivereload + auto buildな環境が立ち上がり、<strong>npm run build</strong>するとbundle.jsが生成されるようになっています。</p>

<ul>
<li><a href="https://github.com/koba04/vue-boilerplate/blob/master/package.json">https://github.com/koba04/vue-boilerplate/blob/master/package.json</a>
<code>javascript
"scripts": {
  "dev": "beefy src/index.coffee:bundle.js --live -- -t partialify -t coffeeify -t stylify --extension=coffee",
  "build": "browserify src/index.coffee -t partialify -t coffeeify -t stylify --extension=coffee &gt; bundle.js"
}
</code></li>
</ul>


<p>ちなみに<a href="https://github.com/bclinkinbeard/partialify">partialify</a>はhtmlをrequireで読み込むのに使っています。</p>

<p>これで、gruntを使うことなくbrowserifyだけでlivereload + auto buildが出来るようになりました。便利！</p>

<h2>Reusable components</h2>

<p>Vue.jsを使っていると、ViewModelをCompomentとして組み合わせてアプリケーションを作る感じになっていくので、Component単位でhtml、js、cssをまとめたくなります(ならない？)。</p>

<p>Vue.jsにはcompomentという概念があるのでこんな感じでViewModelをcompomentとして登録することが出来ます。</p>

<p>```coffeescript</p>

<h1>グローバルにcompomentを登録</h1>

<p>Vue.component &lsquo;artist&rsquo;,   require &lsquo;./artist/index.coffee&rsquo;</p>

<h1>or</h1>

<h1>ViewModelに紐づけて登録</h1>

<p>module.exports = Vue.extend
  components:</p>

<pre><code>"nav":          require '../nav/index.coffee'
</code></pre>

<p>```</p>

<p>exampleでもそのようになっていて、partialifyでhtmlとcssをrequireして読み込んでcssの方はinsert-cssで追加する感じになっています。</p>

<ul>
<li>insert-cssというのはsubstackが作っているライブラリで、CSSを渡すとDOMにstyle要素を作ってhead要素にappendしてくれるというライブラリです。

<ul>
<li><a href="https://www.npmjs.org/package/insert-css">https://www.npmjs.org/package/insert-css</a></li>
</ul>
</li>
</ul>


<p>ただCSSはグローバルに作用してしまいます。なので名前ベースで解決したくなりますがCSSではネストした記述をサポートしていません。そこでstylusを使ってネストで書きやすくしてみました。</p>

<ul>
<li><a href="https://github.com/koba04/vue-boilerplate/blob/master/src/top/index.coffee">https://github.com/koba04/vue-boilerplate/blob/master/src/top/index.coffee</a>
```coffeescript
require(&lsquo;insert-css&rsquo;)(require(&lsquo;./index.styl&rsquo;))</li>
</ul>


<p>Vue = require &lsquo;vue&rsquo;
module.exports = Vue.extend
  template: require &lsquo;./index.html&rsquo;
  className: &lsquo;top&rsquo;
  components:</p>

<pre><code>"nav":          require '../nav/index.coffee'
</code></pre>

<p>```</p>

<ul>
<li><a href="https://github.com/koba04/vue-boilerplate/blob/master/src/top/index.styl">https://github.com/koba04/vue-boilerplate/blob/master/src/top/index.styl</a>
<code>sass
.top
h1
  font-family: 'Playfair Display SC', serif
</code></li>
</ul>


<p>こんな感じにすると、Compoment単位でディレクトリ作ってindex.coffeeの中でinsert-cssを使ってcssを追加しつつpartialifyでhtmlをtemplateとして設定することで、javascriptとhtmlとcssをまとめることが出来ます。</p>

<ul>
<li><p>ファイル名の付け方は悩ましいですが・・・。</p></li>
<li><p><a href="https://github.com/koba04/vue-boilerplate">https://github.com/koba04/vue-boilerplate</a>
<code>sh
src
├── artist
│   ├── components
│   │   └── input-artist
│   │       ├── index.coffee
│   │       ├── index.html
│   │       └── index.styl
│   ├── index.coffee
│   ├── index.html
│   └── index.styl
├── country
│   ├── components
│   │   └── select-country
│   │       ├── index.coffee
│   │       ├── index.html
│   │       └── index.styl
│   ├── index.coffee
│   ├── index.html
│   └── index.styl
├── index.coffee
├── index.html
├── index.styl
├── nav
│   ├── index.coffee
│   ├── index.html
│   └── index.styl
├── partials
│   └── footer.html
├── top
│   ├── index.coffee
│   ├── index.html
│   └── index.styl
└── tracks
  ├── index.coffee
  ├── index.html
  └── index.styl
</code></p></li>
</ul>


<p>まぁ実際はcompoment化してもなかなか再利用は難しいのですが、こういう分け方もありかなーと思いました。</p>

<h2>routing animation by v-view and css animation</h2>

<p>余談ですが、今回作ったサンプルの遷移時のウザイアニメーションは、v-viewとv-animationを組み合わせています。</p>

<ul>
<li><a href="http://koba04.com/vue-boilerplate/">http://koba04.com/vue-boilerplate/</a></li>
</ul>


<p>routingは<a href="https://www.npmjs.org/package/director">director</a>とv-viewとVue.compomentを組み合わせています。</p>

<ul>
<li>angular.jsのng-animateみたいな感じでv-enterとv-leaveというクラスがあてられるのでそれを使ってアニメーションさせています。</li>
</ul>


<p>v-viewとv-animationの組み合わせについては、v-leaveのanimation-endで要素が削除されるためアニメーションが指定されていないと古い要素が残ったりと若干ハマりどころもあるのですが、それはまた別の機会にまとめたいと思います。</p>

<ul>
<li><a href="https://github.com/koba04/vue-boilerplate/blob/master/src/index.html">https://github.com/koba04/vue-boilerplate/blob/master/src/index.html</a>
```html</li>
</ul>


<div v-view="view" v-animation></div>


<p>```</p>

<ul>
<li><a href="https://github.com/koba04/vue-boilerplate/blob/master/src/index.styl">https://github.com/koba04/vue-boilerplate/blob/master/src/index.styl</a>
```sass

<h1>app</h1>

<p>.v-enter
  -webkit-animation: fadein 0.5s
  -webkit-animation-delay: 0.2s
  animation: fadein 0.5s
  animation-delay: 0.2s
  opacity: 0
.v-leave
  -webkit-animation: fadeout 0.2s
  animation: fadeout 0.2s</p></li>
</ul>


<p>@keyframes fadein
  0%</p>

<pre><code>transform: scale(0.5)
-webkit-transform: scale(0.5)
opacity: 0
</code></pre>

<p>  50%</p>

<pre><code>transform: scale(1.2)
-webkit-transform: scale(1.2)
opacity: 0.7
</code></pre>

<p>  100%</p>

<pre><code>transform: scale(1)
-webkit-transform: scale(1)
opacity: 1
</code></pre>

<p>@keyframes fadeout
  0%</p>

<pre><code>transform: scale(1)
-webkit-transform: scale(1)
</code></pre>

<p>  100%</p>

<pre><code>transform: scale(0)
-webkit-transform: scale(0)
</code></pre>

<p>```</p>

<h3>追記</h3>

<p>ちなみにネストしたViewの場合は色々な解決方法があると思うのですが、v-viewとv-refを組み合わせて実現することも出来ます</p>

<p>v-refを使うことで子のViewを参照することができるのでそれを使って同じようにv-componentを更新する感じです</p>

<p>サンプルはこんな感じ</p>

<p><a href="http://jsfiddle.net/koba04/WgSK9/1/">http://jsfiddle.net/koba04/WgSK9/1/</a></p>

<h2>more?</h2>

<p>本当はここにtestling + mocha + power-assertな組み合わせのテストも含めたかったのですが間に合わず・・。</p>

<p>Vue.js自体についても下記のメモをスライドにでもまとめようかなと思っています..そのうち..</p>

<ul>
<li><a href="https://gist.github.com/koba04/9776792">https://gist.github.com/koba04/9776792</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[browserify in Backbone.Marionette project]]></title>
    <link href="http://blog.koba04.com/post/2014/03/23/browserify-in-backbone-marionette-project/"/>
    <updated>2014-03-23T21:05:46+09:00</updated>
    <id>http://blog.koba04.com/post/2014/03/23/browserify-in-backbone-marionette-project</id>
    <content type="html"><![CDATA[<h2>browserify</h2>

<ul>
<li><a href="http://browserify.org/">http://browserify.org/</a></li>
</ul>


<p>browserifyはbrowser環境でもnodeのようにrequire(&lsquo;xxx&rsquo;)というスタイルで依存しているライブラリを読み込むことが出来るようになるもので、最近盛り上がってますね。</p>

<p>(Backboneなど色々なプロジェクトでbrowserifyについて議論されていたり)</p>

<p>ここでは基本的な使い方は省略して、Backbone + Marionetteなサンプルプロジェクトをbrowserify対応してみたのでその構成についてを書きたいと思います。</p>

<!-- more -->


<p>(まだ全然理解出来てないので、もっといい方法があれば教えて欲しいです)</p>

<h2>Sample Project</h2>

<ul>
<li><a href="https://github.com/koba04/backbone-boilerplate">https://github.com/koba04/backbone-boilerplate</a></li>
</ul>


<p>{% img /images/last-fm-top-tracks.png &lsquo;Atrist Top Tracks by Last.FM&rsquo; %}</p>

<ul>
<li><a href="http://koba04.com/last-fm-top-tracks/">http://koba04.com/last-fm-top-tracks/</a></li>
</ul>


<p>サンプルプロジェクト過ぎると役に立たないと思うので、テストも書きつつwebアプリっぽくLast.FMのAPI使ってアーティストの人気の曲一覧を表示するようなアプリにしてみました。</p>

<p>(testling対応はIssueにしているのでそのうちやります&hellip; <a href="https://ci.testling.com/">https://ci.testling.com/</a>)</p>

<h2>grunt-browserify</h2>

<ul>
<li>Gruntfile.coffee
<code>coffeescript
  browserify:
    app:
      files: "public/js/app.js": [ "coffee/**/*.coffee", "template/**/*.hbs" ]
      options:
        ignore: ["coffee/vendor.coffee"]
        extensions: [".coffee", ".hbs"]
        transform: ["coffeeify", "hbsfy"]
        aliasMappings: [
          {
            cwd: 'coffee'
            dest: 'myapp'
            src: ['**/*.coffee']
          }
          {
            cwd: 'template'
            dest: 'template'
            src: ['**/*.hbs']
          }
        ]
        external: [
          "jquery"
          "underscore"
          "backbone"
          "backbone.marionette"
          "handlebars"
        ]
        alias: [ "hbsfy/runtime:handlebars" ]
    vendor:
      files: "public/js/vendor.js": ["coffee/vendor.coffee"]
      options:
        transform: ["coffeeify"]
        alias: [
          "jquery"
          "underscore"
          "backbone"
          "backbone.marionette"
        ]
    spec:
      files: "specs/spec.js": [ "specs/**/*.coffee" ]
      options: "&lt;%= browserify.app.options %&gt;"
</code></li>
</ul>


<h3>transform</h3>

<p>coffeescriptのcompileやhandlebarsのprecompileは、coffeeifyとhbsfyというtransformを使っています。</p>

<p>coffeescriptやhandlebarsのgrunt pluginを別途使用する必要がなくていいですね。</p>

<h3>separate files</h3>

<p>ライブラリ(vendor)とアプリ(app)のjsを分けているのは、vendor.jsはほとんど変更されることがないので毎回ビルドに含まれるのは無駄なためです。</p>

<h3>external</h3>

<p>vendor.jsのaliasで指定して、app.jsのexternalでそれを指定することでapp.js側にライブラリが含まれないようになります。</p>

<p>hbsfy/runtimeもそうしたかったのですが、どうしてもapp.js内で展開されてしまったのでapp.js内で指定しています&hellip;</p>

<h3>aliasMappings</h3>

<p>browserifyはそのファイルからの相対パスを指定する必要があるので階層が深くなってくると階層を意識するのが面倒になります。</p>

<p>そこで、aliasmappingsを使ってどこからでも同じパス指定(<strong>require &lsquo;myapp/collections/users&rsquo;</strong>)のように指定出来るようにしています。</p>

<p>```</p>

<h1>coffee/view/items/hoge.coffee</h1>

<h1>before</h1>

<p>users = require &lsquo;../../collections/users&rsquo;</p>

<h1>after (anywhere!)</h1>

<p>users = require &lsquo;myapp/collections/users&rsquo;
```</p>

<h3>???</h3>

<p>テスト用のspec.jsにアプリのjsも含まれてしまっているので、ホントはspec.jsにはテストだけが含まれてapp.jsを別に読み込むようにしたいのですがその方法がわからず・・・</p>

<ul>
<li>aliasで全部のmodelとかviewを指定すれば出来そうな気もするけどそれは面倒なのでやりたくない・・・。</li>
</ul>


<h2>Sample</h2>

<ul>
<li>App(coffee/views/layouts/top.coffee)</li>
</ul>


<p>```coffeescript
&lsquo;use strict&rsquo;</p>

<p>Backbone          = require &lsquo;backbone&rsquo;
ArtistSearchView  = require &lsquo;myapp/views/items/artist_search&rsquo;
TracksView        = require &lsquo;myapp/views/collections/tracks&rsquo;
Artist            = require &lsquo;myapp/models/artist&rsquo;
tracks            = require &lsquo;myapp/collections/tracks&rsquo;
template          = require &lsquo;template/layouts/top&rsquo;</p>

<p>module.exports = class extends Backbone.Marionette.Layout
  template: template
  regions:</p>

<pre><code>artistSearch: ".js-artist-search"
topTracks:    ".js-top-tracks"
</code></pre>

<p>  onRender: &ndash;></p>

<pre><code>@artistSearch.show new ArtistSearchView model: new Artist
@listenTo tracks, 'reset', @showTracks
</code></pre>

<p>  showTracks: &ndash;></p>

<pre><code>@topTracks.show new TracksView collection: tracks
</code></pre>

<p>```</p>

<ul>
<li>Spec(specs/views/layouts/top_spec.coffee)</li>
</ul>


<p>```coffeescript
describe &ldquo;views/layouts/top&rdquo;, &ndash;>
  expect            = require &lsquo;expect.js&rsquo;
  sinon             = require &lsquo;sinon&rsquo;
  Backbone          = require &lsquo;backbone&rsquo;
  TopView           = require &lsquo;myapp/views/layouts/top&rsquo;
  ArtistSearchView  = require &lsquo;myapp/views/items/artist_search&rsquo;
  TracksView        = require &lsquo;myapp/views/collections/tracks&rsquo;
  Artist            = require &lsquo;myapp/models/artist&rsquo;
  tracks            = require &lsquo;myapp/collections/tracks&rsquo;
  template          = require &lsquo;template/layouts/top&rsquo;</p>

<p>  view = null
  beforeEach &ndash;></p>

<pre><code>view = new TopView
</code></pre>

<p>  it &ldquo;extends Marionette.Layout&rdquo;, &ndash;></p>

<pre><code>expect(view).to.be.a Backbone.Marionette.Layout
</code></pre>

<p>  it &ldquo;template is layouts/top&rdquo;, &ndash;></p>

<pre><code>expect(view.template).to.be template
</code></pre>

<p>  describe &ldquo;onRender&rdquo;, &ndash;></p>

<pre><code>beforeEach -&gt;
  sinon.spy view, "showTracks"
  view.onRender()

it "artistSearch region has artist_search view", -&gt;
  expect(view.artistSearch.currentView).to.be.a ArtistSearchView

it "artist_search view has models/artist", -&gt;
  expect(view.artistSearch.currentView.model).to.be.a Artist

it "listenTo tracks's reset event, trigger showTracks", -&gt;
  tracks.reset []
  expect(view.showTracks.calledOnce).to.be.ok()
</code></pre>

<p>  describe &ldquo;showTracks&rdquo;, &ndash;></p>

<pre><code>beforeEach -&gt;
  view.showTracks()

it "topTracks region has tracks view", -&gt;
  expect(view.topTracks.currentView).to.be.a TracksView

it "tracks view has collections/tracks", -&gt;
  expect(view.topTracks.currentView.collection).to.be tracks
</code></pre>

<p>```</p>

<h2>Summary</h2>

<p>まだまだ情報が少ない気がしますが、依存関係を意識せずrequireでライブラリを使えるのはわかりやすくてよさそうに感じました(実装を理解するともっと便利に使えそう)。</p>

<p>npmで提供されているライブラリだけ使うのであればbowerを使わなくてよくなるのもいいなと思いました。</p>

<p>repositoryはこちら</p>

<ul>
<li><a href="https://github.com/koba04/backbone-boilerplate">https://github.com/koba04/backbone-boilerplate</a></li>
</ul>


<h2>References</h2>

<ul>
<li><a href="http://aeflash.com/2014-03/a-year-with-browserify.html">http://aeflash.com/2014-03/a-year-with-browserify.html</a></li>
</ul>

]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: react.js | blog.koba04.com]]></title>
  <link href="http://blog.koba04.com/blog/categories/react-dot-js/atom.xml" rel="self"/>
  <link href="http://blog.koba04.com/"/>
  <updated>2017-04-25T01:56:35+09:00</updated>
  <id>http://blog.koba04.com/</id>
  <author>
    <name><![CDATA[koba04]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[React Fiber現状確認]]></title>
    <link href="http://blog.koba04.com/post/2017/04/25/a-state-of-react-fiber/"/>
    <updated>2017-04-25T02:00:55+09:00</updated>
    <id>http://blog.koba04.com/post/2017/04/25/a-state-of-react-fiber</id>
    <content type="html"><![CDATA[<p><a href="https://developers.facebook.com/videos/?category=f8_2017">F8</a>でもReact Fiberについての発表もあったので、気になっている人も多いReact Fiberの現状について簡単に書きたいと思います。</p>

<p>Reactの完全な書き換えということで、使い方も変わってしまうと思っている人もいると思いますが、内部実装の書き換えであり、利用者から見える部分ではほとんど変更はありません。</p>

<p>もちろん、react-fiberというパッケージをインストールするというわけでもありません。</p>

<p>むしろ、<code>v16</code>の時点では現在の実装と互換性を保たれているので、<code>v16</code>がリリースされた時に、<code>v15.5</code>を使っていればほとんどそのまま<code>v16</code>に更新できると思います。
そして、言われなければ内部実装が変わっていることに気づかないのではないかと思います。</p>

<h2>とりあえずどうなるのか知りたい人向けのまとめ</h2>

<ul>
<li>v16では、基本的にはv15の時と同じように動作します。逆に言うとパフォーマンスもそんなに変わらない（はず）です</li>
<li>renderメソッドから<code>[&lt;Foo /&gt;, &lt;Bar /&gt;]</code> みたいに配列で返したり、文字列をReactElementでラップすることなく返せるようになります</li>
<li>v17では、デフォルトで非同期のrendering（後述）になります。v16でも何らかのAPIでopt-inで試せるようにはなりそうです。現状は<code>ReactDOM.unstable_deferredUpdates</code>で一部試すことができます</li>
<li>v17では、劇的に高速になるというよりは、ユーザーの入力をブロックしないようにしたり、柔軟に更新処理をスケジューリング出来るようになる予定です</li>
</ul>


<h2>注意点</h2>

<p><strong>以下の情報は、Reactをただ使いたい人にとっては知る必要のない内部実装の話です。多くの人にとってはここまでの情報でReact FiberについてはOKだと思います。v17になるまでは。</strong></p>

<!-- more -->


<h2>Reactの構成</h2>

<p>新しいFiberについて説明するために、まずは現状の実装について確認しましょう。
Reactのソースコードは下記のような構成になっています。</p>

<p>```</p>

<pre><code>src
├── fb
├── isomorphic
│   ├── children
│   ├── classic
│   │   ├── class
│   │   ├── element
│   │   └── types
│   ├── hooks
│   └── modern
│       ├── class
│       └── element
├── renderers
│   ├── art
│   ├── dom
│   │   ├── fiber
│   │   ├── shared
│   │   └── stack
│   ├── native
│   ├── noop
│   ├── shared
│   │   ├── fiber
│   │   ├── hooks
│   │   ├── shared
│   │   ├── stack
│   │   └── utils
│   └── testing
│       └── stack
├── shared
│   ├── types
│   └── utils
└── test
(テストなどの一部ディレクトリは省略)
</code></pre>

<p>```</p>

<p>上記の通り、Fiberは<code>renderers</code> の中にありrendererの1つであることがわかります。<code>fiber</code> と同列にある<code>stack</code> は現在の実装のrendererです。</p>

<p><code>renderes/shared/</code> に<code>fiber</code> と<code>stack</code> のディレクトリがあって、<code>renderers/dom/</code> にも<code>stack</code> と<code>fiber</code> があります。rendererの中にはStackとFiberの2種類の実装があり、それぞれに対応するDOMやNativeなどの環境毎のrendererがさらにあるような構成になっています。</p>

<p>FiberやStackは、reconciliationと呼ばれる部分の役割を担っています。
reconciliationとは、ReactElementからComponentのインスタンスを生成したり差分を計算してHost(DOM)に反映したり、ライフサイクルメソッドの呼び出しといったことを行う部分です。
Hostに反映させる部分はHostが何かによっても異なり、反映方法もreconciliationによって異なるため、<code>renderers/dom/</code> 以下にもStackとFiberが存在します。</p>

<p>Hostとは各環境のことです。ブラウザー環境であればDOMであり、ReactNativeであればネイティブのビューとなります。</p>

<h2>Stack</h2>

<p>それでは、まずは現在使われているStackのrendererについて簡単に触れます。
Stackは、ReactElementがツリー構造になるのと同様に、親から子、子から孫に処理を行っていきます。</p>

<p><img src="/images/posts/a-state-of-react-fiber/ReactDOM.png" title="&lsquo;ReactDOM Stack&rsquo;" ></p>

<p>上記では、<code>mountComponent</code> がどんどん入れ子になって呼ばれているのがわかります。
加えてこれは同期的に行われます。</p>

<p>つまり、トップレベルのComponentから再renderした場合、</p>

<ul>
<li>子孫の全てのComponentに対するrender処理を行いReactElementのツリーを構築する</li>
<li>更新の場合は、前のReactElementツリーと比較を行う</li>
<li>差分をHostに適用する</li>
<li>ライフサイクルメソッドの呼び出しなどを行う</li>
</ul>


<p>という処理が同期的に処理されます。
そのため、例えば複雑なツリー構造を持っていて上記の処理に時間がかかる場合、UIを完全にブロックしてしまいます。</p>

<p>また、例えばアニメーションやユーザーのタイピングなど、即時に反映する必要のある処理を行っている時にサーバーから結果が返ってきた時を考えてみます。
Stackは全てが同期的に処理されるため、サーバーからの結果の反映処理が、アニメーションやタイピングの反映に割り込んでブロックしてしまうことも起きます。</p>

<p>これらは、単純なパフォーマンスのベンチマークでは現れない指標ですが、ユーザー体験という意味では重要です。</p>

<p>これらの問題を解決するためのものとしてReact Fiberはあります。</p>

<p>ちなみにStackに関連するソースは、v16のリリース時には削除されそうな感じではあります。</p>

<h2>Fiber</h2>

<p>Fiberは、wikipediaによると「軽量な実行スレッド」とされています。</p>

<p><a href="https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A1%E3%82%A4%E3%83%90%E3%83%BC_">https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A1%E3%82%A4%E3%83%90%E3%83%BC_</a>(%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF)</p>

<p>React Fiberでは、Fiberの単位でreconciliationが行われます。
Fiberは、基本的には1つのReactElementと対応すると考えることができます。</p>

<p>厳密にはReactElementの単位とFiberが必ずしも一致するわけでありません。
さらにFiberは、<code>fiber.alternate</code> として自身をcloneしたFiberを持っており再利用されています。
ただ、考える上ではFiberをReactElementの単位でイメージするとわかりやすいと思います。</p>

<p>FiberはFlowの型で下記のように指定されています。</p>

<p>```js</p>

<pre><code>// 一部省略
type Fiber = {
  tag: TypeOfWork,
  key: null | string,
  type: any,
  stateNode: any,
  return: Fiber | null,
  child: Fiber | null,
  sibling: Fiber | null,
  index: number,
  ref: null | (((handle: mixed) =&gt; void) &amp; {_stringRef: ?string}),
  pendingProps: any, // This type will be more specific once we overload the tag.
  memoizedProps: any, // The props used to create the output.
  updateQueue: UpdateQueue | null,
  memoizedState: any,
  effectTag: TypeOfSideEffect,
  nextEffect: Fiber | null,
  firstEffect: Fiber | null,
  lastEffect: Fiber | null,
  pendingWorkPriority: PriorityLevel,
  progressedPriority: PriorityLevel,
  progressedChild: Fiber | null,
  progressedFirstDeletion: Fiber | null,
  progressedLastDeletion: Fiber | null,
  alternate: Fiber | null,
};
</code></pre>

<p>```</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactFiber.js">https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactFiber.js</a></li>
</ul>


<p>各プロパティについては解説しませんが、<code>return</code> や<code>child</code> や<code>sibling</code> など、他のFiberへの参照を持っていることがわかります。
FiberはLinked Listの構造になっています。Stackの場合はTree構造を掘り下げていくように処理をしていましたが、Fiberでは、<code>return</code> や<code>child</code> や<code>sibling</code> などをたどることで順番にReactElementを処理していきます。
そのことは、下記のスタックツリーを見てもわかります。</p>

<p><img src="/images/posts/a-state-of-react-fiber/ReactDOMFiber.png" title="&lsquo;ReactDOM Fiber&rsquo;" ></p>

<p>上記の通り、Stackのようにスタックがたくさん積まれていないことがわかります。</p>

<p>Stackでは処理が1つのツリーを単位として行われていましたが、FiberではFiberの単位で処理されます。Stackでは処理を同期的に行うしかできませんでしたが、FiberではこのFiberに対する処理をスケジューリングすることができます。</p>

<p>つまり、A → B → C とLinkedListを構成しているFiberがあった時に、A → B まで処理して中断し、またB → Cから処理を再開できます。
これはStackのような構造では難しいことです。
Generatorsだとどうでしょうか？それに対しては、<a href="https://github.com/sebmarkbage">Sebastian Markbåge</a>が下記でGeneratorsを採用しなかった理由を書いているので興味のある人は見て見るといいと思います。</p>

<ul>
<li><a href="https://github.com/facebook/react/issues/7942">https://github.com/facebook/react/issues/7942</a></li>
</ul>


<h3>Fiberのスケジューリング</h3>

<p>では、具体的にどのようにスケジューリングが行われるのかを見ていきます。</p>

<p>Fiberは、<code>beginWork</code> と<code>completeWork</code> と<code>commitWork</code> という3つのフェーズがあります。
beginWorkはcomponentのインスタンス化やrenderメソッドの呼び出し、shouldComponentUpdateなどによる比較を行います。</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactFiberBeginWork.js">https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactFiberBeginWork.js</a></li>
</ul>


<p>completeWorkは副作用を示すeffectTagを設定したり、Hostインスタンスを作成したりなどを行います。（末端のHostなどでのみ実行される）</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactFiberCompleteWork.js">https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactFiberCompleteWork.js</a></li>
</ul>


<p>副作用は下記のように定義されています。</p>

<p>```js</p>

<pre><code>module.exports = {
  NoEffect: 0, //           0b0000000
  Placement: 1, //          0b0000001
  Update: 2, //             0b0000010
  PlacementAndUpdate: 3, // 0b0000011
  Deletion: 4, //           0b0000100
  ContentReset: 8, //       0b0001000
  Callback: 16, //          0b0010000
  Err: 32, //               0b0100000
  Ref: 64, //               0b1000000
};
</code></pre>

<p>```</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactTypeOfSideEffect.js">https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactTypeOfSideEffect.js</a></li>
</ul>


<p>commitWorkでは、componentDid(Mount|Update)などのライフサイクルメソッドの呼び出しや、completeWorkで設定されたeffectTagに基づいてHostに結果を反映します。</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactFiberCommitWork.js">https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactFiberCommitWork.js</a></li>
</ul>


<p>この中で、beginWorkとcompleteWorkはFiber単位で実行されます。
commitWorkは、全てのFiberに対する処理が終わった後にまとめて実行されます。</p>

<p>例えば、下記のような構成のComponentがある場合、</p>

<p>```js</p>

<pre><code>Text = () =&gt; '...';
List = () =&gt; [
  &lt;div&gt;...&lt;/div&gt;,
  &lt;div&gt;...&lt;/div&gt;,
  &lt;div&gt;...&lt;/div&gt;,
];

class App extends React.Component {
    render() {
        return (
            &lt;main&gt;
            &lt;h2&gt;...&lt;/h2&gt;
            &lt;p&gt;...&lt;/p&gt;
            &lt;div&gt;
                &lt;Text /&gt;
                &lt;List /&gt;
            &lt;/div&gt;
            &lt;/main&gt;
        );
    }
}
</code></pre>

<p>```</p>

<p>下記のような流れで処理されます。</p>

<ol>
<li><strong>beginWork</strong> … (HostRoot)</li>
<li><strong>beginWork …</strong>  <code>&lt;App&gt;</code> (ClassComponent)</li>
<li><strong>beginWork</strong> …  <code>&lt;main&gt;</code> (HostComponent)</li>
<li><strong>beginWork, completeWork …</strong>  <code>&lt;h2&gt;</code> (HostComponent)</li>
<li><strong>beginWork, completeWork …</strong> <code>&lt;p&gt;</code> (HostComponent)</li>
<li><strong>beginWork …</strong> <code>&lt;div&gt;</code> (HostComponent)</li>
<li><strong>beginWork …</strong> <code>&lt;Text&gt;</code> (FunctionalComponent)</li>
<li><strong>beginWork completeWork …</strong> &lsquo;&hellip;&rsquo; (HostText)</li>
<li><strong>beginWork …</strong> <code>&lt;List&gt;</code> (Functional Component)</li>
<li><strong>beginWork, completeWork …</strong> : <code>&lt;div&gt;</code> (HostComponent)</li>
<li><strong>beginWork, completeWork …</strong> : <code>&lt;div&gt;</code> (HostComponent)</li>
<li><strong>beginWork, completeWork …</strong> : <code>&lt;div&gt;</code> (HostComponent)</li>
<li><strong>commitAllWork …</strong> (HostRoot)</li>
</ol>


<p>React Fiberは、非同期renderingの場合には、後述する優先度が高くないものについてはrequestIdleCallback（サポートしてなければpolyfill実装）を使い、これらをスケジューリングして非同期に処理していきます。
requestIdleCallbackでは、アイドル時間を<code>timeRemaining</code>の関数から受け取ることができるため、この値を元に処理できる時間がなくなると再び<code>requestIdleCallback</code> に処理を登録して次のアイドル時間に処理するようになっています。
これにより、優先度が高くない処理がUIや他の処理をブロックしないようになっています。</p>

<ul>
<li><a href="https://developer.mozilla.org/ja/docs/Web/API/Window/requestIdleCallback">https://developer.mozilla.org/ja/docs/Web/API/Window/requestIdleCallback</a></li>
</ul>


<p>下記はFiberを同期モードで実行した時のスタックです。
全てが同期的に行われていることがわかります。この間はUIを完全にブロックしてしまいます。</p>

<p><img src="/images/posts/a-state-of-react-fiber/ReactDOMFiber-sync.png" title="&lsquo;ReactDOM Fiber Sync&rsquo;" ></p>

<p>下記は同じ処理を非同期で実行したスタックです。
スタックが途切れ途切れになっていることがわかります。そのためUIをブロックしません。
右端にある細いスタックはcommitWorkによるものです。
Renderingの処理はcommitWorkの以降でだけ発生していることがわかります。</p>

<p><img src="/images/posts/a-state-of-react-fiber/ReactDOMFiber-async.png" title="&lsquo;ReactDOM Fiber Async&rsquo;" ></p>

<p>このとき、HostのViewに反映するといった副作用をこのbeginWork〜completeWorkの中で行わないというのは1つのポイントです。
例えば、Viewへの反映をこの非同期処理の中で行ってしまうと、Viewが部分部分更新される形になり、UIがガタガタしてしまいます。
React Fiberでは、commitWorkで全てのViewへの更新をまとめて行うため、このようなことは起こりません。
逆にcommitWorkの部分は時間がかかりやすくframeを落としてしまうこともあるためパフォーマンスチューニングが注意深く行われています。
componentDid(Mount|Update)もこの中で行われるため、この中で重い処理を行わないように注意が必要です。</p>

<p>余談ですが、上記のようにライフサイクルメソッドがボトルネックになる場面が想定されるため、ライフサイクルメソッドをPromiseを返す非同期なAPIとする案もあります。
あと、実はマウント時はcompleteWorkでもSideEffectが処理されています。これはマウント時にはまだHostContainerはDOMに追加されていないため追加しても表示されず問題ないためです。
これもcommitWorkでframeを落とさないための工夫の1つです。</p>

<p>また、上記のようなrequestIdleCallbackを使ったスケジュール以外にも、優先度に応じたスケジューリングも可能です。
優先度は下記のように定義されています。</p>

<p>```js</p>

<pre><code>export type PriorityLevel = 0 | 1 | 2 | 3 | 4 | 5 | 6;

module.exports = {
  NoWork: 0, // No work is pending.
  SynchronousPriority: 1, // For controlled text inputs. Synchronous side-effects.
  TaskPriority: 2, // Completes at the end of the current tick.
  AnimationPriority: 3, // Needs to complete before the next frame.
  HighPriority: 4, // Interaction that needs to complete pretty soon to feel responsive.
  LowPriority: 5, // Data fetching, or result from updating stores.
  OffscreenPriority: 6, // Won't be visible but do the work in case it becomes visible.
};
</code></pre>

<p>```</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactPriorityLevel.js">https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactPriorityLevel.js</a></li>
</ul>


<p>更新処理に優先度を持たせることで、ユーザーインタラクションやアニメーションなどの更新処理を、APIレスポンスの反映など、優先度の低いタスクが邪魔しないようにすることができます。</p>

<p>下記はそれを表したサンプルです。「Async mode」の場合、5000個のlist itemは100ms毎に<code>LowPriority</code>で更新されます。「Sync mode」の場合は<code>SynchronousPriority</code>として同期的にレンダリングされます。</p>

<ul>
<li><a href="https://koba04.github.io/react-fiber-resources/examples/">https://koba04.github.io/react-fiber-resources/examples/</a></li>
</ul>


<p>上にある入力フィールドに何か入力してください。「Async mode」の場合は入力中はlist itemが更新されず、入力も多少引っかかりますがスムーズに反映されます。「Sync mode」の場合は入力中もlist itemが更新されてユーザーの入力を邪魔してしまっています。</p>

<p>優先度の低い処理はrequestIdleCallbackを使ってアイドル時間がある時に、優先度の高い処理はrequestAnimationFrameを使うか同期的にASAPで反映されます。</p>

<p>優先度の低いタスクを実行中に、優先度の高いタスクが割り込んで来た場合、優先度の低いタスクは中断されて、優先度の高いタスクが先に行われます。
優先度の高いタスクが終了後、再び優先度の低いタスクが実行されます。
この際、割り込まれる前に優先度の低いタスクが実行していたFiberのうち、優先度の高いタスクが処理しなかったものは再利用されます。</p>

<p>このように、タスクの割り込みによっては複数回Fiberが処理されることがあるため、非同期のレンダリングの場合には、componentWillMountなどのライフサイクルメソッドが複数回呼び出されることがあります。componentDidMountなどはcommitWorkで呼ばれるため複数回呼ばれることはありません。</p>

<p>また、OffscreenPriorityというPriorityがあります。これを利用することで初回のレンダリングでは必要ない部分をプリレンダリングしたり、ダブルバッファリングが可能となります。ReactDOMでは、<code>hidden</code>属性のあるものはOffscreenPriorityとして扱われます。</p>

<p>他にもAnimationPriorityなどのPriorityがありますが、現時点ではまだPriorityを制御するようなAPIはないため、どのように利用するのかは見えていません。（facebook.comでの非同期レンダリングの実験をやりながらAPIを決めていくらしい）</p>

<p>その他の細かい挙動については、<code>ReactIncremental-test.js</code>のテストを見るとどんなことができるのかわかるかと思います。</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/__tests__/ReactIncremental-test.js">https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/__tests__/ReactIncremental-test.js</a></li>
</ul>


<p>ここで使われている<code>ReactNoop</code> というrendererはテスト用のrendererです。UIは全く持っておらずテスト用に<code>timeRemaining</code> などが柔軟に制御可能であり、React Fiberの開発は初期の頃はこのrendererに対して行われていました。custom rendererを作る際の参考にもいいかもしれません。</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/noop/ReactNoop.js">https://github.com/facebook/react/blob/master/src/renderers/noop/ReactNoop.js</a></li>
</ul>


<h2>Error Boundary</h2>

<p>あと、Fiber自体には直接関係ないですが、Error Boundaryの機能も公式にサポートされるようになりそうです。
Error Boundaryとは、これまでは子孫Componentのrender時にエラーが発生した場合は、何も表示されなくなってしまいましたが、Error Boundaryの機能を使うことで握り潰したりエラーハンドリングができるようになるものです。</p>

<p>```js</p>

<pre><code>class App extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            error: null
        };
    }
    // エラーハンドリングを定義する
    unstable_handleError(error) {
        this.setState({error});
    }
    render() {
        if (this.state.error) {
            return &lt;div&gt;エラーが発生しました&lt;/div&gt;;
        }
        return this.props.children;
    }
}
</code></pre>

<p>```</p>

<h2>CoroutineComponent</h2>

<p>Fiberには<code>CoroutineComponent</code> や<code>CoroutineHandlerPhase</code> や<code>YieldComponent</code>といったComponentもあります。これはどうやら、親のComponentのレンダリングを途中で止めて、子のComponentからの結果を受けて親のComponentのレンダリングを再開するみたいなこともできるっぽいです（あんまりわかってない）。例えばレイアウトを行うComponentで子を実際にレンダリングしてみて、サイズなどの結果を持って親のComponentを再度レンダリングするみたいなことが、ユースケースとしてどこかで説明されていました。</p>

<p>これの動作については、上記であげた<code>ReactCoroutin-test.js</code> の中にあるので見てみるといいかと思います。状態としてはとりあえず動いてるっぽいという感じだとは思います。</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/__tests__/ReactCoroutine-test.js">https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/__tests__/ReactCoroutine-test.js</a></li>
</ul>


<h2>Custom Renderer</h2>

<p>Stackでは、Custom Rendererを作成するためにはハックが必要でしたが、React FiberではFlowによって型付けされているため、わかりやすくなりました。</p>

<p>```js</p>

<pre><code>export type HostConfig&lt;T, P, I, TI, PI, C, CX, PL&gt; = {
  getRootHostContext(rootContainerInstance: C): CX,
  getChildHostContext(parentHostContext: CX, type: T): CX,
  getPublicInstance(instance: I | TI): PI,

  createInstance(
    type: T,
    props: P,
    rootContainerInstance: C,
    hostContext: CX,
    internalInstanceHandle: OpaqueHandle,
  ): I,
  appendInitialChild(parentInstance: I, child: I | TI): void,
  finalizeInitialChildren(
    parentInstance: I,
    type: T,
    props: P,
    rootContainerInstance: C,
  ): boolean,

  prepareUpdate(
    instance: I,
    type: T,
    oldProps: P,
    newProps: P,
    rootContainerInstance: C,
    hostContext: CX,
  ): null | PL,
  commitUpdate(
    instance: I,
    updatePayload: PL,
    type: T,
    oldProps: P,
    newProps: P,
    internalInstanceHandle: OpaqueHandle,
  ): void,
  commitMount(
    instance: I,
    type: T,
    newProps: P,
    internalInstanceHandle: OpaqueHandle,
  ): void,

  shouldSetTextContent(props: P): boolean,
  resetTextContent(instance: I): void,
  shouldDeprioritizeSubtree(type: T, props: P): boolean,

  createTextInstance(
    text: string,
    rootContainerInstance: C,
    hostContext: CX,
    internalInstanceHandle: OpaqueHandle,
  ): TI,
  commitTextUpdate(textInstance: TI, oldText: string, newText: string): void,

  appendChild(parentInstance: I | C, child: I | TI): void,
  insertBefore(parentInstance: I | C, child: I | TI, beforeChild: I | TI): void,
  removeChild(parentInstance: I | C, child: I | TI): void,

  scheduleAnimationCallback(callback: () =&gt; void): number | void,
  scheduleDeferredCallback(
    callback: (deadline: Deadline) =&gt; void,
  ): number | void,

  prepareForCommit(): void,
  resetAfterCommit(): void,

  useSyncScheduling?: boolean,
};
</code></pre>

<p>```</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactFiberReconciler.js">https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactFiberReconciler.js</a></li>
</ul>


<p>実際に実装する際には、先ほど紹介した<code>ReactNoop</code> や、Test用のrendererでありReactElementからJSONを返す<code>ReactTestRenderer</code> や<code>ReactART</code> などが参考になると思います。</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/testing/ReactTestRendererFiber.js">https://github.com/facebook/react/blob/master/src/renderers/testing/ReactTestRendererFiber.js</a></li>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/art/ReactARTFiber.js">https://github.com/facebook/react/blob/master/src/renderers/art/ReactARTFiber.js</a></li>
</ul>


<p>ただ、Reactはv16からFlat bundleになり、内部ライブラリーを<code>react/lib/xxx</code>のように利用出来なくなったので、Custom Renderer作る人向けに何かが提供されるのかは不明なところです。</p>

<h2>Server Side Rendering</h2>

<p>サーバーサイドレンダリングについては、Facebookで使っていないということもあり後回しになっていて、まだ実装されていません。
ただ、今までの<code>renderToString</code> は完全に同期でしたが、ReactFiberになることでイベントループをブロックしないようにHTML文字列を生成することは簡単になりそうです（v16には入るかどうかは不明）。<code>renderToStream</code> みたいなのは、副作用はcommitWorkでまとめてやるというところからは外れてしまうのでどうなんでしょうね。</p>

<h2>v16でも非同期レンダリングを試したい</h2>

<ul>
<li>現時点では、<code>ReactDOMFeatureFlags</code> に<code>fiberAsyncScheduling</code> というフラグがあるので、それを無理やり<code>true</code> に書き換えることでデフォルトで非同期のレンダリングに出来ます。ただまだそんなにテストされていないと思うのでバグなどはありそうです</li>
<li>または、<code>ReactDOM.unstable_deferredUpdates</code> を使うとその中の更新処理は<code>lowPriority</code> として処理されるため、非同期となります</li>
</ul>


<h2>その他リソース</h2>

<p>Fiberで何が嬉しいのかを知りたい人は、F8のTom OcchinoのTalkがとてもわかりやすいと思います。</p>

<ul>
<li>The Evolution of React and GraphQL at Facebook and Beyond

<ul>
<li><a href="https://developers.facebook.com/videos/f8-2017/the-evolution-of-react-and-graphql-at-facebook-and-beyond/">https://developers.facebook.com/videos/f8-2017/the-evolution-of-react-and-graphql-at-facebook-and-beyond/</a></li>
</ul>
</li>
</ul>


<p>Lin ClarkがReact ConfでCode Cartoonを使ってReact Fiberについて説明していたのもわかりと思います。</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/ZCuYPiUIONs?ecver=1" frameborder="0" allowfullscreen></iframe>


<p>あとはSebastian MarkbågeのReact ConfのキーノートでもReact Fiberについて触れられています。</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/bvFpe5j9-zQ?ecver=1" frameborder="0" allowfullscreen></iframe>


<p>あとは、個人的にReact Fiberについてまとめたリポジトリもあります。</p>

<ul>
<li><a href="https://github.com/koba04/react-fiber-resources">https://github.com/koba04/react-fiber-resources</a></li>
</ul>


<h2>で結局何が嬉しいの？</h2>

<p>React Fiberに変わることで、よくフレームワークのパフォーマンス比較にあるようなベンチマークのスコアがよくなるといったことはおそらくないと思います。
React Fiberになることで、これまで同期的にツリーを処理していくしかなかったものが非同期に、より柔軟に処理出来るようになるのがメリットです。
これにより、アニメーションやユーザーのインタラクションに対して可能な限り早く反応出来るように出来ます。また、このような基盤としてReact Fiberがあるので、今後そういった機能追加が行われていくのではないかと思います。</p>

<p>というで、v16ではそんなに変わりませんが、今後の機能追加を楽しみにしましょう。
また、React Fiberの実装も勉強になるので興味のある人は是非読んでみてください。</p>

<p>ちなみにReact Fiberの最初のPRはこれのようですね。</p>

<ul>
<li><a href="https://github.com/facebook/react/pull/6690">https://github.com/facebook/react/pull/6690</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React v15.5(6) and v16]]></title>
    <link href="http://blog.koba04.com/post/2017/04/14/react-dot-js-v155-and-v16/"/>
    <updated>2017-04-14T14:00:05+09:00</updated>
    <id>http://blog.koba04.com/post/2017/04/14/react-dot-js-v155-and-v16</id>
    <content type="html"><![CDATA[<p>Reactのv15.5がリリースされたので、v15.5での変更点とv16についてのまとめです。</p>

<ul>
<li><a href="https://facebook.github.io/react/blog/2017/04/07/react-v15.5.0.html">https://facebook.github.io/react/blog/2017/04/07/react-v15.5.0.html</a></li>
</ul>


<p>v15.5はバグフィックスとv16での変更点に対する準備なので、可能ならあげておいた方がスムーズにv16がリリースされた時に対応できると思います。</p>

<p>基本的には、v16で色々と廃止するための警告が主になります。
最近のバージョンと同様に、コアから必要なもの以外をどんどん削ぎ落としていく流れです。</p>

<p>この警告に対応するために、Enzymeなどでは利用するために必要なライブラリーが変更されているので更新する際には注意が必要です。</p>

<p>また、当初の予定ではv15.5がv15系の最後のリリースになる予定でしたが、上記のような混乱もあったためフォローアップとしてv15.6もリリースされることになりました。
なので、v15.6がリリースされてから対応するのもアリだと思います。</p>

<p>廃止されるものは色々ありますが、基本的に全てのものに対してマイグレーションのパスは提供されているので対応可能だと思います。
ただ、アクティブにメンテされていないくて15.5対応版をリリースしていないライブラリーを使っていると色々警告が出ると思います。
場合によっては、その警告によってテストが壊れることがあるかもしれません。</p>

<!-- more -->


<h2>Deprecated React.createClass</h2>

<p>廃止されること自体は前から言われていたので、使わないようにしていた人も多いと思いますが、<code>create-react-class</code>として別パッケージとなり、v16では<code>react</code>から削除されます。</p>

<p><code>js
import createReactClass from 'create-react-class';
</code></p>

<p>そのためv15.5では、<code>React.createClass</code>を使おうとすると警告が出ます。</p>

<p>自分の書いたコードで<code>React.createClass</code>を使っている場合は、<code>React.Component</code>を使ったComponent定義かStateless Functional Componentsに書き換える必要があります。</p>

<p>mixinを使っているなど、どうしても<code>React.createClass</code>を使いたい場合は<code>create-react-class</code>を使うこともできますが、可能な限りReact本体が提供する方法を利用する方がいいと思います。</p>

<p><code>React.createClass</code>から<code>React.Component</code>の定義に書き換えるcodemodも提供されているので、使ってみるのもいいかもしれません。</p>

<ul>
<li><a href="https://github.com/reactjs/react-codemod">https://github.com/reactjs/react-codemod</a></li>
</ul>


<p>このcodemodでは、<code>React.createClass</code>が提供するautobindを実現するために、property initializerのシンタックスを利用します。そのため、変換後は<code>babel-plugin-transform-class-properties</code>を使用する必要があります。(Stage 2)</p>

<ul>
<li><a href="http://babeljs.io/docs/plugins/transform-class-properties/">http://babeljs.io/docs/plugins/transform-class-properties/</a></li>
</ul>


<p>v16になった時点で<code>React.createClass</code>を使っているライブラリーを利用している場合には、PR送って対応してもらうか、<code>React.createClass</code>に<code>create-react-class</code>を代入するなどの対応が必要になるかもしれません。
(v15.5では、警告を出すために<code>React.createClass</code>には<code>Object.defineProperty</code>でgetterが設定されており、<code>configurable</code>でないので置き換えることはできません)</p>

<h2>Deprecated React.PropTypes</h2>

<p>これも、<code>React.createClass</code>と同様にずっと言われていましたが、<code>prop-types</code>として別パッケージとなり、v16では<code>react</code>から削除されます。</p>

<p><code>js
import PropTypes from 'prop-types';
</code></p>

<p>そのためv15.5では、<code>React.PropTypes</code>を使おうとすると警告が出るようになりました。</p>

<p>これもcodemodが提供されているので、それを使って一括で変換することができます。</p>

<ul>
<li><a href="https://github.com/reactjs/react-codemod#react-proptypes-to-prop-types">https://github.com/reactjs/react-codemod#react-proptypes-to-prop-types</a></li>
</ul>


<p>PropTypesに関しては、FlowやTypeScriptへの移行が勧められているもののハードルもあるので、別パッケージ化された<code>prop-types</code>をしばらく使い続けるのは選択肢としてあるのかなと思います。
今回別パッケージとなったのは組み込みのPropTypesのvalidationロジックであり、PropTypesのチェック機構自体がなくなることは、まだ予定されていないので。</p>

<p>ちなみに、将来的にAPIの変更が予定されているContextを使う場合にも、変わらず<code>prop-types</code>を使って指定します。
（実際には<code>contextTypes</code>の定義でマスクしているだけなので、<code>prop-types</code>を使う必要はないのですが）</p>

<h2>Deprecated Addons</h2>

<p>React本体がアドオンとして提供していた諸々が、廃止されたり別パッケージ化したり、移動したりしています。
v16では、<code>react-with-addons</code>のUMDビルドも提供されなくなります。</p>

<ul>
<li><code>react-addons-create-fragment</code>は、v16のFiber化により配列を返すことができるようになるため、多くの場面で不要となるので削除されます。</li>
<li><code>react-addons-css-transition-group</code>と<code>react-addons-transition-group</code>は、<code>react-transition-group</code>の別パッケージになりました。<code>CSSTransitionGroup</code>と<code>TransitionGroup</code>して利用できます。ただし、全く実装が一緒というわけではないので移行する際には注意が必要です。すでに修正済みですが下記のようなバグとかもあったりするので&hellip;。

<ul>
<li><a href="https://github.com/reactjs/react-transition-group">https://github.com/reactjs/react-transition-group</a></li>
<li><a href="https://github.com/reactjs/react-transition-group/pull/13">https://github.com/reactjs/react-transition-group/pull/13</a></li>
</ul>
</li>
<li><code>react-addons-linked-state-mixin</code>と<code>react-linked-input</code>は、明示的に<code>value</code>と<code>onChange</code>を指定すればいいので削除されます。</li>
<li><code>react-addons-pure-render-mixin</code>と<code>react-addons-shallow-compare</code>は、<code>React.PureComponent</code>を代わりに利用できます。</li>
<li><code>react-addons-update</code>は<code>immutability-helper</code>が代わりに利用できます。

<ul>
<li><a href="https://github.com/kolodny/immutability-helper">https://github.com/kolodny/immutability-helper</a></li>
</ul>
</li>
</ul>


<p><code>react-addons-test-utils</code>は、<code>react-dom</code>のrendererに依存している部分が多いため、<code>react-dom/test-utils</code>に移動されました。</p>

<p><code>js
import TestUtils from 'react-dom/test-utils';
</code></p>

<p>ShallowRenderに関しては<code>react-dom</code>に依存していないため、<code>react-test-renderer/shallow</code>に移動されました。
ちなみに<code>react-test-renderer</code>はJestがsnapshot testingで使っていたりする、ReactElementをJSONとして返すrendererです。
ShallowRenderは、これのトップレベルのComponentまでしかrenderしない版として考えることができます。</p>

<p><code>js
import {createRenderer} from 'react-test-renderer/shallow';
</code></p>

<p><del><code>react-addons-perf</code>だけは、特に何もなくこのままですが、<code>react-addons-perf</code>は同期的なrenderが前提となっているため、将来的にFiberで非同期的なrenderをする場合には正しく計測できません。</del></p>

<p><strong>[修正]</strong> <code>react-addons-perf</code>は同期的なrenderが前提となっていてFiberへの対応が難しいため、v16(Fiber)への対応は行われません。
Perfに変わる何かについては検討されるので、将来的に何か提供される可能性もありますが、とりあえずは<code>?react_perf</code>によるBrowser Timelineを使った計測が推奨されています。</p>

<ul>
<li><a href="https://facebook.github.io/react/docs/optimizing-performance.html#profiling-components-with-chrome-timeline">https://facebook.github.io/react/docs/optimizing-performance.html#profiling-components-with-chrome-timeline</a></li>
</ul>


<h2>15.6（予定）</h2>

<p><a href="https://github.com/facebook/react/issues/9398">https://github.com/facebook/react/issues/9398</a></p>

<ul>
<li><code>React.DOM.{p, div,...}</code>として提供されていたファクトリ関数が廃止となります。</li>
<li>APIの廃止などの警告は、これまでは<code>console.error</code>として出力されていましたが、<code>console.warn</code>で出力されるようになります。</li>
</ul>


<h2>16に向けて</h2>

<p>v16はすでに<code>@next</code>でインストールできます。
そのため、まだ実装されていないサーバーサイドレンダリングとShallowRenderを使っていない部分では試すことが可能です。</p>

<p><code>
npm i react@next react-dom@next
</code></p>

<h3>Fiber</h3>

<p>v16の一番大きな目玉は、Fiberに内部実装が置き換えられることです。
ただし、v16の時点ではFiberは現在のStackのrendererと互換性のあるモードで動作します。
そのため、Fiberの特徴である<code>requestIdleCallback</code>によってスケジューリングされた非同期なrenderではなく、同期的なrenderとなるため、利用者として大きな違いは感じないかもしれません。
（call stack見ると全く変わっていることがわかると思いますが）</p>

<p>文字列や配列をComponentでラップすることなく直接返すことができるのは嬉しい部分かもしれません。</p>

<p><code>js
const Text = ({text}) =&gt; text;
const List = () =&gt; [1, 2, 3];
</code></p>

<p>ちなみに、v16の時点でも<code>ReactDOM.unstable_deferredUpdates</code>を使うことで、非同期なrenderが出来るようにはなりそうです。
あとは、<code>ReactDOMFiber.js</code>にある<code>useSyncScheduling</code>というフラグを無理やり<code>false</code>にすればデフォルトで非同期なrenderになります。（軽く試した感じだと問題なく動いていた）</p>

<p>非同期のrenderをどのようにユーザー側のAPIとして見せるのかは、まだ明らかになっていなくてこれから議論していくようです。</p>

<p>Fiberについては、下記に集めたリソースを読むとわかると思います。（今後紹介的な何かを書くかも）</p>

<ul>
<li><a href="https://github.com/koba04/react-fiber-resources">https://github.com/koba04/react-fiber-resources</a></li>
</ul>


<p>最初に見るものとしてのおすすめは、Lin ClarkによるA Cartoon Intro to Fiber(React.js Conf 2017)です。</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/ZCuYPiUIONs?ecver=1" frameborder="0" allowfullscreen></iframe>


<p>互換モードによるFiber自体はfacebook.comでも問題なく動作しているようです。
ただし、サーバーサイドレンダリングに対する対応は、まだ全く入っておらず今後どうなっていくのかは不明です。FiberになるとStreaming renderingもやりやすくなるのではとは思いますが。</p>

<h3>No more direct import!</h3>

<p>v16からは、それぞれのエントリーポイントがRollupを使ってバンドルされたものになります。
なので下のような構造になります。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">react@next and react-dom@next are flat bundles! 👀 <a href="https://twitter.com/hashtag/reactjs?src=hash">#reactjs</a> <a href="https://t.co/5ezjjf08sd">pic.twitter.com/5ezjjf08sd</a></p>&mdash; Toru Kobayashi (@koba04) <a href="https://twitter.com/koba04/status/850180571653222400">April 7, 2017</a></blockquote>


<script async src="http://blog.koba04.com//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>これにより、初期ロード時間の短縮やサーバーサイドでのパフォーマンスの向上が見込まれています。
また、利用者側には関係ないですがビルド周りが見直されており、GruntやgulpやBrowserifyのタスクがリポジトリから削除されています。すっきり。</p>

<p>この変更による、一番大きな影響は<code>react/lib/xxxx</code>として直接Reactの内部ライブラリを利用しているライブラリが動作しなくなることです。
<code>enzyme</code>などのメジャーなライブラリはReact側でもケアされていますが、それ以外のライブラリーは壊れてどうにもならなくなることがあるかもしれません。
したがって、そのようなハックをしているライブラリーを利用している場合は注意した方がよさそうです。</p>

<h3>リリース？</h3>

<p>ちなみにv16は、夏くらい(?)をターゲットに考えているようです。</p>

<p>また何か動きがあれば追記するかも。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React.js Links vol.12]]></title>
    <link href="http://blog.koba04.com/post/2016/09/30/reactjs-links-vol12/"/>
    <updated>2016-09-30T14:00:10+09:00</updated>
    <id>http://blog.koba04.com/post/2016/09/30/reactjs-links-vol12</id>
    <content type="html"><![CDATA[<p>これはReactに関する記事や気になるissueなどのリンクを紹介する記事です。</p>

<!-- more -->


<h2>React v15.3.2</h2>

<ul>
<li><a href="https://github.com/facebook/react/releases/tag/v15.3.2">https://github.com/facebook/react/releases/tag/v15.3.2</a></li>
</ul>


<p>React v15.3.2がリリースされています。
細かなバグフィックスなどが中心です。</p>

<h2>Our First 50,000 Stars</h2>

<ul>
<li><a href="https://facebook.github.io/react/blog/2016/09/28/our-first-50000-stars.html">https://facebook.github.io/react/blog/2016/09/28/our-first-50000-stars.html</a></li>
</ul>


<p>ReactのGitHubでのstarが50,000を超えたことを記念するエントリーです。
Reactの前にはFaxJSというのがあって〜など、Reactが誕生するまでの流れの話などとても面白いです。</p>

<h2>Codebase Overview</h2>

<ul>
<li><a href="https://facebook.github.io/react/contributing/codebase-overview.html">https://facebook.github.io/react/contributing/codebase-overview.html</a></li>
</ul>


<p>React本体のコードについての解説です。
Reactを使う人にとってはほとんど知る必要のないことですが、contributeしたい場合にはとても役に立つドキュメントです。
特に<code>Haste</code>とというCommonJSではないFacebook独自のモジュールシステムを使っていたりするので&hellip;。
最初からこれがあれば&hellip;。</p>

<h2>If TypeScript is so great, how come all notable ReactJS projects use Babel?</h2>

<ul>
<li><a href="https://discuss.reactjs.org/t/if-typescript-is-so-great-how-come-all-notable-reactjs-projects-use-babel/4887">https://discuss.reactjs.org/t/if-typescript-is-so-great-how-come-all-notable-reactjs-projects-use-babel/4887</a></li>
</ul>


<p>TypeScriptが最高なら、どうしてReact周りのプロジェクトはみんなBabelを使っているの？という疑問に対するスレッドです。
FlowTypeとTypeScriptの違いなどの話も登場して面白いです。</p>

<h2>Redux Patterns and Anti-Patterns</h2>

<ul>
<li><a href="https://tech.affirm.com/redux-patterns-and-anti-patterns-7d80ef3d53bc">https://tech.affirm.com/redux-patterns-and-anti-patterns-7d80ef3d53bc</a></li>
</ul>


<p>Reduxでのアンチパターンについての記事です。
Immutable.jsと組み合わせた場合や、redux-thunkでのAPIアクセスの書き方について解説されています。</p>

<h2>You Might Not Need Redux</h2>

<ul>
<li><a href="https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367">https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367</a></li>
</ul>


<p>Dan Abramov自身によるエントリーで、何も考えずにとりあえずRedux使うのをやめようという記事です。</p>

<h2>Declarative Routing for React</h2>

<ul>
<li><a href="https://react-router-website-uxmsaeusnn.now.sh/">https://react-router-website-uxmsaeusnn.now.sh/</a></li>
</ul>


<p>react-router v4についてのページです。
react-routerでは、Reactのためのルーティングライブラリーではなく、Reactを使ったルーティングライブラリーになっています。
そのため、<code>Match</code>や<code>Redirect</code>といったComponentが登場しており、議論を呼びそうな感じの変わり方をしています。
（反応を見ていると、概ねポジティブに捉えられているのがビックリですが）</p>

<h2>AMA with Redux</h2>

<ul>
<li><a href="https://hashnode.com/ama/with-redux-cisteui6p005gzx53fstg8t6l">https://hashnode.com/ama/with-redux-cisteui6p005gzx53fstg8t6l</a></li>
</ul>


<p>Reduxの作者であるDan Abramovと初期からの開発者であるAndrew ClarkによるAMAです。
Reduxについての実際に作った人たちの考えが説明されているので、興味のある人は読むといいと思います。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React.js meetup #4]]></title>
    <link href="http://blog.koba04.com/post/2016/09/30/reactjs-meetup-vol4/"/>
    <updated>2016-09-30T13:56:56+09:00</updated>
    <id>http://blog.koba04.com/post/2016/09/30/reactjs-meetup-vol4</id>
    <content type="html"><![CDATA[<p>前回が2月だったので約半年振りですが、React.js meetup #4を開催しました。</p>

<ul>
<li><a href="http://reactjs-meetup.connpass.com/event/39793/">http://reactjs-meetup.connpass.com/event/39793/</a></li>
</ul>


<p>今回は <strong>67/80人</strong> の方が参加してくださりました！感謝！</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">たくさんの方に参加してもらって感謝！！ <a href="https://twitter.com/hashtag/reactjs_meetup?src=hash">#reactjs_meetup</a> <a href="https://t.co/1tTO5gKDxP">pic.twitter.com/1tTO5gKDxP</a></p>&mdash; Toru Kobayashi (@koba04) <a href="https://twitter.com/koba04/status/780747386251415552">September 27, 2016</a></blockquote>


<script async src="http://blog.koba04.com//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>今回も、前回同様にサイボウズさんに会場を提供して頂き開催することができました。
 サイボウズの皆様、参加者の皆様、発表者の皆様ありがとうございました！！</p>

<!-- more -->


<h2>本編</h2>

<p>今回はメインのTalk(20min)が4本、LT(10min)が4本とかなり多く、さらにそれぞれのTalkもかなり濃かったので、その場では消化しきれなかった方も多かったのではないでしょうか。
資料も公開されているので、是非見返してみてください。</p>

<ul>
<li><a href="http://reactjs-meetup.connpass.com/event/39793/presentation/">http://reactjs-meetup.connpass.com/event/39793/presentation/</a></li>
</ul>


<p>Tweetはここにまとめてあります。</p>

<ul>
<li><a href="http://togetter.com/li/1029915">http://togetter.com/li/1029915</a></li>
</ul>


<p>さらに今回は、直前に<a href="https://twitter.com/cpojer">@cpojer</a>さんから、ちょうど日本にいるタイミングなので参加したいという連絡があり、急遽JestについてのLTをしてもらいました。</p>

<p>Jestは、最近になってものすごい勢いで開発されていて、全く別のライブラリーと言えるくらい進化しているので、それを紹介できる機会になってよかったなぁと思っています。</p>

<ul>
<li><a href="http://facebook.github.io/jest/">http://facebook.github.io/jest/</a></li>
</ul>


<p>後、これまでは先着での受付にしていたのですが、すぐに埋まってしまうので今回は抽選にしました。
Twitterのpollを見る感じでも、抽選の方がよさそうですね。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr">ちなみに次回 <a href="https://twitter.com/hashtag/reactjs_meetup?src=hash">#reactjs_meetup</a> やるとしたら、募集方法は抽選と先着のどちらがいいですか？</p>&mdash; Toru Kobayashi (@koba04) <a href="https://twitter.com/koba04/status/780705408335753222">September 27, 2016</a></blockquote>


<script async src="http://blog.koba04.com//platform.twitter.com/widgets.js" charset="utf-8"></script>


<h2>React.js meetupについて</h2>

<p>そういえば、React.js meetupをどんな感じでやっているかを書いてなかったので、少しだけ書いてみます。</p>

<p>React.js meetupは、メインのTalkは全てこちらからお願いして決めています。
<a href="https://twitter.com/koba04">@koba04</a> が個人的に聞きたいものや多くの人が関心のありそうなテーマから選んでいます。
それを普段からアウトプットしている方にお願いしています。</p>

<p>その結果、React.js meetupはクオリティの高いTalkが聞ける場だと思ってもらえていたら嬉しいなと思っています。</p>

<p>LTは、新しい発見の場として募集で受付けています。5minだと短いので10minで。
(これはNode学園を参考にしました)</p>

<p>毎回面白いTalkが多いのでいつも楽しみにしています。</p>

<p>それを<a href="https://twitter.com/yosuke_furukawa">@yosuke_furukawa</a>や<a href="https://twitter.com/teppeis">@teppeis</a>や<a href="https://twitter.com/yoshiko_pg">@yoshiko_pg</a>や、<a href="https://twitter.com/ama_ch">@ama_ch</a>に相談したり、会場を探したり、色々と準備を手伝ってもらいながら運営しています。</p>

<p>（<a href="http://reactjs-meetup.connpass.com/event/19504/">#2</a>に関しては、別のイベントとしてすでにあったものをReact.js meetupという名前を使う形にしたのでちょっと違いますが）</p>

<p>そんな感じで小さくやっているので、あまり規模を拡大したり、頻繁に開催するといったことは考えていません。
すでにReactに関するイベントはたくさん行なわれていると思うので。</p>

<p>基本的には、自分たちが楽しむためにやっている感じです。
聞きたいTalkを聞いて、参加者の人とディスカッションして。
（参加したけど知っている人がいないという人は是非声かけてください！）</p>

<p>実際のところ、当日は事前に懇親会の食べ物・飲み物を頼んでいたりするので参加率を気にしたり、ピザの配達状況を確認したりしているので、正直ちゃんとTalk聞けていないのですが&hellip;。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="ja" dir="ltr"><a href="https://twitter.com/hashtag/reactjs_meetup?src=hash">#reactjs_meetup</a> <br>yield pizza;<br><br>とのこと <a href="https://t.co/RDGQgcMKsz">pic.twitter.com/RDGQgcMKsz</a></p>&mdash; Yosuke FURUKAWA (@yosuke_furukawa) <a href="https://twitter.com/yosuke_furukawa/status/780737219464007682">September 27, 2016</a></blockquote>


<script async src="http://blog.koba04.com//platform.twitter.com/widgets.js" charset="utf-8"></script>


<h2>次回？</h2>

<p>今のところ、特に考えていないので、何か話したいこととか、聞きたいテーマなどあれば教えてください！
今回は詰め込みすぎたので、次回はメインのTalkは2本くらいにしようと思っています。</p>

<p>来年かな。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React.js Links vol.11]]></title>
    <link href="http://blog.koba04.com/post/2016/09/07/reactjs-links-vol11d/"/>
    <updated>2016-09-07T19:26:04+09:00</updated>
    <id>http://blog.koba04.com/post/2016/09/07/reactjs-links-vol11d</id>
    <content type="html"><![CDATA[<p>これはReactに関する記事や気になるissueなどのリンクを紹介する記事です。</p>

<!-- more -->


<h2>React Core Meeting Notes</h2>

<p>7/21, 28, 8/4, 25のMeeting Noteがまとめて公開されました。</p>

<p><code>React.createClass</code>のES classes化については、引き続き進められているようで、すでに80%がES classesになったそうです。
Public Class Fieldsがstage2になったことも紹介されています。</p>

<p>その他には、<code>create-react-app</code>をリリースしたことや、そこでのJestサポートについても紹介されています。
また7/28のMeeting Noteでは、Reconcilerの位置付けについて解説されています。Reconcilerはrendererに属するものであり、react本体にはComponentやReactElementを作成する部分のみが含まれているという形です。
それにより、新しいReactFiberのReconcilerの導入もすでにあるReact Componentに手を入れることなくできるとしています。</p>

<p>（Reactの中では、完全にrenderer毎にコードが分かれているわけではなくて、共通化されている部分もありますが）</p>

<ul>
<li><a href="https://github.com/reactjs/core-notes/blob/master/2016-07/july-21.md">https://github.com/reactjs/core-notes/blob/master/2016-07/july-21.md</a></li>
<li><a href="https://github.com/reactjs/core-notes/blob/master/2016-07/july-28.md">https://github.com/reactjs/core-notes/blob/master/2016-07/july-28.md</a></li>
<li><a href="https://github.com/reactjs/core-notes/blob/master/2016-08/august-04.md">https://github.com/reactjs/core-notes/blob/master/2016-08/august-04.md</a></li>
<li><a href="https://github.com/reactjs/core-notes/blob/master/2016-08/august-25.md">https://github.com/reactjs/core-notes/blob/master/2016-08/august-25.md</a></li>
</ul>


<h2>PATTERNS FOR STYLE COMPOSITION IN REACT</h2>

<p>CSS in JSでのパターン集です。</p>

<ul>
<li><a href="http://jxnblk.com/writing/posts/patterns-for-style-composition-in-react/">http://jxnblk.com/writing/posts/patterns-for-style-composition-in-react/</a></li>
</ul>


<h2>Strip flow-only class props without needing transform-class-properties. #3655 (Babel)</h2>

<p><code>babel-plugin-transform-flow-strip-types</code>でtype annotationのためだけに使われているclass propertiesを削除するというPRです。
これがmergeされると、Flowのtype annotationのためだけに<code>babel-plugin-transform-class-properties</code>を追加する必要はなくなります。</p>

<ul>
<li><a href="https://github.com/babel/babel/pull/3655">https://github.com/babel/babel/pull/3655</a></li>
</ul>


<h2>exponentjs/exponent</h2>

<p>ReactEurope 2016でAndroid版の事例を紹介していたReactNativeで作られたExponentのiOS/Android版が公開されています。</p>

<ul>
<li><a href="https://github.com/exponentjs/exponent">https://github.com/exponentjs/exponent</a></li>
</ul>


<h2>react-history</h2>

<p><code>history</code>をラップしたようなReactComponentです。
<code>react-router</code>のv4はこれを使うというような話もあり、あいかわらず落ち着かない感じです&hellip;。</p>

<ul>
<li><a href="https://github.com/ReactTraining/react-history">https://github.com/ReactTraining/react-history</a></li>
</ul>


<h2>Animating in React</h2>

<p>ReactでのAnimationの方法についてのスライドです。
codepenによるサンプルも多く埋め込まれており、とてもわかりやすいです。</p>

<p>CSS、DOM、SVG、Canvasなどによるアプローチの比較や、react-motionなどライブラリーに関する解説もあり、アニメーションで悩んでいる人にはおすすめのスライドです。</p>

<ul>
<li><a href="http://slides.com/sdrasner/react-rally#/">http://slides.com/sdrasner/react-rally#/</a></li>
</ul>


<h2>Async Redux Actions With RxJS</h2>

<p>NetflixのエンジニアでRxJSの開発者であるBen Leshによる、redux-observableを使ってReduxとRxJSを組み合わせる話です。
なぜReduxにRxJSを組み合わせる必要があるのか、redux-observableにあるEpicとは何なのかということがわかりやすく解説されています。</p>

<ul>
<li><a href="http://www.slideshare.net/benlesh1/async-redux-actions-with-rxjs-react-rally-2016">http://www.slideshare.net/benlesh1/async-redux-actions-with-rxjs-react-rally-2016</a></li>
</ul>


<h2>React: Facebook&rsquo;s Functional Turn on Writing JavaScript</h2>

<p>Reactの初期の開発者であるPete Huntと、現在の開発者であるPaul O'Shannessyに対するReactに関するインタビューです。
Reactの思想などについて語られていて、面白いです。</p>

<ul>
<li><a href="http://queue.acm.org/detail.cfm?id=2994373">http://queue.acm.org/detail.cfm?id=2994373</a></li>
</ul>

]]></content>
  </entry>
  
</feed>

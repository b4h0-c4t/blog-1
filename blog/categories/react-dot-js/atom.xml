<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: react.js | blog.koba04.com]]></title>
  <link href="http://blog.koba04.com/blog/categories/react-dot-js/atom.xml" rel="self"/>
  <link href="http://blog.koba04.com/"/>
  <updated>2015-09-11T23:50:42+09:00</updated>
  <id>http://blog.koba04.com/</id>
  <author>
    <name><![CDATA[koba04]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[React.js meetup #2を開催しました]]></title>
    <link href="http://blog.koba04.com/post/2015/09/09/reactjs-meetup2/"/>
    <updated>2015-09-09T22:53:58+09:00</updated>
    <id>http://blog.koba04.com/post/2015/09/09/reactjs-meetup2</id>
    <content type="html"><![CDATA[<ul>
<li><a href="http://reactjs-meetup.connpass.com/event/19504/">http://reactjs-meetup.connpass.com/event/19504/</a></li>
<li><a href="http://eventdots.jp/eventreport/568979">http://eventdots.jp/eventreport/568979</a></li>
</ul>


<p>4月に#1をやってから約4ヶ月くらい経ちましたがReact.js meetup #2を開催しました。</p>

<p>雨の中来てくださった方、発表者の方、運営のお手伝いをしてくださった方ありがとうございました！</p>

<!-- more -->


<h2>開催の経緯</h2>

<p>最初は今回発表してくださったViktorさんが来日されるのでそれにあわせてイベントをやるという話があり、せっかくなのでということでReact.js meetupの2回目としてやることになりました。</p>

<h2>dots</h2>

<p>開催予定日まで時間もなくてその時点で話す人も決まっていたので後は会場を決めればなんとかなりそうということで、いくつかの選択肢の中から今回はdotsさんで開催することになりました。
渋谷の駅から近くて、人数も200人近く入れるし会場もオシャレな感じだったのでここだ！という感じで決めました。</p>

<blockquote class="twitter-tweet" lang="en"><p lang="ja" dir="ltr"><a href="https://twitter.com/hashtag/reactjs_meetup?src=hash">#reactjs_meetup</a> #2 at dots!! (@ dots. in 渋谷区, 東京都) <a href="https://t.co/os56mGdfFu">https://t.co/os56mGdfFu</a> <a href="http://t.co/2BhpBeIK9H">pic.twitter.com/2BhpBeIK9H</a></p>&mdash; Toru Kobayashi (@koba04) <a href="https://twitter.com/koba04/status/641186091891073024">September 8, 2015</a></blockquote>


<script async src="http://blog.koba04.com//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>募集開始の際にはご迷惑をお掛けしましたが&hellip;dotsさん、ありがとうございました！</p>

<h2>準備など</h2>

<p>今回は <a href="https://twitter.com/yoshiko_pg">@yoshiko_pg</a> さんから話をもらって、その後の色々な準備もほとんどやってもらって本当に感謝でした。ありがとうございます！
当日の準備や受付は <a href="http://goodpatch.com/jp">Goodpatch</a> の方々がやってくださり、お菓子も提供して頂いて本当にありがたかったです。仲良さそうな感じが印象的でした。ありがとうございます！</p>

<h2>Talk</h2>

<p>各Talkのスライドはここにあるので見てください。</p>

<p><a href="http://reactjs-meetup.connpass.com/event/19504/">http://reactjs-meetup.connpass.com/event/19504/</a></p>

<p>自分のTalkはReactの次のバージョンである0.14での変更点について話しました。予想としてはRC版が出てるはずだったのですが&hellip;。
Stateless Componentsが加わったりはしていますが、基本的には無駄な機能は削ぎ落としたりメンテナンス性を維持していくための変更が多い印象で正しい方向に向かっている印象を持っています。</p>

<p>全体を通してReduxのような最近注目されているようなTopicから、Flowtypeのような型付けやDDDなどReact.jsやFluxを使って実際に大規模なアプリを作っていく中で求められるようなTopicについての話まであって面白かったです。</p>

<p>FlowtypeがもっとFacebook以外でも使いやすくコントリビュートしやすくなっていくといいなーと思いながら、それには壁がいくつもありそうだなとViktorさんと話して感じたり。</p>

<p>後、LTを一句で締めるのとてもよかったです。</p>

<h2>当日の様子</h2>

<p><a href="http://togetter.com/li/871189">http://togetter.com/li/871189</a></p>

<p>感想とか書いてもらえると嬉しいです！</p>

<h2>次回？</h2>

<p>まったく何も考えていないので、聞きたいテーマなどあれば教えてもらえると嬉しいです！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React.js meetup #1 を開催しました]]></title>
    <link href="http://blog.koba04.com/post/2015/04/25/reactjs-meetup1/"/>
    <updated>2015-04-25T17:11:35+09:00</updated>
    <id>http://blog.koba04.com/post/2015/04/25/reactjs-meetup1</id>
    <content type="html"><![CDATA[<p><a href="http://reactjs-meetup.connpass.com/event/11232/">http://reactjs-meetup.connpass.com/event/11232/</a></p>

<p>一人Advent Calendar書いた時にやりたいと言っていたのでReact.js meetup #1 を<a href="http://twitter.com/yosuke_furukawa">@yosuke_furukawa</a>さんと開催しました。</p>

<p> DeNAさんが会場から懇親会のお酒や寿司、当日の運営まで全てやってくださったので自分はほとんど何もしてないですが..。
 本当にありがとうございました！！</p>

<p>やりたいって言ってこの規模の勉強会を開催させてもらえるの本当にスゴいなぁと思います&hellip;。</p>

<p> <blockquote class="twitter-tweet" lang="en"><p><a href="https://twitter.com/hashtag/reactjs_meetup?src=hash">#reactjs_meetup</a> <a href="https://twitter.com/hashtag/react_sushi?src=hash">#react_sushi</a> です <a href="http://t.co/GdpyF7Paqk">pic.twitter.com/GdpyF7Paqk</a></p>&mdash; Toru Kobayashi (@koba04) <a href="https://twitter.com/koba04/status/591580062702383107">April 24, 2015</a></blockquote></p>

<script async src="http://blog.koba04.com//platform.twitter.com/widgets.js" charset="utf-8"></script>




<!-- more -->


<p>ある程度予想はしていたのですが、Talkが10分と短かったりで押して慌ただしい感じになってしまったのは申し訳なかったなぁと思ってます。
ただ、色んなテーマのTalkを一度に聞くことが出来たのはよかったかなと思っています。</p>

<h2>Talks</h2>

<p>各Talkの資料についてはconpassのページに追加しておいたのでそちらを見て頂くとして簡単な一言感想です。</p>

<p><a href="http://reactjs-meetup.connpass.com/event/11232/presentation/">http://reactjs-meetup.connpass.com/event/11232/presentation/</a></p>

<h3><a href="https://twitter.com/naoya_ito">@naoya_ito</a> &ndash; React概論</h3>

<p>Reactの特徴をわかりやすく説明していてReact.js触ってない人にとってもわかりやすい説明だったんじゃないかなと思います。</p>

<h3><a href="https://twitter.com/hokaccha">@hokaccha</a> &ndash; react-rails</h3>

<p>Railsと一緒に使いたい人にとってはかなり有益な情報だったんじゃないかなと思います。Turbolinksどうするのとか。</p>

<h3><a href="https://twitter.com/azu_re">@azu_re</a> &ndash; 10分で実装するFlux</h3>

<p>Fluxを最小限の構成にしてデータの流れを一方向にするということがどういうことなのか説明していてわかりやすかったです。console.traceを使っての説明もなるほどなぁと思いました。</p>

<h3><a href="http://twitter.com/yosuke_furukawa">@yosuke_furukawa</a> &ndash; mercury/mithril.js</h3>

<p>React.jsのVIRTUAL DOMのdiffアルゴリズムの説明からmercuryやmithril.jsといった他のライブラリがどうやってReact.jsより高速化しているのかという説明で面白かったです。</p>

<h3><a href="https://twitter.com/mizchi">@mizchi</a> &ndash; React/FluxでSPAを開発してぶちあたった問題</h3>

<p>KobitoをReact.js + Fluxで作った時の問題になった点と解決方法について説明していて、ないものは作る姿勢がスゴイなぁ思いました。</p>

<h3><a href="https://twitter.com/sugyan">@sugyan</a> &ndash; React.jsと、 Railsとかアイドルとか (LT)</h3>

<p>React.jsとRailsでReactRouter使ったり色々組み合わてみた話でツラいと言いながらちゃんと作ってしまうところがスゴイなぁと思いました。</p>

<h3><a href="https://twitter.com/making">@making</a> &ndash; Java + React.jsでSever Side Rendering (LT)</h3>

<p>SPAで作ったブログが検索に引っかからないからReact.js + Javaでserver-side renderingするようにしたという話で、最後のオチも含めて面白かったです。</p>

<h3><a href="https://twitter.com/tyshgc">@tyshgc</a> &ndash; Rapid React Prototyping : React.jsでUIデザインプロトタイプを作る (LT)</h3>

<p>React.jsでプロトタイプを作る話で、Photoshopのレイヤー情報からReact.jsのComponentを生成するようにしていてスゴかったです。</p>

<h3><a href="https://twitter.com/teppeis">@teppeis</a> &ndash; Flowtype (LT)</h3>

<p>懇親会の時にFlowtypeについてのLTをしてくれて、デモもあったりFacebookが開発中のElectron(旧:AtomShell)ベースのNuclideの話まであって面白かったです。</p>

<h2>LiveCodingやった</h2>

<p>ぼっちでも懇親会に参加して欲しかったので、ぼーっと見ていたり会話のネタになるかなと思ってLiveCodeingをやってみました。</p>

<p>最近だとJSの環境を作るにも何を使えばいいのかわからないという声も聞くので、0から簡単なアプリを作るところまでの流れを伝えられればと思い、HackerNewsのAPIを使ってTopStoryの一覧を表示するものを作ってみました。</p>

<p>あと、3分間クッキングみたいに事前に色々用意しておくのもライブ感がないなぁと思ったので<code>mkdir</code>から全部その場で作ることにしました。</p>

<p><a href="https://github.com/koba04/react-hacker-news-stories/tree/meetup">https://github.com/koba04/react-hacker-news-stories/tree/meetup</a></p>

<p>環境構築は、browserifyとwatchifyとbabelifyで変換を行ってlivereloadするためのbrowser-syncを使いました。</p>

<p>LiveCodingの流れとしては</p>

<ul>
<li>ディレクトリ作ったり<code>npm init</code>したり<code>npm install</code>したりして環境を作る</li>
<li>Hello Worldしてみる(Hellって書いたけど&hellip;)</li>
<li>各Componentを作成する</li>
<li>HackerNewsのAPI叩いて一覧が出るようにする</li>
<li><code>React.addons.Perf</code>を使ってDOMが無駄に更新されていることとkeyが指定されていないwarningが出ていることを確認</li>
<li>keyを指定することで無駄のDOM操作がなくなることを確認</li>
<li>diffの時間を減らすために<code>Immutable.js</code>を使いつつ<code>shouldComponentUpdate</code>を実装</li>
</ul>


<p>という感じで行いました。</p>

<p>ライブコーディングが初めてで緊張していたのとお酒が入っていたのもあって(言い訳)、いつもと同じ感覚でコーディング出来なくてtypoしまくってしまい、「これ終わらないかも&hellip;」とかなり駆け足になってしまったのは反省です&hellip;。
(事前に練習はしたんですが&hellip;)</p>

<p>でも、とりあえず最後まで出来てよかった&hellip;。</p>

<h2>まとめ</h2>

<p>イベントの管理者側でやるのは初めてだったので色々至らない点があったかもしれませんが、準備してくださったDeNAの方々、発表者の方々、参加者の皆様、本当にありがとうございました！！</p>

<p>感想とかブログに書いてもらえると嬉しいです！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setting up minimum single page application]]></title>
    <link href="http://blog.koba04.com/post/2015/03/19/setting-up-minimum-single-page-application/"/>
    <updated>2015-03-19T18:54:49+09:00</updated>
    <id>http://blog.koba04.com/post/2015/03/19/setting-up-minimum-single-page-application</id>
    <content type="html"><![CDATA[<p>React.jsなどを試そうとするときに、browserify? gulp? grunt? webpack? どれ使えばいいのとか、テストは何を使えばいいのかとかよくわからないというのをたまに聞くので、最低限の設定だけどES6で書けたりautobuildやlivereloadが出来る構成のサンプルを作ってみました。</p>

<p>あと、テストはkarma + mocha + power-assertでchromeでテスト出来るようにしています。</p>

<!-- more -->


<p>本当はpackage.jsonだけにしたかったのですがkarmaの設定だけは別ファイルになってます&hellip;。
テストが必要ない場合は、package.jsonの指定だけで大丈夫です。</p>

<ul>
<li><a href="https://github.com/koba04/minimum-spa-boilerplate">https://github.com/koba04/minimum-spa-boilerplate</a></li>
</ul>


<p>git cloneして<code>npm install</code>して<code>npm start</code>すればいいだけの設定になっています。</p>

<p><code>
git clone git@github.com:koba04/minimum-spa-boilerplate.git
npm install
npm start
</code></p>

<p><img src="http://i.gyazo.com/f906464bfb325437c5c905f80a5b976d.gif" alt="gif" /></p>

<h2>概要</h2>

<h3>tree</h3>

<p><code>
➜  tree -L 1
.
├── README.md
├── index.js         // エントリーポイント
├── karma.conf.js    // karmaの設定
├── lib              // ソース
├── node_modules
├── package.json     // 設定はこの中
├── public           // document root
└── test             // テスト
</code></p>

<h3>package.json</h3>

<p>基本的には<code>npm init</code>で作ったものに色々インストールしてnpm scriptの設定をしているだけです。</p>

<p>```json
  &ldquo;scripts&rdquo;: {</p>

<pre><code>"build": "NODE_ENV=production browserify index.js -t babelify | uglifyjs &gt; public/bundle.js",
"watch": "watchify -d index.js -t babelify -o public/bundle.js -v",
"server": "browser-sync start --server public --files public/**/*",
"test": "karma start",
"start": "npm run watch &amp; npm run server &amp; npm test"
</code></pre>

<p>  },</p>

<p>  &ldquo;dependencies&rdquo;: {</p>

<pre><code>"react": "^0.13.1"
</code></pre>

<p>  },
  &ldquo;devDependencies&rdquo;: {</p>

<pre><code>"babelify": "^5.0.4",
"browser-sync": "^2.3.1",
"browserify": "^9.0.3",
"espowerify": "^0.10.0",
"karma": "^0.12.31",
"karma-browserify": "^4.0.0",
"karma-chrome-launcher": "^0.1.7",
"karma-cli": "0.0.4",
"karma-mocha": "^0.1.10",
"mocha": "^2.2.1",
"power-assert": "^0.10.2",
"uglify-js": "^2.4.17",
"watchify": "^2.4.0"
</code></pre>

<p>  }
```
<a href="https://github.com/koba04/minimum-spa-boilerplate/blob/master/package.json">https://github.com/koba04/minimum-spa-boilerplate/blob/master/package.json</a></p>

<ul>
<li><code>npm run build</code></li>
</ul>


<p>これはReactに依存したビルドになっているのですが、production用にビルドされたファイルを生成することを想定しています。</p>

<ul>
<li><code>npm run watch</code></li>
</ul>


<p>watchifyによってファイルが変更されたら自動的にbrowserifyのビルドが走るようになっています。
watchifyはキャッシュするので二回目以降のビルドが高速化されるのもポイントです。</p>

<ul>
<li><code>npm run server</code></li>
</ul>


<p>BrowserSyncによって<code>public</code>をrootにしたserverを立ちあげつつ、<code>public</code>以下のファイルを監視してlivereloadするようになっています。</p>

<ul>
<li><code>npm test</code></li>
</ul>


<p>テストはkarmaを使うので<code>karma start</code>しているだけです。<code>karma</code>の設定は<code>karma.conf.js</code>にあります。</p>

<ul>
<li><code>npm start</code></li>
</ul>


<p>上記のweatchとbrowserとtestをまとめて実行するコマンドで、これだけ実行すれば開発を始められるようになっています。</p>

<h3>karma</h3>

<p>karmaは<code>karma init</code>で対話的に作成出来る<code>karma.conf.js</code>にbrowserifyの設定を追加したくらいです。</p>

<p>```js
// frameworks to use
// available frameworks: <a href="https://npmjs.org/browse/keyword/karma-adapter">https://npmjs.org/browse/keyword/karma-adapter</a>
frameworks: [&lsquo;mocha&rsquo;, &lsquo;browserify&rsquo;],</p>

<p>// list of files / patterns to load in the browser
files: [
  &lsquo;test/<em>*/</em>.js&rsquo;
],</p>

<p>// list of files to exclude
exclude: [
],</p>

<p>// preprocess matching files before serving them to the browser
// available preprocessors: <a href="https://npmjs.org/browse/keyword/karma-preprocessor">https://npmjs.org/browse/keyword/karma-preprocessor</a>
preprocessors: {
  &lsquo;test/<em>*/</em>.js&rsquo;: &lsquo;browserify&rsquo;
},</p>

<p>browserify: {
  debug: true,
  transform: [</p>

<pre><code>"babelify",
"espowerify"
</code></pre>

<p>  ]
},
```</p>

<p>karmaについては以前にも書いたのでそちらも。</p>

<ul>
<li><a href="http://blog.koba04.com/post/2014/06/23/karma-for-javascript-test-runner/">http://blog.koba04.com/post/2014/06/23/karma-for-javascript-test-runner/</a></li>
</ul>


<p>今回はカジュアルさを優先したので設定していませんが、travis-ciを使いたい場合は、<code>karma-phantomjs-launcher</code>を入れて<code>npm test</code>でPhantomJSで実行出来るようにすればOKだと思います。</p>

<h3>Code</h3>

<p>コードはこんな感じで書けます。</p>

<p>```js
import React from &lsquo;react&rsquo;;</p>

<p>export default class App extends React.Component {
  render() {</p>

<pre><code>return &lt;div&gt;Hello World&lt;/div&gt;;
</code></pre>

<p>  }
}
```
<a href="https://github.com/koba04/minimum-spa-boilerplate/blob/master/lib/components/app.js">https://github.com/koba04/minimum-spa-boilerplate/blob/master/lib/components/app.js</a></p>

<h3>Test</h3>

<p>テストはこんな感じ</p>

<p>```js
import assert from &lsquo;power-assert&rsquo;;
import React from &lsquo;react/addons&rsquo;;
import App from &lsquo;../../lib/components/app&rsquo;;</p>

<p>const {TestUtils} = React.addons;</p>

<p>describe(&ldquo;App&rdquo;, () => {
  let component;</p>

<p>  beforeEach(() => {</p>

<pre><code>component = TestUtils.renderIntoDocument(&lt;App /&gt;);
</code></pre>

<p>  });</p>

<p>  it(&ldquo;returns Hello World in div&rdquo;, () => {</p>

<pre><code>const div = TestUtils.findRenderedDOMComponentWithTag(component, 'div');
assert(
  React.findDOMNode(div).textContent
  ===
  'Hello World'
);
</code></pre>

<p>  });
});
```</p>

<h2>おまけ</h2>

<h3>karma-browserify + power-assert + babel</h3>

<p>npm scriptでbrowserifyとwatchifyの引数に<code>babelify</code>を指定していますが、本当は↓のようにbrowserifyのtransformフィールドにだけ指定してkarmaには<code>espowerify</code>だけを指定したいところなのですが、<code>karma-browserify</code>に指定するtransformはbrowserifyにoptionとしてそのまま渡されるのではなくて事前にtransformするので、<code>espowerify</code>が<code>babelify</code>される前のコードを対象としてしまいエラーになります&hellip;。</p>

<p>なのでここでは、それぞれに個別に設定する形になっています&hellip;。
レアケースですがなんとかしたいなぁと思いつつ&hellip;。</p>

<p>```
&ldquo;browserify&rdquo;: {
  &ldquo;transform&rdquo;: [</p>

<pre><code>["babelify"]
</code></pre>

<p>  ]
}
```</p>

<hr />

<p>そこそこカジュアルな感じになっているかなぁと思います。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React.js v0.13 changes]]></title>
    <link href="http://blog.koba04.com/post/2015/03/05/react-js-v013-changes/"/>
    <updated>2015-03-05T09:23:28+09:00</updated>
    <id>http://blog.koba04.com/post/2015/03/05/react-js-v013-changes</id>
    <content type="html"><![CDATA[<p>React.js v0.13のRC2がリリースされたのでまとめてみます。</p>

<ul>
<li><a href="http://facebook.github.io/react/blog/2015/02/24/react-v0.13-rc1.html">http://facebook.github.io/react/blog/2015/02/24/react-v0.13-rc1.html</a></li>
<li><a href="http://facebook.github.io/react/blog/2015/03/03/react-v0.13-rc2.html">http://facebook.github.io/react/blog/2015/03/03/react-v0.13-rc2.html</a></li>
<li><a href="http://facebook.github.io/react/blog/2015/02/24/streamlining-react-elements.html">http://facebook.github.io/react/blog/2015/02/24/streamlining-react-elements.html</a></li>
</ul>


<p>今回のバージョンで何か大きく変更があるというよりもv0.14でやりたいことに向けての布石が多いように感じます。</p>

<p>試すときはこの辺りから。</p>

<p><code>
npm install react@0.13.0-rc2
npm install react-tools@0.13.0-rc2
</code></p>

<p><code>
http://fb.me/react-0.13.0-rc2.js
http://fb.me/react-0.13.0-rc2.min.js
http://fb.me/react-with-addons-0.13.0-rc2.js
http://fb.me/react-with-addons-0.13.0-rc2.min.js
http://fb.me/JSXTransformer-0.13.0-rc2.js
</code></p>

<!-- more -->


<h2>Propを変更するとwarninngが出ます (Breaking Change)</h2>

<p>development環境でPropをelement作成後に変更することはdeprecatedになってwarningが出るようになりました。
つまりimmutableなものとして扱う必要があります。</p>

<p><code>js
var element = &lt;Foo bar={false} /&gt;;
if (shouldUseFoo) {
  element.props.foo = 10;
  element.props.bar = true;
}
</code></p>

<h3>これまでの問題点</h3>

<ul>
<li>Propを直接変更してしまうと元の値を破棄してしまうのでdiffがなくなってしまいます。この場合、<code>shouldComponentUpdate</code>を実装している場合に比較時に差分を検出出来なくてDOM構造に差分があるはずなのに実際には反映されない可能性がありました。</li>
<li>またPropが変更されることがあるためcreateElementの時点でPropTypesのValidationも出来ず、それによってエラー時のstacktraceが深くなったりFlowによる静的解析にとっても都合がよくなかったりという面もありました。</li>
</ul>


<h4>それに対しての提案</h4>

<ul>
<li>動的にしたい場合は↓のような形で書くことでも可能です。</li>
</ul>


<p>```js
if (shouldUseFoo) {
  return <Foo foo={10} bar={true} />;
} else {
  return <Foo bar={false} />;
}</p>

<p>var props = { bar: false };
if (shouldUseFoo) {
  props.foo = 10;
  props.bar = true;
}
return <Foo {...props} />;
```</p>

<ul>
<li>現時点ではネストしたオブジェクトについては変更してもwarningは出ません。基本的にはimmutable.jsなどを使って完全にimmutableに扱った方がいいですが、mutableなオブジェクトは多くの場面で便利だし今回はネストしたオブジェクトはwarningの対象外となりました。</li>
</ul>


<p><code>js
return &lt;Foo nestedObject={this.state.myModel} /&gt;;
</code></p>

<ul>
<li>PropTypesのwarningをReactElementの作成時に行うなうようになりました。Propを変更するために↓のようにcloneしてReactElementにPropに値を追加するのは正しい方法です。</li>
</ul>


<p><code>js
var element1 = &lt;Foo /&gt;; // extra prop is optional
var element2 = React.addons.cloneWithProps(element1, { extra: 'prop' });
</code></p>

<h2>statics内のメソッドに対してautobindingされなくなりました (Breaking Change)</h2>

<p><code>statics</code>に定義したメソッドをonClickなどにバインドした時にcomponentをバインドしなくなりました。</p>

<p>```js
var Hello = React.createClass({
  statics: {</p>

<pre><code>foo () {
  this.bar();  // v0.13では呼べない
},
bar() {
  console.log("bar");
}
</code></pre>

<p>  },
  render() {</p>

<pre><code>return &lt;div&gt;hello &lt;button onClick={Hello.foo}&gt;click&lt;/button&gt;&lt;/div&gt;;
</code></pre>

<p>  }
});
```</p>

<h2>refを設定する処理の順番が変わりました (Breaking Change)</h2>

<p><code>ref</code>に指定されたcomponentの<code>componentDidMount</code>が呼ばれた後になります。
これは親componentのcallbackを<code>componentDidMount</code>の中で読んでいる場合だけ気にする必要があります。そもそれもこれはアンチパターンなので避けるべきですが&hellip;。</p>

<ul>
<li><code>componentDidMount</code>は子componentから順番に呼ばれるので下記の<code>refDiv</code>はChildの<code>componentDidMount</code>の時点では設定されていません。</li>
</ul>


<p>```js
var Hello = React.createClass({
  foo() {</p>

<pre><code>console.log(this.refs.refDiv);
</code></pre>

<p>  },
  render() {</p>

<pre><code>return (
  &lt;div&gt;
    &lt;Child foo={this.foo} /&gt;
    &lt;div ref="refDiv"&gt;hello&lt;/div&gt;
  &lt;/div&gt;
);
</code></pre>

<p>  }
});</p>

<p>var Child = React.createClass({
  componentDidMount() {</p>

<pre><code>this.props.foo(); // v0.13 "undefined"
</code></pre>

<p>  },
  render() {</p>

<pre><code>return &lt;div&gt;child&lt;/div&gt;;
</code></pre>

<p>  }
});
```</p>

<h2><code>this.setState()</code>が第1引数に関数を受け取れるようになりました</h2>

<p><code>js
this.setState((state, props) =&gt; ({count: state.count + 1}));
</code></p>

<p>のようにすることで<code>this._pendingState</code>を使うことなくトランザクションが必要とされるstateの更新を行うことが出来ます。</p>

<p>```js
console.log(this.state.count) // 0
this.setState({ count: this.state.count + 1 })
this.setState({ count: this.state.count + 1 })
// state.count will render as 1</p>

<p>console.log(this.state.count) // 0
this.setState(function(state, props) { return { count: state.count + 1 } });
this.setState(function(state, props) { return { count: state.count + 1 } });
// state.count will render as 2
```</p>

<h2>setStateの呼び出しが常に非同期になります (Breaking Change)</h2>

<p>ライフサイクルメソッドの中での<code>setState</code>の呼び出しが常に非同期でバッチとして処理されます。以前は最初のマウント時の呼び出しは同期的に行われていました。</p>

<p><code>
componentDidMount() {
  console.log(this.state.count) // 0
  this.setState({ count: this.state.count + 1 })
  this.setState({ count: this.state.count + 1 })
  console.log(this.state.count) // v0.13 is 0 (v0.12 is 2)
}
</code></p>

<h2>setStateとforceUpdateをunmountされたcomponentに対して呼んだ時に、エラーではなくwarningが出るようになりました (Breaking Change)</h2>

<p>非同期処理の結果を<code>setState</code>して反映させるときに、<code>isMounted</code>でブロックしなくてもよくなったのはいいですね。</p>

<h2>privateなプロパティが整理されました (Breaking Change)</h2>

<p><code>this._pendingState</code>や<code>this._rootNodeID</code>などのprivateなプロパティが削除されました。</p>

<h2>ES6 classesによるReactComponentの作成がサポートされました</h2>

<p>これについては↓に書きましたが、ES6 classesによって作成されたcomponentには<code>createClass</code>にはある<code>getDOMNode</code>、<code>setProps</code>、<code>replaceState</code>が含まれていなかったりmixinが指定出来ないなど注意点がいくつかあります。</p>

<ul>
<li><a href="http://blog.koba04.com/post/2015/01/28/published-react-v0.13.0-beta1/">http://blog.koba04.com/post/2015/01/28/published-react-v0.13.0-beta1/</a></li>
</ul>


<h2><code>React.findDOMNode(component)</code>のAPIが追加されました</h2>

<p>これは既存の<code>component.getDOMNode()</code>を置き換えるAPIです。
<code>getDOMNode()</code>はES6 classesによって作成されたcomponentでは提供されていません。</p>

<h2><code>ref</code>がcallbackスタイルで指定できるようになりました。</h2>

<p><code>js
&lt;Photo ref={(c) =&gt; this._photo = c} /&gt;
</code></p>

<p>この変更はこの後で書く<code>owner</code>の扱いの変更に関係しています。</p>

<h2>childrenにiteratorやimmutable-jsのsequenceを指定出来るようになりました</h2>

<p>immutable-jsを使っている人にとってはいいですね。</p>

<h2><code>ComponentClass.type</code>はdeprecatedになりました</h2>

<p>代わりに<code>ComponentClass</code>をそのまま使ってください。</p>

<h2>ownerベースのcontextを使っていてparentベースのcontextと一致しない場合にwarningが出るようになります</h2>

<p>そもそもowner? parent?という感じかと思うので簡単に説明します。</p>

<h3>owner and parent</h3>

<p>Reactは"parent"と"owner"を持っています。"owner"はReactElementを作ったcomponentです。</p>

<p>```js
class Foo {
  render() {</p>

<pre><code>return &lt;div&gt;&lt;span /&gt;&lt;/div&gt;;
</code></pre>

<p>  }
}
```</p>

<p>この場合、<code>span</code>のownerは<code>Foo</code>でparentは<code>div</code>になります。</p>

<h3>context</h3>

<p>これはdocument化されてないfeatureですが、"owner"から子や孫に渡すことが出来る"context"というものがあります。</p>

<p>簡単にコードを書くとこんな感じです。見てもらえればどんなfeatureなのかわかるかと思います。</p>

<p>```js
var Parent = React.createClass({</p>

<pre><code>childContextTypes: {
  name: React.PropTypes.string,
  age: React.PropTypes.number
},
getChildContext: function() {
  return {
    name: "parent",
    age: 50
  };
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return &lt;Child /&gt;;
</code></pre>

<p>  }
});</p>

<p>var Child = React.createClass({</p>

<pre><code>contextTypes: {
  name: React.PropTypes.string,
  age: React.PropTypes.number
},
componentDidMount: function() {
  console.log("Child",this.context); // {name: "parent", age: 50}
},
render: function() {
  return &lt;GrandChild /&gt;;
}
</code></pre>

<p>});</p>

<p>var GrandChild = React.createClass({</p>

<pre><code>contextTypes: {
  name: React.PropTypes.string
},
componentDidMount: function() {
  console.log("GrandChild",this.context); // {name: "parent"}
},
render: function() {
  return &lt;div&gt;hello&lt;/div&gt;;
}
</code></pre>

<p>});</p>

<p>React.render(<Parent />, document.body);
```</p>

<p><code>react-router</code>ではparentベースのcontextに依存していたので対応が大変そうでした。</p>

<h3>問題点</h3>

<ul>
<li>ownerは密かにReactElementに追加されているので気づかないうちに挙動が変わることが発生します。↓の場合はそれぞれのinputのownerが異なりますし、<code>React.addons.cloneWithProps</code>を使った場合もownerが変わります。</li>
</ul>


<p>```js
var foo = <input className="foo" />;
class Component {
  render() {</p>

<pre><code>return bar ? &lt;input className="bar" /&gt; : foo;
</code></pre>

<p>  }
}
```</p>

<ul>
<li>ownerは実行時のstackによって決定します。↓の場合、<code>span</code>のonwerは実際は<code>B</code>で<code>A</code>ではありません。これはcallbackが実行されたタイミングに依存するからです。</li>
</ul>


<p>```js
class A {
  render() {</p>

<pre><code>return &lt;B renderer={text =&gt; &lt;span&gt;{text}&lt;/span&gt;} /&gt;;
</code></pre>

<p>  }
}
class B {
  render() {</p>

<pre><code>return this.props.renderer('foo');
</code></pre>

<p>  }
}
```</p>

<ul>
<li>また、JSXが書いているscope内にReactが必要なのは、Reactが現在のownerを保持していてJSXの変換がそれに依存しているからという意外なところに影響があったりもします。</li>
</ul>


<h3>それに対する提案</h3>

<ul>
<li>ownerベースのcontextの代わりにparentベースのcontextの導入を考えているのでそれを使うことです。ほとんどのケースはparentベースのcontextでも問題ないです。</li>
<li>ownerベースのcontextが必要になる場合はほとんどないはずだしコードを見直すべきです。</li>
</ul>


<h3>未解決</h3>

<ul>
<li><code>ref</code>はまだownerベースのままで、これについてはまだ完全に解決出来ていません。

<ul>
<li>v0.13ではcallbackでもrefが定義出来るようなりましたがこれまでの宣言的な定義方法も残されています。宣言的な定義方法に代わる何かいい方法がない限りこのAPIは廃止されません。</li>
</ul>
</li>
</ul>


<h2><code>{key: element}</code>(Keyed Object)の形式でchildに渡すとwarningが出るようになりました</h2>

<p>v0.12では<code>{key: element}</code>の形式でkeyが指定したらelementを渡すことが出来ましたが、これはあまり使われてないし問題となる場合があるので使うべきではないのでwarningが出るようになりました。</p>

<p>```js</p>

<div>{ {a: <span />, b: <span />} }</div>


<p>```</p>

<h3>問題点</h3>

<ul>
<li>列挙される順番はkeyに数値を指定した場合を除いては仕様として定義されてないので実装次第になってしまいます。</li>
<li>一般的にobjectをmapとして扱うことは型システムやVMの最適化やコンパイラーにとって好ましくないし、さらにセキュリティ上のリスクもあって↓のような場合にもし<code>item.title === '__proto__'</code> を指定されたら&hellip;.</li>
</ul>


<p><code>js
var children = {};
items.forEach(item =&gt; children[item.title] = &lt;span /&gt;);
return &lt;div&gt;{children}&lt;/div&gt;;
</code></p>

<h3>それに対する解決</h3>

<ul>
<li>ほとんどの場合、<code>key</code>を設定したReactElementの配列にすれば問題ないはずです。</li>
</ul>


<p>```js
var children = items.map(item => <span key={item.title} />);</p>

<div>{children}</div>


<p>```</p>

<ul>
<li><code>this.props.children</code>を使った場合など、<code>key</code>を指定することが出来ない場合もあるかもしれません。その場合はv0.13で追加された<code>React.addons.createFragment</code>を使うことでKeyed ObjectからReactElementを作成することが出来ます。

<ul>
<li>注意として、これはまだrenderの戻り値として直接渡せるものではないので<div>などでラップしてあげる必要があります。</li>
</ul>
</li>
</ul>


<p>```js</p>

<p><div>{React.addons.createFragment({ a: <div />, b: this.props.children })}</div>
```</p>

<h2><code>React.cloneElement</code>が追加されました</h2>

<p>これはこれまで<code>React.addons.cloneWithProps</code>と似たAPIです。
異なる点としては、<code>style</code>や<code>className</code>のmergeが行われなかったり<code>ref</code>が保持される点があります。
<code>cloneWithProps</code>を使ってchildrenを複製した時に<code>ref</code>が保持されなくて問題となるという報告が多くあったのでこのAPIでは<code>ref</code>を保持するようになりました。
<code>cloneElement</code>時に<code>ref</code>を指定すると上書きされます。</p>

<p><code>js
var newChildren = React.Children.map(this.props.children, function(child) {
  return React.cloneElement(child, { foo: true })
});
</code></p>

<p>このAPIはv0.13でPropがimmutableなものとして扱われるようになったことで、Propを変更するためにelementをcloneする機会が増えたため必要となりました。
<code>React.addons.cloneWithProps</code>はそのうちdeprecateになりますが今回のタイミングではなりません。</p>

<h2><code>React.addons.classSet</code>がdeprecatedになりました</h2>

<p>必要な場合は<a href="https://www.npmjs.com/package/classnames">classnames</a>などを使用してください。</p>

<h2>jsxコマンドで<code>--target</code>optionとしてECMAScript versionを指定出来るようになりました。 (Breaking Change)</h2>

<p><code>es5</code>がデフォルトです。
<code>es3</code>はこれまでの挙動ですが追加で予約語を安全に扱うようになりました(eg <code>this.static</code>は<code>this['static']</code>にIE8での互換性のために変換されます)。</p>

<h2>jsxコマンドでES6 syntaxで変換した際にclassメソッドがdefaultではenumerableではなくなりました</h2>

<p><code>Object.defineProperty</code>を使用しているため、IE8などをサポートしたい場合は<code>--target es3</code>optionを渡す必要があります。</p>

<ul>
<li>Original</li>
</ul>


<p>```js
class Hello extends React.Component {
  foo() {</p>

<pre><code>console.log("foo");
</code></pre>

<p>  }
  render() {</p>

<pre><code>return &lt;div&gt;hello&lt;/div&gt;;
</code></pre>

<p>  }
}
Hello.static = {
  bar() {</p>

<pre><code>console.log("bar");
</code></pre>

<p>  }
};
```</p>

<ul>
<li>ES5</li>
</ul>


<p>```js
var <strong><strong>Class0=React.Component;for(var </strong></strong>Class0<strong><strong>Key in </strong></strong>Class0){if(<strong><strong>Class0.hasOwnProperty(</strong></strong>Class0<strong><strong>Key)){Hello[</strong></strong>Class0<strong><strong>Key]=</strong></strong>Class0[<strong><strong>Class0</strong></strong>Key];}}var <strong><strong>SuperProtoOf</strong></strong>Class0=<strong><strong>Class0===null?null:</strong></strong>Class0.prototype;Hello.prototype=Object.create(<strong><strong>SuperProtoOf</strong></strong>Class0);Hello.prototype.constructor=Hello;Hello.<strong>superConstructor</strong>=<strong><strong>Class0;function Hello(){&ldquo;use strict&rdquo;;if(</strong></strong>Class0!==null){____Class0.apply(this,arguments);}}
  Object.defineProperty(Hello.prototype,&ldquo;foo&rdquo;,{writable:true,configurable:true,value:function() {&ldquo;use strict&rdquo;;</p>

<pre><code>console.log("foo");
</code></pre>

<p>  }});
  Object.defineProperty(Hello.prototype,&ldquo;render&rdquo;,{writable:true,configurable:true,value:function() {&ldquo;use strict&rdquo;;</p>

<pre><code>return React.createElement("div", null, "hello");
</code></pre>

<p>  }});</p>

<p>Hello.static = {
  bar:function() {</p>

<pre><code>console.log("bar");
</code></pre>

<p>  }
};
```</p>

<ul>
<li>ES3</li>
</ul>


<p>```js
var <strong><strong>Class0=React.Component;for(var </strong></strong>Class0<strong><strong>Key in </strong></strong>Class0){if(<strong><strong>Class0.hasOwnProperty(</strong></strong>Class0<strong><strong>Key)){Hello[</strong></strong>Class0<strong><strong>Key]=</strong></strong>Class0[<strong><strong>Class0</strong></strong>Key];}}var <strong><strong>SuperProtoOf</strong></strong>Class0=<strong><strong>Class0===null?null:</strong></strong>Class0.prototype;Hello.prototype=Object.create(<strong><strong>SuperProtoOf</strong></strong>Class0);Hello.prototype.constructor=Hello;Hello.<strong>superConstructor</strong>=<strong><strong>Class0;function Hello(){&ldquo;use strict&rdquo;;if(</strong></strong>Class0!==null){____Class0.apply(this,arguments);}}
  Hello.prototype.foo=function() {&ldquo;use strict&rdquo;;</p>

<pre><code>console.log("foo");
</code></pre>

<p>  };
  Hello.prototype.render=function() {&ldquo;use strict&rdquo;;</p>

<pre><code>return React.createElement("div", null, "hello");
</code></pre>

<p>  };</p>

<p>Hello[&ldquo;static&rdquo;] = {
  bar:function() {</p>

<pre><code>console.log("bar");
</code></pre>

<p>  }
};
```</p>

<h2>JSXによる変換でharmony optionを有効にすることでspread operatorを使えるようになりました</h2>

<p>JSXの中ではこれまでもspread attributesとしてサポートしていましたが、JSのコード内でも使えるようになりました。</p>

<p><code>js
var [a, b, ...other] = [1,2,3,4,5];
</code></p>

<h2>JSXのparseに変更があります (Breaking Change)</h2>

<p>elementの内側に<code>&gt;</code> or <code>}</code> を使った時に以前は文字列として扱われましたがparseエラーになるようになりました。</p>

<p><code>js
render() {
  return &lt;div&gt;} or &gt;&lt;/div&gt;; // parse error!
}
</code></p>

<h2>v0.14に向けて</h2>

<p>今回の変更を踏まえてReact v0.14では静的な要素においていくつかの最適化が可能になります。
これらの最適化は以前はtemplate-baseなフレームワークでのみ可能でしたが、ReactでもJSXと<code>React.createElement/Factory</code>のどちらでも可能になります。</p>

<p>詳細は下記のissueにあります。
まだ議論もされてないので変わる可能性は大きいと思いますが。</p>

<h3>Reuse Constant Value Types</h3>

<ul>
<li><a href="https://github.com/facebook/react/issues/3226">https://github.com/facebook/react/issues/3226</a></li>
</ul>


<p>これは静的なelementに変更できないものとして扱うことでdiffのコストを減らすというものです。</p>

<p>例えばこんな感じにするとか</p>

<p><code>js
function render() {
   return &lt;div className="foo" /&gt;;
}
↓
var foo = &lt;div className="foo" /&gt;;
function render() {
   return foo;
}
</code></p>

<h3>Tagging ReactElements</h3>

<ul>
<li><a href="https://github.com/facebook/react/issues/3227">https://github.com/facebook/react/issues/3227</a></li>
</ul>


<p>これはReactElementにtag付けをしてそれを使ってdiffアルゴリズムを最適化するというもののようです。</p>

<h3>Inline ReactElements</h3>

<ul>
<li><a href="https://github.com/facebook/react/issues/3228">https://github.com/facebook/react/issues/3228</a></li>
</ul>


<p>これはproductionビルドのときに、React.createElementではなくてinline objectに変換することでReact.createElementのコストを削減するというものです。</p>

<p>こんな感じ</p>

<p><code>js
&lt;div className="foo"&gt;{bar}&lt;Baz key="baz" /&gt;&lt;/div&gt;
↓
{ type: 'div', props: { className: 'foo', children:
  [ bar, { type: Baz, props: { }, key: 'baz', ref: null } ]
}, key: null, ref: null }
</code></p>

<p>こうするとReact.createElementの時に行っているPropTypesやkeyに対するvalidationが出来ないので、developmentビルドの時には適用しないことを想定しているようです。</p>

<hr />

<p>というわけで、React v0.13をダラダラと書いてみました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React v0.13.0 Beta1でclassでComponentが作れるようになった]]></title>
    <link href="http://blog.koba04.com/post/2015/01/28/published-react-v0.13.0-beta1/"/>
    <updated>2015-01-28T17:20:35+09:00</updated>
    <id>http://blog.koba04.com/post/2015/01/28/published-react-v0.13.0-beta1</id>
    <content type="html"><![CDATA[<p>React.js Confの前日にv0.13.0 Beta1がnpmにpublishされました。</p>

<p><a href="http://facebook.github.io/react/blog/2015/01/27/react-v0.13.0-beta-1.html">http://facebook.github.io/react/blog/2015/01/27/react-v0.13.0-beta-1.html</a></p>

<p>featureは色々あるみたいですが、↑のブログにはその1つとしてClassによるReact Componentの作成が紹介されていたのでそれについて書きたいと思います。</p>

<p>ちなみに<code>React.createClass</code>を使う場合はこれまでと同じままで大丈夫なはずです。</p>

<!-- more -->


<h2>ES6 Classes</h2>

<p><code>React.createClass</code>ではなくて、ES6のclassを使って↓みたいな感じで書けるようになります。</p>

<p>```js
import {React} from &lsquo;react&rsquo;;</p>

<p>export class Hello extends React.Component {
  constructor(props) {</p>

<pre><code>super(props);
this.state = { val: props.foo * 2 };
</code></pre>

<p>  }
  onClick() {</p>

<pre><code>this.setState({ val: this.state.val * 2 });
</code></pre>

<p>  }
  render() {</p>

<pre><code>return (
  &lt;div&gt;
    &lt;p&gt;state is {this.state.val}. props is {this.props.foo}&lt;/p&gt;
    &lt;button onClick={this.onClick.bind(this)}&gt;click&lt;/button&gt;
  &lt;/div&gt;
);
</code></pre>

<p>  }
}
Hello.propTypes = {
  foo: React.PropTypes.number
};
```</p>

<p>ポイントとしては</p>

<ul>
<li><code>React.Component</code>をextendsします。</li>
<li><code>constructor</code>に<code>props</code>が引数として渡ってくるのでそれを使って必要に応じて<code>state</code>の初期化をする。

<ul>
<li><code>getInitialState</code>は使うことができません。(warnが出ます)</li>
</ul>
</li>
<li>Autobindingはされなくなったので明示的に<code>this.onClick.bind(this)</code>のようにする必要があります。</li>
<li><code>propTypes</code>や<code>defaultProps</code>はconstructorのpropertyとして指定する必要があります。</li>
<li>現時点で<code>mixin</code>はclassで書いた場合は使うことができません。</li>
</ul>


<p>といった辺りです。</p>

<h3>変換</h3>

<p>ES6のコードの変換は、これまで通りreact-toolsでjsxの<code>--harmony</code>optionを有効にしたり6to5使ったりする感じです。</p>

<h3>今後</h3>

<p>今の書き方だと微妙に感じるところも結構あるのですが、最終的には↓のような形で書けるようにしたいみたいです。</p>

<p>```js
import {React} from &lsquo;react&rsquo;;</p>

<p>export class Hello extends React.Component {
  propTypes = { foo: React.PropTypes.number };
  state = { val: this.props.foo * 2 };
  onClick = () => {</p>

<pre><code>this.setState({ val: this.state.val * 2 });
</code></pre>

<p>  };
  render() {</p>

<pre><code>return (
  &lt;div&gt;
    &lt;p&gt;state is {this.state.val}. props is {this.props.foo}&lt;/p&gt;
    &lt;button onClick={this.onClick}&gt;click&lt;/button&gt;
  &lt;/div&gt;
);
</code></pre>

<p>  }
}
```</p>

<p>mixinについてはreact-futureを見る限りこんな感じになるのかもしれないですね。</p>

<p><a href="https://github.com/reactjs/react-future/blob/master/01%20-%20Core/02%20-%20Mixins.js">https://github.com/reactjs/react-future/blob/master/01%20-%20Core/02%20-%20Mixins.js</a></p>

<p>```js
import { mixin } from &ldquo;react-utils&rdquo;;
import { Component } from &ldquo;react&rdquo;;</p>

<p>const A = {
  componentDidMount() {</p>

<pre><code>super();
console.log('A');
</code></pre>

<p>  }
};</p>

<p>class Hello extends mixin(Component, A) {
  render() {</p>

<pre><code>return &lt;div /&gt;;
</code></pre>

<p>  }
}
```</p>

<h3>CoffeeScript &amp; TypeScript</h3>

<p>ちなみにES6だけでなく、CoffeescriptやTypeScriptのClass syntaxでもかけます。</p>

<hr />

<p>React.js自体でやることを減らしてES6、7のfeatureに任せることが出来るところは任せようといった方向性を感じて個人的にはいいんじゃないかと思っています。</p>

<p>React.js Conf行きたかった&hellip;</p>
]]></content>
  </entry>
  
</feed>

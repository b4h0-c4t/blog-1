<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: react.js | blog.koba04.com]]></title>
  <link href="http://blog.koba04.com/blog/categories/react-dot-js/atom.xml" rel="self"/>
  <link href="http://blog.koba04.com/"/>
  <updated>2018-04-05T17:22:46+09:00</updated>
  <id>http://blog.koba04.com/</id>
  <author>
    <name><![CDATA[koba04]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[React v16.3 changes]]></title>
    <link href="http://blog.koba04.com/post/2018/04/04/react-v163-changes/"/>
    <updated>2018-04-04T15:25:23+09:00</updated>
    <id>http://blog.koba04.com/post/2018/04/04/react-v163-changes</id>
    <content type="html"><![CDATA[<p>React v16.3.0 がリリースされました。</p>

<p><strong>※4/4 にバグフィックスを含む v16.3.1 がリリースされています</strong></p>

<p>このバージョンでは、基本的には v17 で有効化される非同期レンダリングへの対応が中心になっています。変更点は多いですが、ほとんどが機能追加であり破壊的な変更はないため、v16.2 から v16.3 へのアップグレードは比較的簡単じゃないかなと思います。</p>

<p><a href="https://reactjs.org/blog/2018/03/29/react-v-16-3.html">https://reactjs.org/blog/2018/03/29/react-v-16-3.html</a></p>

<!-- more -->


<p>当初の予定からはかなり延びたため、直前に発表された React Suspense の機能も入れるのかと思いましたが入りませんでした。まだ最終的な API は決まってないようなので今後に期待。
React Suspense については、v16.3 と関係ないので今回は省略します。</p>

<p><a href="https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html">https://reactjs.org/blog/2018/03/01/sneak-peek-beyond-react-16.html</a></p>

<hr />

<p>長いので 3 行で知りたい人向けのまとめ</p>

<ul>
<li>v16.3 は、v17 移行で有効になる非同期レンダリングに移行するための機能追加が中心で、このバージョンでの破壊的な変更はない</li>
<li>ライフサイクルメソッドの変更、新しい Ref の API と Context の API が入る</li>
<li>StrictMode の Component、<code>react-lifecycles-compat</code> 、<code>react-is</code>、<code>create-subscription</code>パッケージが追加された</li>
</ul>


<hr />

<p>それでは、大きな変更だけ見ていきたいと思います。</p>

<h2>Lifecycle Methods</h2>

<p>もっとも大きな変更は、将来のライフサイクルメソッドの変更に備えて新しいライフサイクルメソッドが追加されたことです。</p>

<p>ただ実際には、v16.3 の段階では破壊的な変更はありません。ライフサイクルメソッドの変更は下記のようなスケジュールで適用されます。</p>

<p><img src="/images/posts/react-163-changes/lifecycle-methods.png" title="&lsquo;React Lifecycle Methods Changes&rsquo;" ></p>

<p>上記を見てわかる通り、v16.3 の段階では新しい<code>static getDerivedStateFromProps</code> と <code>getSnapshotBeforeUpdate</code> と<code>UNSAFE_xxx</code>メソッドの追加のみです。
<code>UNSAFE_xxx</code> のメソッドは既存実装の Alias で今のところ、削除される予定は決まっていません。したがって、他のメソッドへのマイグレーションが難しい場合にはとりあえず使い続けることも可能です。
<code>UNSAFE_</code>の prefix がついていないメソッドは、v16 系のマイナーリリースの中で警告が出るようになって、v17 系のリリースで削除されます。（React では Breaking Change をするときは、前のバージョンで警告を出すようになっています）この警告は、当初は v16.4 のリリースと計画されていたのですが最新のブログでは v16.x となっています。</p>

<p>ちなみに、この後で紹介する<code>react-lifecycles-compat</code>というライブラリを使うことで、新しく追加された static getDerivedStateFromProps や getSnapshotBeforeUpdate を使った Component でも古いバージョンの React をサポートすることが可能です。</p>

<h3>なぜこれらのライフサイクルメソッドが廃止されるのか？</h3>

<p>React は v16 で React Fiber と呼ばれる実装に内部実装が書き換えられましたが、v16 系ではこれまでのバージョンと互換性のある挙動をするようになっています（同期的）。
v17 では、ここの挙動がデフォルトで変更されます。その際、Render Phase と Commit Phase のうち、Render Phase の方は非同期で処理され、さらに何度も呼ばれる可能性があります。</p>

<p>Render Phase はインスタンスを作ったり差分を計算するいわゆる副作用のない部分です。Commit Phase は、Render Phase の結果を元に実際に DOM などの Host 環境に適用する Phase で、同期的に処理されます。</p>

<p>そのため、Render Phase で呼ばれるライフサイクルメソッド（componentWillMount, componentWillReceiveProps, shouldComponentUpdate, componentWillUpdate）のうち shouldComponentUpdate 以外は、安全性を保証できないため廃止されることになりました。</p>

<p><code>UNSAFE_</code>という prefix が付いた形では残りますが、前述した通り、これらのメソッドは何度も呼ばれる可能性があるため、副作用のある処理を行う場合には注意が必要です。例えば、イベントの登録・解除の処理など、1 対 1 で結びついていることを期待する処理を componentWillMount と componentWillUnmount を組み合わせて行った場合、1 対 1 であることが保証されないため壊れる可能性があります。この場合は、Commit Phase で実行される componentDidMount と componentWillUnmount を組み合わせて使う必要があります。</p>

<p>これらの話は、以前にも書いたのでそちらを参照してもらうとイメージ出来ると思います。（Render Phase という名前は最近使われるようになったので、参照先では、beginWork〜completeWork として書かれている部分です）</p>

<ul>
<li><a href="http://blog.koba04.com/post/2017/04/25/a-state-of-react-fiber/">http://blog.koba04.com/post/2017/04/25/a-state-of-react-fiber/</a></li>
<li><a href="https://speakerdeck.com/koba04/react-v16-and-beyond-react-fiber">https://speakerdeck.com/koba04/react-v16-and-beyond-react-fiber</a></li>
<li><a href="https://speakerdeck.com/koba04/capability-of-react-fiber">https://speakerdeck.com/koba04/capability-of-react-fiber</a></li>
</ul>


<p>前述した通り、非同期レンダリングの世界では、更新処理の割り込みにより様々なタイミングで Render Phase が複数回実行されます。そのため、React が管理する Props や State 以外のインスタンスが持つ状態を保証するのが難しくなります。そのため、この後紹介する componentWillReceiveProps の代わりと使われることが想定される getDerivedStateFromProps は、static メソッドになっています。</p>

<p>将来的には、Class による Component API とは違う、React が管理する State など以外の状態を持つことができない Component を作成する新しい API も計画されているようです。（つまりクラスではない Stateful Functional Component のような?）</p>

<p>shouldComponentUpdate については、基本的にはこのような副作用が書かれていることはないということと影響の大きさから、残されたのかなと思います。将来的に static なメソッドになる可能性はあるかなと思います。</p>

<h3><code>static getDerivedStateFromProps(nextProps, prevState)</code></h3>

<p>Render Phase で呼ばれます。タイミングとしては、新しい Props が渡された場合に、componentWillReceiveProps と同じタイミングで呼ばれます。
componentWillReceiveProps と違い、更新時だけでなくマウント時にも呼ばれます。</p>

<p>引数として新しい Props と現在の State を受け取ります。このメソッドで返した値は現在の State の値とマージされます。つまり受け取った Props を元に State の値を更新したいような場面で使います。返した値が State の値とマージされるというのは、setState の挙動と同じです。</p>

<p>componentWillReceiveProps と違い static になっているのは、前述した通り Render Phase でいつ呼ばれてもいいように、Props と State 以外の状態に依存させないためです。</p>

<p>State を更新する必要がない時は、<code>null</code>を返します。</p>

<p>実際に使おうとすると prevProps が取得出来ないのを不便に感じるのですが、下記の理由から prevProps を渡さないようになったとのことです。ドキュメントでは、prevProps が欲しい場合は、State として保存することが推奨されています。</p>

<ul>
<li>getDerivedStateFromProps はマウント時にも呼ばれ、マウント時は prevProps は<code>null</code>になるので、prevProps を使おうとする<code>null</code>かどうかのチェックが常に必要になってしまう</li>
<li>prevProps を渡さないことで、メモリ常に保持しておく必要がなくなるので将来的に最適化が可能になる</li>
</ul>


<p>あんまりいい例が思いつかなかったのですが、getDerivedStateFromProps の例はこんな感じ。</p>

<p>```js
static getDerivedStateFromProps(nextProps, prevState) {
  // カテゴリが変わったらデータをリセット
  if (nextProps.category !== prevState.category) {</p>

<pre><code>return {
  data: null,
  category: null,
}
</code></pre>

<p>  }
  return null;
}
componentDidUpdate() {
  if (this.state.category == null) {</p>

<pre><code>fetchData(this.props.category).then((data) =&gt; {
  this.setState({category: this.props.category, data});
});
</code></pre>

<p>  }
}
```</p>

<h3><code>getSnapshotBeforeUpdate(prevProps, prevState)</code></h3>

<p>Commit Phase で呼ばれます。したがって、Render Phase で呼ばれる componentWillUpdate と違い、更新前に必ず一度だけ呼ばれることが保証されます。</p>

<p>用途としては、スクロール位置など Host 環境(DOM)の更新前後の値を比較して何かしたい場合に使います。これまでは、componentWillUpdate でインスタンスプロパティに保存して、componentDidUpdate でそれを参照し比較していたのを、componentWillUpdate の代わりに getSnapshotBeforeUpdate を使います。
getSnapshotBeforeUpdate では、名前の通り snapshot を返します。
snapshot はどんな値でもよく、上記の場合はスクロール位置を snapshot として返します。</p>

<p>getSnapshotBeforeUpdate で返した snapshot は、componentDidUpdate の第 3 引数として渡されます。したがって componentDidUpdate の中では、snapshot と現在の値を比較できます。</p>

<p>ちなみに getDerivedStateFromProps も getSnapshotBeforeUpdate も長くて覚えにくい名前だと思いますが、これはこれらのライフサイクルメソッドは頻繁に使うようなものではないため、あえてそういう名前にしたという話もあります。（名前決める議論の中でそんなことを言っていた記憶がないので本当かは不明）</p>

<p>例として、タイムラインのようにどんどん先頭に要素が追加されていく状態で、表示されている要素を維持し続けるために更新前のスクロール位置を保持して、追加された要素分位置を調整する例はこんなイメージ。</p>

<p>```js
getSnapshotBeforeUpdate() {
  const body = document.body;
  return {</p>

<pre><code>scrollHeight: body.scrollHeight,
scrollTop: body.scrollTop
</code></pre>

<p>  };
}
componentDidUpdate(prevProps, prevState, snapshot) {
  const body = document.body;
  body.scrollTop = snapshot.scrollTop + (body.scrollHeight &ndash; snapshot.scrollHeight);
}
```</p>

<h3>Migration paths</h3>

<p>今回のライフサイクルメソッドの変更で影響のありそうなパターンについては、下記のブログで丁寧に触れられているので、移行作業をする際には確認することをオススメします。</p>

<p><a href="https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html#examples">https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html#examples</a></p>

<p>以下、簡単に紹介しておきます。</p>

<ul>
<li>Initializing state

<ul>
<li>State の初期化を componentWillMount で初期化を行なっていた場合は、constructor に移動させることが出来ます</li>
</ul>
</li>
<li>Fetching external data

<ul>
<li>外部リソースの取得を componentWillMount で行なっていた場合は、componentDidMount で行うようにします。</li>
<li>ただ、この辺りは将来的には React Suspense で置き換えることを想定しているようです。SSR 時の外部リソースの取得についても言及されているので、React Suspense は SSR の時にもうまく動作するようになるのかもしれないですね。（既存の SSR の Renderer は Fiber ベースではないのでどう実装するのかは不明ですが…）</li>
</ul>
</li>
<li>Adding event listeners (or subscriptions)

<ul>
<li>componentWillMount で行なっていたイベントの購読については、componentDidMount で行うようにします。</li>
<li>一点注意点としては、componentWillMount は親 → 子の順番で呼ばれますが、componentDidMount は子 → 親の順番で呼ばれます。そのため、親の componentDidMount でイベントの購読を行う場合、子の componentDidMout 発行されたイベントについては購読出来ません（子がイベントを発行していた時点で、親はまだイベントを購読してないため）。</li>
<li>イベントの処理については、後述する<code>create-subscription</code>を使う方法もあります。</li>
</ul>
</li>
<li>Updating state based on props

<ul>
<li>componentWillReceiveProps で新しい Props の値をもとに State の値を更新していたような場合は、static getDerivedStateFromProps を代わりに使います。</li>
</ul>
</li>
<li>Invoking external callbacks

<ul>
<li>State が変更されたタイミングで何かコールバックを実行したいような場合は、componentWillUpdate ではなくて、componentDidUpdate を使います。</li>
</ul>
</li>
<li>Side effects on props change

<ul>
<li>Props の変更に応じて何か副作用を呼び出したい場合は、componentWillReceiveProps や componentWillUpdate ではなく、componentDidUpdate を使います。</li>
</ul>
</li>
<li>Fetching external data when props change

<ul>
<li>Props の変更に応じて外部リソースをフェッチしたい場合には、static getDerivedStateFropProps でデータをリセットして、componentDidUpdate でデータをフェッチする方法が推奨されています。（componentDidUpdate で呼ばないと何度もリクエストが投げられる可能性があります）</li>
</ul>
</li>
<li>Reading DOM properties before an update

<ul>
<li>更新前の DOM の状態を取得して更新後の値と比較したい場合は、getSnapshotBeforeUpdate で取得した値を返して、componentDidUpdate の第 3 引数として受け取ります。</li>
</ul>
</li>
</ul>


<p>ライフサイクルメソッドについての公式のドキュメント</p>

<p><a href="https://reactjs.org/docs/react-component.html#the-component-lifecycle">https://reactjs.org/docs/react-component.html#the-component-lifecycle</a></p>

<h2>createRef API</h2>

<p>新しい Ref に対する API です。<code>React.createRef()</code>で作成した変数を ref に設定します。簡単ですね。</p>

<p><code>js
const ref = React.createRef();
&lt;button ref={ref} /&gt;;
</code></p>

<p>注意点としては、上記の場合、button 要素は ref の変数に入っているのではなく、<code>ref.current</code>に入っています。したがって上記の場合、focus をあてたい場合には<code>ref.current.focus()</code>とします。</p>

<p>これまでは、文字列とコールバックを使った Ref 指定が可能でした。文字列を使った Ref は、利用者としては単純でわかりやすいですが、Owner コンテキストで評価されるなど内部の実装としても好ましくない部分があったり、最適化や静的型チェックが難しいという問題がありました。そのため、ずっと廃止予定とアナウンスされていて、今回それに変わる<code>React.createRef()</code>が登場したため、廃止されることが決定しました。（どのバージョンで廃止されるのかはまだ未定です）</p>

<p>コールバックを使った Ref 指定はそのまま残るので、コールバックで指定しているものはそのままで問題ありません。実際 Functional Component の中でただ focus を当てたいような場合には、ref の参照を保持しておく必要がないので、コールバックで処理した方が便利です。</p>

<p><code>js
const Text = () =&gt; &lt;input ref={el =&gt; el &amp;&amp; el.focus()} /&gt;;
</code></p>

<p>公式のドキュメント</p>

<p><a href="https://reactjs.org/docs/refs-and-the-dom.html">https://reactjs.org/docs/refs-and-the-dom.html</a></p>

<h2>forwardRef API</h2>

<p>主に HOC でラップされた Component に対して Ref を指定した場合に使います。</p>

<p><code>React.forwardRef((props, ref) =&gt; &lt;Component {…props} ref={ref} /&gt;)</code>のような形式にすることで、指定された ref を引数として受け取ることが出来るようになるので、そのまま子の Component の ref に指定できます。</p>

<p>Ref は Props と違い伝播させることができなかったので、これまでは、componentRef のような Props として渡す必要があったのですが、これを使うことで、ref として渡すことができるようになります。</p>

<p>Ref で子の Component を参照することが自体が避けるべきことではあるので、そんなに用途はないように思いますが…。</p>

<p>無理やり例を考えて見ると、HOC でラップした Component に対する ref を指定したい場合、</p>

<p>```js
const withColor = Component => color => ({buttonRef, &hellip;props}) => (
  <Component {...props} color={color} ref={buttonRef} />
);</p>

<p>const TomatoButton = withColor(Button)(&lsquo;tomato&rsquo;);</p>

<p>const App = () => (
  <div></p>

<pre><code>&lt;!-- buttonRefとして渡す必要がある --&gt;
&lt;TomatoButton id="foo" buttonRef={button =&gt; button &amp;&amp; button.focus()} /&gt;
</code></pre>

<p>  </div>
);
```</p>

<p><a href="https://codepen.io/koba04/pen/dmKyNd?editors=0010">https://codepen.io/koba04/pen/dmKyNd?editors=0010</a></p>

<p>のように<code>buttonRef</code>などのように Props の一部として渡す必要があったのが、</p>

<p>```js
const withColor = Component => color => React.forwardRef((props, ref) => (
  <Component {...props} color={color} ref={ref} />
));</p>

<p>const TomatoButton = withColor(Button)(&lsquo;tomato&rsquo;);</p>

<p>const App = () => (
  <div></p>

<pre><code>&lt;!-- refとして渡すことが出来る --&gt;
&lt;TomatoButton id="foo" ref={button =&gt; button &amp;&amp; button.focus()} /&gt;
</code></pre>

<p>  </div>
);
```</p>

<p><a href="https://codepen.io/koba04/pen/pLKobo?editors=0010">https://codepen.io/koba04/pen/pLKobo?editors=0010</a></p>

<p>のように<code>React.forwardRef</code>を使うことで、直接 Component を利用する時のように ref として指定出来るようになります。</p>

<p>公式のドキュメント</p>

<p><a href="https://reactjs.org/docs/forwarding-refs.html">https://reactjs.org/docs/forwarding-refs.html</a></p>

<h2>Strict Mode</h2>

<p>新しい Component です。Component なので、<code>&lt;React.StrictMode&gt;…&lt;/React.StrictMode&gt;</code>のように利用します。
Strict Mode の Component 自体は何も UI を描画せず、後述するチェックも development 環境の場合のみチェックするので、本番環境のコードに含めたままでも問題ありません。</p>

<p><code>&lt;StrictMode&gt;</code>で囲まれた Component の中では、廃止予定の API や問題になりそうな使い方をチェックして問題を検出してくれます。現時点では、下記のようなチェックが行われています。</p>

<ul>
<li>Identifying components with unsafe lifecycles

<ul>
<li>componentWillMount や componentWillReceiveProps や componentWillUpdate などの廃止予定の API を使用していないかをチェックして、見つかった場合にはコンソールに出力します。</li>
</ul>
</li>
<li>Warning about legacy string ref API usage

<ul>
<li>文字列を使った ref 指定をチェックして、見つかった場合にはコンソールに出力します。</li>
</ul>
</li>
<li>Detecting unexpected side effects

<ul>
<li>非同期レンダリングが有効になった場合をシミュレートすることで、非同期レンダリングが有効になった時に問題となる副作用のあるコードがないかを検出します。ただし、副作用のあるコードがあるかどうかを検出することはできないので、Strict Mode では、下記の API が意図的に 2 回呼ばれるようになります。

<ul>
<li>constructor</li>
<li>render メソッド</li>
<li>setState の第 1 引数に指定する関数</li>
<li>static getDerivedStateFromProps</li>
</ul>
</li>
<li>これにより、完璧ではないですが、複数回呼ばれると壊れるような副作用のある実装をできることを期待しています。</li>
</ul>
</li>
</ul>


<p>ちなみに、なぜ<code>React.strictMode = true</code>のようになっていないのか疑問に思うかもしれませんが、Component の形式になっていることでアプリケーションの一部だけチェックすることが出来るようになります。これは Facebook が 50,000 以上の Component を持っていることから来ているマイグレーションの戦略かなと思います。</p>

<h2>New Context API</h2>

<p>長くなってきたのでここからは簡潔に&hellip;。</p>

<p>API の変更があるとずっと予告されていた Context の新しい API です。</p>

<p>既存の Context も少なく v16 系ではサポートされ続けます。既存の Context は、<code>react-redux</code>や<code>react-router</code>などのライブラリが内部で使っているので、多くの人に関係あるといえばある変更です。これらのライブラリがどのように対応するのかは、issue などで議論は行われていますがまだ不明です。</p>

<ul>
<li><a href="https://github.com/reactjs/react-redux/pull/898">https://github.com/reactjs/react-redux/pull/898</a></li>
<li><a href="https://github.com/ReactTraining/react-router/pull/5908">https://github.com/ReactTraining/react-router/pull/5908</a></li>
</ul>


<p>また最近軽量な Redux 風なライブラリが増えているのはこの Context API の影響もあると思います。</p>

<ul>
<li><a href="https://github.com/jamiebuilds/unstated">https://github.com/jamiebuilds/unstated</a></li>
</ul>


<p>今回の New Context API は正式な機能としてリリースされましたが、Context を abuse するのではなく、Props を使ってデータのやりとりをするのが基本であるのは変わりません。テーマや言語のような様々な場所、階層で利用されるようなものや Flux の Store など本当に必要な部分のみで利用することが推奨されています。</p>

<p>新しい Context の API は、Component ベースになっていて、<code>const ThemeContext = React.createContext('themeName')</code>で Context を作成し、<code>ThemeContext.Provider</code>と<code>ThemeContext.Consumer</code>を組み合わせます。</p>

<p><code>ThemeContext.Provider</code>が Context の値を管理する、親となる Component です。<code>ThemeContext.Consumer</code>は、Provider の子孫要素であり、Context の値を利用する側です。Provider の子孫であればどこでも利用出来ます。</p>

<p>```js
const ThemeContext = React.createContext(&lsquo;dark&rsquo;);</p>

<p>&lt;ThemeContext.Provider value={&lsquo;dark&rsquo;}>
  <!-- このツリーの中では、ThemeContext.Consumerを通じてThemeContextの値を参照できる -->
  <Child></p>

<pre><code>&lt;ThemeContext.Consumer&gt;
  {(theme) =&gt; &lt;button className={theme}&gt;click&lt;/button&gt;}
&lt;/ThemeContext.Consumer&gt;
</code></pre>

<p>  </Child>
&lt;/ThemeContext.Provider>
```</p>

<p>Render Function のパターンになっているので、複数種類の Context を組み合わせて使うことも勿論可能です。</p>

<p>```js
const LangContext = React.createContext(&ldquo;lang&rdquo;);
const ThemeContext = React.createContext(&ldquo;dark&rdquo;);</p>

<p>&lt;LangContext.Provider value=&ldquo;en&rdquo;>
  &lt;ThemeContext.Provider value=&ldquo;dark&rdquo;></p>

<pre><code>&lt;Child&gt;
  &lt;LangContext.Consumer&gt;
    {lang =&gt; (
      &lt;ThemeContext.Consumer&gt;
        {theme =&gt; (
          &lt;button className={theme}&gt;{getMessage("click", lang)}&lt;/button&gt;
        )}
      &lt;/ThemeContext.Consumer&gt;
    )}
  &lt;/LangContext.Consumer&gt;
&lt;/Child&gt;
</code></pre>

<p>  &lt;/ThemeContext.Provider>
&lt;/LangContext.Provider>;
```</p>

<h3>newContext and legacyContext</h3>

<p>なぜ既存の Context API が置き換えられることになったかというと、Static Type Checking が難しいなどの問題がありますが、一番大きいのは Context の伝播が途中 Component が shouldComponentUpdate で false を返した場合、子孫の Component は再 render されないので、Context の変更が伝わらなくなってしまうことです。</p>

<p>下記のサンプルを見てもらうと oldContext の方は変更が反映されていないことがわかります。</p>

<p><a href="https://codepen.io/koba04/pen/OvvzXb?editors=0010">https://codepen.io/koba04/pen/OvvzXb?editors=0010</a></p>

<h3>observedBits</h3>

<p>新しい Context の API は observedBits という面白い機能を持っています。unstable ですが&hellip;。通常 Context に変更があると対応する全ての Consumer を再 render しますが、observedBits を指定することで、関連のある Consumer のみ再 render させることができます。</p>

<p>方法は、React.createContext の第二引数に、関数を定義します。この関数は変更前後の Context の値を受け取るので、変更内容を示すビット列を返します。</p>

<p><code>js
// foo === 0b01, bar === 0b10のビット列を設定する
const StoreContext = React.createContext(null, (prev, next) =&gt; {
  let result = 0;
  if (prev.foo !== next.foo) result |= 0b01;
  if (prev.bar !== next.bar) result |= 0b10;
  return result;
});
</code></p>

<p>説明するまでもないですが、上記の場合は、foo が変更されたら<code>0b01</code>を、bar が変更されたら<code>0b10</code>のビットを立てています。</p>

<p>そして、Context.Consumer に、<code>unstable_observedBits</code>の Props として、Consumer が受け取っている値に関連するビット列を指定します。そうすることで、createContext の第 2 引数が返すビット列(changedBits)と Consumer の unstable_observedBits の論理積(<code>&amp;</code>)をとって 0 じゃない場合のみ再 render されます。</p>

<p>```js
// foo(0b01)が変わった場合のみrenderされる
&lt;StoreContext.Consumer unstable_observedBits={0b01}>
  {({foo}) => <div>{foo}</div>
&lt;/StoreContext.Consumer></p>

<p>// bar(0b10)が変わった場合のみrenderされる
&lt;StoreContext.Consumer unstable_observedBits={0b10}>
  {({bar}) => <div>{bar}</div>
&lt;/StoreContext.Consumer></p>

<p>// どちらでも(このば場合、unstable_observedBitsは省略できる
&lt;StoreContext.Consumer unstable_observedBits={0b11}>
  {({foo, bar}) => <div>{foo}:{bar}</div>
&lt;/StoreContext.Consumer>
```</p>

<p>Redux のようなライブラリを組み合わせる時の最適化として使えそうですね。</p>

<p>詳しくは下記のサンプルを見てください。</p>

<p><a href="https://codepen.io/koba04/pen/WzzXJx?editors=0010">https://codepen.io/koba04/pen/WzzXJx?editors=0010</a></p>

<p>ちなみに React の内部でも、Mode や SideEffect はビット列を使って定義されていて、ビット演算を使って処理されています。</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactTypeOfMode.js">https://github.com/facebook/react/blob/master/packages/react-reconciler/src/ReactTypeOfMode.js</a></li>
</ul>


<p><code>js
export const NoContext = 0b00;
export const AsyncMode = 0b01;
export const StrictMode = 0b10;
</code></p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/packages/shared/ReactTypeOfSideEffect.js">https://github.com/facebook/react/blob/master/packages/shared/ReactTypeOfSideEffect.js</a></li>
</ul>


<p><code>js
export const NoEffect = /*              */ 0b000000000000;
export const PerformedWork = /*         */ 0b000000000001;
// You can change the rest (and add more).
export const Placement = /*             */ 0b000000000010;
export const Update = /*                */ 0b000000000100;
export const PlacementAndUpdate = /*    */ 0b000000000110;
export const Deletion = /*              */ 0b000000001000;
export const ContentReset = /*          */ 0b000000010000;
export const Callback = /*              */ 0b000000100000;
export const DidCapture = /*            */ 0b000001000000;
export const Ref = /*                   */ 0b000010000000;
export const ErrLog = /*                */ 0b000100000000;
export const Snapshot = /*              */ 0b100000000000;
// Union of all host effects
export const HostEffectMask = /*        */ 0b100111111111;
export const Incomplete = /*            */ 0b001000000000;
export const ShouldCapture = /*         */ 0b010000000000;
</code></p>

<h2>Others</h2>

<p>その他、細かい変更についても、軽く触れておきます。</p>

<h3>Rename React.unstable_AsyncComponent to React.unstable_AsyncMode</h3>

<p>指定した Component の中で発生した更新処理をデフォルト Low Priority として扱うことのできる<code>React.unstable_AsyncComponent</code>が、<code>React.unstable_AsyncMode</code>にリネームされました。また、以前は可能だった extends する使い方が出来なくなっています。</p>

<h3>New react-is package</h3>

<p><code>react-is</code>という新しいパッケージが公開されました。この中には様々な Component 種別に対する比較処理などを、内部実装を直接参照することなくできます。
Component の種別を使って何かしたい場合に使えます。色々な API が定義されているので、ドキュメントを参照してください。</p>

<p>```js
import * as ReactIs from &lsquo;react-is&rsquo;;</p>

<p>ReactIs.isValidElementType(ClassComponent); // true
ReactIs.isContextConsumer(&lt;ThemeContext.Consumer />); // true
:
:
```</p>

<p><a href="https://github.com/facebook/react/tree/master/packages/react-is">https://github.com/facebook/react/tree/master/packages/react-is</a></p>

<h3>New react-lifecycles-compat package</h3>

<p>static getDerivedStateFromProps や getSnapshotBeforeUpdate を使って書かれた Component をこれらをサポートしていない、古いバージョンの React でも動作させるためのパッケージです。</p>

<p>これを使うことで、Component の開発者は新しいライフサイクルメソッドの API を、古いバージョンの React のサポートを切り捨てることなく利用出来ます。
HOC として提供されています。</p>

<p>内部では、static getDerivedStateFromProps や getSnapshotBeforeUpdate の動作を、既存の componentWillMount や componentWillReceiveProps、componentWillUpdate でエミュレートする形になっています。</p>

<p>```js
import React from &ldquo;react&rdquo;;
import { polyfill } from &ldquo;react-lifecycles-compat&rdquo;;</p>

<p>class ExampleComponent extends React.Component {
  // &hellip;
}
polyfill(ExampleComponent);</p>

<p>export default ExampleComponent;
```</p>

<p><a href="https://github.com/reactjs/react-lifecycles-compat">https://github.com/reactjs/react-lifecycles-compat</a></p>

<h3>New create-subscription package</h3>

<p>非同期レンダリングを考慮した、イベントを購読する処理を実装するためのライブラリです。これは Flux ライブラリの実装として利用することを想定されているのではなく、Geolocation などの API を監視して何かしたい場合の使用が想定されています。そこまで利用シーンは多くない気はしています。（IntersectionObserver とかと組み合わせると良さそう？）</p>

<p>```js
import { createSubscription } from &ldquo;create-subscription&rdquo;;</p>

<p>const Subscription = createSubscription({
  getCurrentValue(source) {</p>

<pre><code>// 現在の値を返します
</code></pre>

<p>  },
  subscribe(source, callback) {</p>

<pre><code>// sourceのPropsを受け取って、変更があった時にcallbackを呼びます
</code></pre>

<p>  }
});</p>

<p><Subscription source={eventDispatcher}>
  {value => <AnotherComponent value={value} />}
</Subscription>;
```</p>

<p>Component がマウントされているかどうかの状態も考慮してくれているので、Promise を使って非同期処理の結果を Component に適用することを安全に行うために使うことも出来ます。</p>

<p><a href="https://github.com/facebook/react/tree/master/packages/create-subscription">https://github.com/facebook/react/tree/master/packages/create-subscription</a></p>

<h3>Expose react-reconciler/persistent</h3>

<p>カスタムレンダラーを作成するための<code>react-reconciler</code>で、persistent モデルの reconciler が外部に公開されました。これ何かやってるなぁと認識してはいたものの、しっかり見ていないのでどういうものかはわかっていません。</p>

<h3>Remove useSyncScheduling</h3>

<p>フラグが削除されています。なので現時点では前述した<code>React.unstable_AsyncMode</code>で使い分ける形になります。</p>

<p>その他の CHANGELOG は下記にあります。自分の PR も 2 つほど入ってました（実装したことも忘れてましたが…）</p>

<p><a href="https://github.com/facebook/react/blob/master/CHANGELOG.md#1630-march-29-2018">https://github.com/facebook/react/blob/master/CHANGELOG.md#1630-march-29-2018</a></p>

<hr />

<p>というわけで色々入りましたが、どれも必要に応じて使えばいいものなので、出来るようになったことを把握しつつ、ゆっくり v17 の準備をするのがいいのかなと思います。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React v16でのサーバーサイドレンダリング]]></title>
    <link href="http://blog.koba04.com/post/2017/10/01/serverside-rendering-in-react-v16/"/>
    <updated>2017-10-01T23:02:46+09:00</updated>
    <id>http://blog.koba04.com/post/2017/10/01/serverside-rendering-in-react-v16</id>
    <content type="html"><![CDATA[<p>React v16について書いたブログの中の、サーバーサイドレンダリングについての部分に間違いがあったので修正しつつ、v16のサーバーサイドレンダリングについて補足します。</p>

<p><a href="http://blog.koba04.com/post/2017/09/27/react-v16-changes/">http://blog.koba04.com/post/2017/09/27/react-v16-changes/</a></p>

<p><strong>Hydrationしたい場合は、renderToStringまたはrenderToNodeStreamで行う必要があります。</strong></p>

<p>renderToStringまたはrenderToNodeStreamには、<code>data-reactroot</code>以外にも変数部分を識別するためのコメントノードなどが挿入されていて、それが必要であるためです。</p>

<p>それでは、v15とv16でのサーバーサイドレンダリングの違いを見てみます。</p>

<!-- more -->


<p>以下、長いのでサーバーサイドレンダリングはSSRと略します。</p>

<h2>v15まで</h2>

<p>ReactでSSRしたコンテンツをクライアントでも再利用したい場合、これまではSSRしたHTMLを元に生成されたchecksumとクライアントサイドで構築したReactElementから生成したchecksumが一致する必要がありました。</p>

<p>これはつまり、ReactDOMServer.renderToStringのエントリーポイントと、ReactDOM.renderのエントリーポイントが一致する必要があることを示します。</p>

<p>つまりHTML全体をReactで構築しようとするとこんな感じになります。</p>

<ul>
<li>App.js</li>
</ul>


<p>```js
import React from &lsquo;react&rsquo;;
const App = (props) => {</p>

<pre><code>return &lt;div&gt;Hello {props.name}&lt;/div&gt;;
</code></pre>

<p>};
export default App;
```</p>

<ul>
<li>Html.js</li>
</ul>


<p>```js
import React from &lsquo;react&rsquo;;</p>

<p>const Html = (props) => {</p>

<pre><code>return (
    &lt;html&gt;
        &lt;head&gt;
            &lt;title&gt;App&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;div id="app" dangerouslySetInnerHTML={ {__html: props.markup} }&gt;&lt;/div&gt;
            &lt;script id="initial-data" type="text/plain" data-json={props.initialData}&gt;&lt;/script&gt;
            &lt;script src="http://blog.koba04.com/static/bundle.js"&gt;&lt;/script&gt;
        &lt;/body&gt;
    &lt;/html&gt;
);
</code></pre>

<p>};</p>

<p>export default Html;
```</p>

<ul>
<li>server.js</li>
</ul>


<p>```js
import React from &lsquo;react&rsquo;;
import ReactDOMServer from &lsquo;react-dom/server&rsquo;;
import express from &lsquo;express&rsquo;;</p>

<p>import Html from &lsquo;./Html&rsquo;;
import App from &lsquo;./App&rsquo;;</p>

<p>const app = express();</p>

<p>const initialData = {</p>

<pre><code>name: 'World'
</code></pre>

<p>};</p>

<p>app.get(&lsquo;/&rsquo;, (req, res) => {</p>

<pre><code>res.send(
    ReactDOMServer.renderToStaticMarkup(
        &lt;Html
            markup={ReactDOMServer.renderToString(&lt;App {...initialData} /&gt;)}
            initialData={JSON.stringify(initialData)}
        /&gt;
    )
);
</code></pre>

<p>});</p>

<p>app.listen(3000);
```</p>

<ul>
<li>browser.js</li>
</ul>


<p>```js
import React from &lsquo;react&rsquo;;
import ReactDOM from &lsquo;react-dom&rsquo;;
import App from &lsquo;./App&rsquo;;</p>

<p>const initialData = JSON.parse(document.getElementById(&lsquo;initial-data&rsquo;).getAttribute(&lsquo;data-json&rsquo;));</p>

<p>ReactDOM.render(<App {...initialData} />, document.getElementById(&lsquo;app&rsquo;));
```</p>

<p>上記のように<code>Html.js</code>ではdangerouslySetInnerHTMLを使い、アプリケーションのComponentをrenderToStringによりchecksumなどが付与されたHTML文字列として埋め込む必要があります。</p>

<p>また<code>server.js</code>では、HTML全体の部分はrenderToStaticMarkupで、アプリケーションの部分はrenderToStringでと、別々に生成する必要があります。</p>

<p>これにより、renderToStringとReactDOM.renderで構築される内容が一致するため、SSRによって生成されたDOMが再利用されます。</p>

<h2>v16</h2>

<p>v16では、checksumによりチェックは行われず、可能な限りすでに構築されているDOMを再利用しようとします。
また、ReactDOM.hydrateという明示的なAPIを使うことで、サーバー側とクライアント側でエントリーポイントを合わせる必要はありません。
（ReactDOM.renderを使う場合は、<code>data-reactroot</code>の属性がDOMにあるかをチェックしているのでエントリーポイントを合わせる必要があります）</p>

<p>そのためv15のように、エントリーポイントを一致させるために、アプリケーションのComponentを別途HTML文字列として生成する必要はありません。</p>

<p>したがって、上記の例は、v16で追加されたrenderToNodeStreamを使うと</p>

<ul>
<li>App.js</li>
</ul>


<p>```js
import React from &lsquo;react&rsquo;;
const App = (props) => {</p>

<pre><code>return &lt;div&gt;Hello {props.name}&lt;/div&gt;;
</code></pre>

<p>};
export default App;
```</p>

<ul>
<li>Html.js</li>
</ul>


<p>```js
import React from &lsquo;react&rsquo;;</p>

<p>const Html = (props) => {</p>

<pre><code>return (
    &lt;html&gt;
        &lt;head&gt;
            &lt;title&gt;App&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;div id="app"&gt;{props.children}&lt;/div&gt;
            &lt;script id="initial-data" type="text/plain" data-json={props.initialData}&gt;&lt;/script&gt;
            &lt;script src="http://blog.koba04.com/static/bundle.js"&gt;&lt;/script&gt;
        &lt;/body&gt;
    &lt;/html&gt;
);
</code></pre>

<p>};</p>

<p>export default Html;
```</p>

<ul>
<li>server.js</li>
</ul>


<p>```js
import React from &lsquo;react&rsquo;;
import ReactDOMServer from &lsquo;react-dom/server&rsquo;;
import express from &lsquo;express&rsquo;;</p>

<p>import Html from &lsquo;./Html&rsquo;;
import App from &lsquo;./App&rsquo;;</p>

<p>const app = express();</p>

<p>const initialData = {</p>

<pre><code>name: 'World'
</code></pre>

<p>};</p>

<p>app.get(&lsquo;/&rsquo;, (req, res) => {</p>

<pre><code>ReactDOMServer.renderToNodeStream(
    &lt;Html initialData={JSON.stringify(initialData)}&gt;
        &lt;App {...initialData} /&gt;
    &lt;/Html&gt;
).pipe(res);
</code></pre>

<p>});</p>

<p>app.listen(3000);
```</p>

<ul>
<li>browser.js</li>
</ul>


<p>```js
import React from &lsquo;react&rsquo;;
import ReactDOM from &lsquo;react-dom&rsquo;;
import App from &lsquo;./App&rsquo;;</p>

<p>const initialData = JSON.parse(document.getElementById(&lsquo;initial-data&rsquo;).getAttribute(&lsquo;data-json&rsquo;));</p>

<p>ReactDOM.hydrate(<App {...initialData} />, document.getElementById(&lsquo;app&rsquo;));
```</p>

<p>上記ではHtmlのComponent内で、アプリケーションのComponentを、ReactDOM.hydrateの対象となるDOMの子要素として渡しているだけです。
HTML文字列として渡したりする必要はありません。</p>

<p>また全体もrenderToNodeStreamでまとめて構築できるため、コードもシンプルになります。</p>

<p>というわけで、v16ではSSRのコードもよりシンプルに書けるように効率的になっています。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React v16 changes]]></title>
    <link href="http://blog.koba04.com/post/2017/09/27/react-v16-changes/"/>
    <updated>2017-09-27T16:34:07+09:00</updated>
    <id>http://blog.koba04.com/post/2017/09/27/react-v16-changes</id>
    <content type="html"><![CDATA[<p>Reactのv16がリリースされたので、変更点などを整理したいと思います。</p>

<ul>
<li><a href="https://facebook.github.io/react/blog/2017/09/26/react-v16.0.html">https://facebook.github.io/react/blog/2017/09/26/react-v16.0.html</a></li>
<li><a href="https://code.facebook.com/posts/1716776591680069/react-16-a-look-inside-an-api-compatible-rewrite-of-our-frontend-ui-library/">https://code.facebook.com/posts/1716776591680069/react-16-a-look-inside-an-api-compatible-rewrite-of-our-frontend-ui-library/</a></li>
</ul>


<p>React v16やReact Fiberについては、下記で書いたりもしているのでそちらも参考にしてみてください。</p>

<ul>
<li><a href="http://blog.koba04.com/post/2017/04/25/a-state-of-react-fiber/">React Fiber現状確認</a></li>
<li><a href="https://speakerdeck.com/koba04/capability-of-react-fiber">Capability of React Fiber</a></li>
<li><a href="https://speakerdeck.com/koba04/react-v16-and-beyond-react-fiber">React v16 and beyond React Fiber</a></li>
<li><a href="https://html5experts.jp/shumpei-shiraishi/23265/">ReactはなぜFiberで書き直されたのか？Reactの課題と将来像を探る</a></li>
</ul>


<!-- more -->


<h2>新機能</h2>

<h3>render関数から文字列や配列を直接返せるように</h3>

<p>地味に嬉しい機能ですね。これまでは無駄にspanやdivで囲むしかなかったのが、直接文字列や配列を返すことができるようになります。</p>

<p><code>``js
// 文字列を直接返す
const DisplayName = ({user}) =&gt;</code>${user.name} (@${user.id})`;</p>

<p>// 配列
const Row = ({children}) => <tr>{children}</tr>;
const Columns = ({items}) => (
  items.map((item, id) => <td key={i}>{item}</td>)
);
<Row></p>

<pre><code>&lt;Columns items={['foo', 'bar', 'baz']} /&gt;
</code></pre>

<p></Row>
```</p>

<p>配列を返す場合は、<code>key</code>を必ずつける必要があります。
それをJSXのSyntaxレベルでサポートするという議論もあったりします。</p>

<ul>
<li><a href="https://github.com/facebook/jsx/issues/84">https://github.com/facebook/jsx/issues/84</a></li>
</ul>


<p>```js
[</p>

<pre><code>&lt;li key={1}&gt;foo&lt;/li&gt;,
&lt;li key={2}&gt;bar&lt;/li&gt;,
&lt;li key={3}&gt;baz&lt;/li&gt;,
</code></pre>

<p>]</p>

<p>↓↓↓</p>

<p>// こんな感じで書けるようにしたいという議論
&lt;>
  <li>foo</li>
  <li>bar</li>
  <li>baz</li>
</>
```</p>

<h3>Error Boundaries</h3>

<p>子のComponentのrender関数やライフサイクルメソッドで起きたエラーを、<code>componentDidCatch</code>というライフサイクルメソッドでキャッチできるようになります。
これによって、エラーが起きたことをユーザーに伝えたり、エラーリポートのサービスに送信できるようになります。</p>

<p>```js
class Child extends React.Component {</p>

<pre><code>componentDidMount() {
    // 〜 is not a functionみたいなエラーでも同様
    throw new Error('Something went wrong!!');
}
render() {
  return &lt;p&gt;Child!&lt;/p&gt;;
}
</code></pre>

<p>}</p>

<p>class App extends React.Component {
  constructor(props) {</p>

<pre><code>super(props);
this.state = {
  error: null
};
</code></pre>

<p>  }
  componentDidCatch(error, info) {</p>

<pre><code>this.setState({error});
console.log(error.message, info.componentStack);
// Something went wrong!! 
// in Child (created by App)
// in section (created by App)
// in App
</code></pre>

<p>  }
  render() {</p>

<pre><code>return (
  &lt;section&gt;
    {this.state.error ? &lt;p&gt;エラーが発生しました&lt;/p&gt; : &lt;Child /&gt;}
  &lt;/section&gt;
);
</code></pre>

<p>  }
}
```</p>

<p>上記のように、componentDidCatchの引数には、Errorオブジェクト以外に<code>info</code>というオブジェクトを受け取ります。infoは今のところ<code>componentStack</code>のプロパティしか持っていません。<code>componentStack</code>には、Compnentのスタックトレースが文字列で入っています。したがって、これをエラーと一緒に送信すると、どこのComponentでどのエラーが発生したのかがわかります。</p>

<p><strong>Error Boundariesの対象になるのは、render関数とライフサイクルメソッドの中のエラーだけです。</strong>なので、イベントハンドラーの中で起きたエラーや、ライフサイクルメソッドの中での非同期処理（HTTP Requestなど)で起きたエラーは対象になりません。</p>

<p>また、もう一点、上記のError Boundariesの対象となるエラーに対する扱いが変更されています。</p>

<p>v15までは、エラーが発生したらそこで処理が中断されていました。したがって、途中のComponentのrenderで処理が止まるなど、不整合なViewをユーザーに見せてしまう可能性がありました。</p>

<p>v16では、エラーが発生すると、ReactDOM.renderで指定したRoot Containerから全てアンマウント（DOMから削除）されるようになります。
それを避けたい場合には、上記の例のようにcomponentDidCatchを定義してsetStateするなどしてエラー用の表示を行う必要があります。
なので、親のComponentでcomponentDidCatchを定義したり、componentDidCatchを定義したComponentでアプリケーション全体のComponentをラップしておくと安心かと思います。</p>

<h3>Portals</h3>

<p><code>ReactDOM.createPortal</code>というAPIが追加されました。</p>

<ul>
<li><a href="https://facebook.github.io/react/docs/portals.html">https://facebook.github.io/react/docs/portals.html</a></li>
</ul>


<p>これは、Componentツリーの外側に対するrenderをComponentツリーの一部として扱えるようにする機能です。
文字だけで書くとわかりにくいので例として、どこかアプリケーションの外側にモーダル用のDOMがあって、アプリケーションのStateによってモーダルを表示したい場合を考えてみます。</p>

<p>Portalを使わずに書くと、</p>

<p>```js
class App extends React.Component {</p>

<pre><code>componentDidUpdate() {
    const container = document.querySelector('.modal-container');
    if (this.state.modal) {
        ReactDOM.render(
            &lt;Modal
                type={this.state.modal}
                onClose={() =&gt; {
                    this.setState(
                        () =&gt; ({modal: null}),
                        () =&gt; ReactDOM.unmountComponentAtNode(container)
                    )
                }}
            &gt;
        );
    }
}
render() {
    // ....
}
</code></pre>

<p>}
```</p>

<p>とcomponentDidUpdateやcomponentDidMountのライフサイクルメソッドの中で扱う形になりますが、Portalを使うと、</p>

<p>```js
class App extends React.Component {</p>

<pre><code>render() {
    &lt;section&gt;
        &lt;Contents /&gt;
        {this.state.modal &amp;&amp; ReactDOM.createPortal(
            &lt;Modal
                type={this.state.modal}
                onClose={() =&gt; {
                    this.setState(() =&gt; ({modal: null}))
                }}
            /&gt;,
            document.querySelector('.modal-container')
        )}
    &lt;/section&gt;
}
</code></pre>

<p>}
```</p>

<p>というように、render関数の中に書くことが出来ます。
この場合Modalは、Contentsの隣に配置されたComponentと同様に処理されます。</p>

<p>なので、</p>

<p>```js
<section></p>

<pre><code>&lt;div onClick={() =&gt; console.log('click')}&gt;
    {ReactDOM.createPortal(
        &lt;p&gt;Portal&lt;/p&gt;,
        document.querySelector('.somewhere')
    )}
&lt;/div&gt;
</code></pre>

<p></section>
```</p>

<p>とあった場合、<code>&lt;p&gt;Portal&lt;/p&gt;</code>をクリックした場合にも、<code>cosole.log('click')</code>が呼ばれます。</p>

<h3>ServerSide Rendering</h3>

<p>サーバーサイドレンダリングは完全にリライトされました（既存の実装をベースに）。
これまでは、クライアントでのDOM構築と同じ流れでHTMLを構築していたのですが、下記の1ファイルに切り離されました。</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/shared/server/ReactPartialRenderer.js">https://github.com/facebook/react/blob/master/src/renderers/shared/server/ReactPartialRenderer.js</a></li>
</ul>


<p>これにより、無駄な処理が減ったことによる高速化やStreamサポートが簡単に行えるようになりました。
また、独立したファイルになったことで、今後のパフォーマンスチューニングもやりやすくなったと思います。</p>

<p>その他サーバーサイドレンダリングに対する変更は、Node Stream対応のAPIの追加とHydarationの方法の変更です。</p>

<p>Node Streamの対応については、<code>renderToNodeStream</code>と<code>renderToStaticNodeStream</code>のAPIが追加されたので、それを使うだけです。</p>

<p>```js
import ReactDOMServer from &lsquo;react-dom/server&rsquo;;</p>

<p>const App = () => (</p>

<pre><code>&lt;div&gt;
    &lt;p&gt;Hello Stream&lt;/p&gt;
&lt;/div&gt;
</code></pre>

<p>);</p>

<p>ReactDOMServer.renderToNodeStream(<App />).pipe(process.stdin);
// <div data-reactroot=""><p>Hello Stream!</p></div></p>

<p>ReactDOM.server.renderToStaticNodeStream(<App />).pipe(process.stdin);
// <div><p>Hello Stream!</p></div>
```</p>

<p>Hydrationの方法の変更については、クライアント側の変更とバリデーションロジックの変更があります。</p>

<p>ここでいうHydrationとは、サーバーサイドレンダリングで返したHTMLが生成したDOM要素を、クライアント側でのレンダリング時に再利用することを指します。</p>

<p>クライアント側でのAPIの変更については、ReactDOM.renderの代わりに<code>ReactDOM.hydrate</code>という専用のAPIを使うようになります。
v16の段階では、ReactDOM.renderによるHydrationもサポートされますが、将来的に廃止される予定です。</p>

<p><del>ちなみに、renderToNodeStreamとrenderToStaticNodeStreamによる出力の違いは、Rootの要素に<code>data-reactroot</code>があるかないかの違いだけです。このdata-reactrootはReactDOM.renderでHydrationするかどうかの判定に使われているだけです。
なので、将来的にはどちらか1つのAPIだけになると思います。ReactDOM.hydrateを使う場合は、renderToStaticNodeStreamで生成したHTMLに対してもHydration出来ます。</del></p>

<hr />

<p><strong>[2017/10/01:訂正]</strong></p>

<p>renderToNodeStreamとrenderToStaticNodeStreamによる出力の違いは、Rootの要素に<code>data-reactroot</code>以外にも、変数部分を識別するためのコメントノードの差し込みがあります。
したがって、Hydrationする場合にはrenderToNodeStreamを、それ以外の場合はrenderToStaticNodeStreamという使い分けになります。</p>

<hr />

<p>Hydrationの方法については、v15まではrenderToStringで生成したHTMLの<code>data-react-check-sum</code>という属性につけられたチェックサムを使い、クライアント側で生成したReactElementの構造が一致するかどうか判定し、一致すればDOMを再利用して一致しなければDOMを再構築する方法を採用していました。</p>

<p>v16では、サーバーサイドレンダリングで構築したDOMを、React.hydrateの際に可能な限り再利用しようとします。
ReactElementの構造が一致するかどうかの確認が、ReactElementの単位で行われるようになります。
（一致しない場合は、引き続きwarningが出力されます）
ただし、バリデーションするというよりも可能な限り再利用する方針であるため、サーバーサイドレンダリングした内容とのdiff次第では、意図しない結果となる場合があります。</p>

<ul>
<li><a href="https://github.com/facebook/react/issues/10591">https://github.com/facebook/react/issues/10591</a></li>
</ul>


<p>サーバーサイドレンダリングで意図的に異なるコンテンツを返している場合は、一度DOMをリセットする方がいいかもしれません。</p>

<p>これにより、<code>data-react-check-sum</code>だけでなく、<code>react-text</code>のコメントや<code>data-react-id</code>もHTMLに付加されなりました。</p>

<p>サーバーサイドレンダリングについては、補足記事書きました。</p>

<ul>
<li><a href="http://blog.koba04.com/post/2017/10/01/serverside-rendering-in-react-v16/">http://blog.koba04.com/post/2017/10/01/serverside-rendering-in-react-v16/</a></li>
</ul>


<h3>DOM Attributes</h3>

<p>これまでは、ホワイトリストで管理された属性以外は、warningを出しつつDOMには反映されなかったのですが、v16からは反映されるようになります。
これにより、ng-xxとかv-xxみたいな属性や、一部ブラウザーが実装しているけどまだ標準化されていないような属性値も使えるようになります。
ただし、on〜といった属性値については、セキュリティ的なリスクから反映されません。</p>

<p>また、属性が期待している型とは異なる値を渡した場合に、値が反映されなくなります。
例えばclassNameにfalseを渡した場合は、v15までは"false"という文字列がクラス名と設定されていましたが、v16からはwarningが出て反映されなくなります。</p>

<p>詳細は、下のブログに。</p>

<ul>
<li><a href="https://facebook.github.io/react/blog/2017/09/08/dom-attributes-in-react-16.html">https://facebook.github.io/react/blog/2017/09/08/dom-attributes-in-react-16.html</a></li>
</ul>


<h3>Bundle Size</h3>

<p>Browserifyを使ったビルドからRollupを使ったビルドに変更されて、フラットバンドルになりました。
Rollupを使って1つのモジュールとしてビルドすることで、Browserifyが付加する依存関係解決のためのコードが不要になります。
その結果、ファイルサイズの削減やブラウザー上での初回読み込みの時間が短縮されます。</p>

<p>reactとreact-domのv16をnpmからインストールすると、下記のような構造になっており、内部モジュールの構造は維持されていません。</p>

<ul>
<li>react</li>
</ul>


<p>```
node_modules/react/
├── LICENSE
├── README.md
├── cjs
│   ├── react.development.js
│   └── react.production.min.js
├── index.js
├── node_modules
├── package.json
└── umd</p>

<pre><code>├── react.development.js
└── react.production.min.js
</code></pre>

<p>```</p>

<ul>
<li>react-dom</li>
</ul>


<p><code>
node_modules/react-dom/
├── LICENSE
├── README.md
├── cjs
│   ├── react-dom-server.browser.development.js
│   ├── react-dom-server.browser.production.min.js
│   ├── react-dom-server.node.development.js
│   ├── react-dom-server.node.production.min.js
│   ├── react-dom-test-utils.development.js
│   ├── react-dom-unstable-native-dependencies.development.js
│   ├── react-dom-unstable-native-dependencies.production.min.js
│   ├── react-dom.development.js
│   └── react-dom.production.min.js
├── index.js
├── node_modules
├── package.json
├── server.browser.js
├── server.js
├── test-utils.js
├── umd
│   ├── react-dom-server.browser.development.js
│   ├── react-dom-server.browser.production.min.js
│   ├── react-dom-unstable-native-dependencies.development.js
│   ├── react-dom-unstable-native-dependencies.production.min.js
│   ├── react-dom.development.js
│   └── react-dom.production.min.js
└── unstable-native-dependencies.js
</code></p>

<p>上記の<code>cjs</code>がcommonJSのビルドが入っているディレクトリです。<code>〜.development.js</code>と<code>〜.production.min.js</code>があるのは本番用のビルドと開発用のビルドを分けるためです。
この分岐はindex.jsの中で<code>process.env.NODE_ENV</code>によって行われています。</p>

<ul>
<li><code>node_modules/react/index.js</code></li>
</ul>


<p>```js
&lsquo;use strict&rsquo;;</p>

<p>if (process.env.NODE_ENV === &lsquo;production&rsquo;) {
  module.exports = require(&lsquo;./cjs/react.production.min.js&rsquo;);
} else {
  module.exports = require(&lsquo;./cjs/react.development.js&rsquo;);
}
```</p>

<p>これにより、Direct importと言われている<code>react/lib/xxx</code>のような形での内部モジュール参照が出来なくなります。これは、主にカスタムレンダラーの実装や内部の挙動を変更させるために行われており、そういったライブラリーを使っている場合には注意が必要です。</p>

<p>ちなみに、下記をwebpackとBabel(es2015とreactのprest)でビルドして、比較してみるとこんな感じでした。</p>

<p>```js
import React from &lsquo;react&rsquo;;
import ReactDOM from &lsquo;react-dom&rsquo;;</p>

<p>const App = () => <div>Hello</div>;</p>

<p>ReactDOM.render(<App />, document.getElementById(&lsquo;app&rsquo;));
```</p>

<ul>
<li>v15.6.2</li>
</ul>


<p><code>
bundle.js  742 kB
bundle.js  151 kB // with `-p` option
</code></p>

<ul>
<li>16.0.0</li>
</ul>


<p><code>
bundle.js  794 kB
bundle.js  117 kB // with `-p` option
</code></p>

<p>production buildは小さくなってますね。</p>

<p>また、UMDビルドのディレクトリ名とファイル名が変更になっているので、CDNから利用する場合などは注意してください。</p>

<h3>License</h3>

<p>ライセンスがBSD + PATENTSからMITになりました。</p>

<ul>
<li><a href="https://code.facebook.com/posts/300798627056246/relicensing-react-jest-flow-and-immutable-js/">https://code.facebook.com/posts/300798627056246/relicensing-react-jest-flow-and-immutable-js/</a></li>
</ul>


<h3>Addons</h3>

<p>v15.5の時点で、廃止するアナウンスが出ていましたが、<code>react-addons-xxx</code>のパッケージは廃止になります。
基本的には、別パッケージになったりしているので使っているものがあれば下記で移行パスを確認してみてください。</p>

<ul>
<li><a href="https://facebook.github.io/react/blog/2017/04/07/react-v15.5.0.html#discontinuing-support-for-react-addons">https://facebook.github.io/react/blog/2017/04/07/react-v15.5.0.html#discontinuing-support-for-react-addons</a></li>
</ul>


<p>react-addons-perfに関しては、<code>?react_perf</code>をURLにつけてBrowserのPerformanceのTimelineで計測する方法になります。</p>

<ul>
<li><a href="https://facebook.github.io/react/docs/optimizing-performance.html#profiling-components-with-the-chrome-performance-tab">https://facebook.github.io/react/docs/optimizing-performance.html#profiling-components-with-the-chrome-performance-tab</a></li>
</ul>


<p>react-with-addons.jsのようなUMDビルドももう提供されません。</p>

<h2>Breaking Changes</h2>

<p>React Fiberに実装が変わったことによる、処理順の変更などが多いです。</p>

<ul>
<li>ReactDOM.renderとReactDOM.unstable_renderIntoContainerをライフサイクルメソッドの中で読んだ場合にはnullが返るようになります。</li>
<li>setStateでnullを渡した場合、更新処理が行われなくなります。</li>
<li>renderの中でのsetStateは常に更新処理が行われるようになります（以前はされない場合があったらしい）。そもそもrenderの中でsetStateを呼び出すべきではないですが。</li>
<li>setStateの第2引数のコールバックはcomponentDidMountとcomponentDidUpdateの後すぐに呼び出されるようになります。以前は全てのComponentがrenderされた後に呼び出されていました。 <strong>???以前のバージョンの挙動が確認できなかった</strong></li>
<li><code>&lt;A /&gt;</code>から<code>&lt;B /&gt;</code>に置き換えたとき、B.componentWillMountが常にA.componentWillUnmountの前に呼ばれるようになります。</li>
<li>以前は、refを更新する際のデタッチ(nullでの呼び出し)はComponentのrender関数の前に呼ばれていましたが、render関数の後に変更になります。</li>
<li>React以外によって、編集されたDOMに対して再度ReactDOM.renderを行った時にwarningが出るようになりました。この場合は一度ReactDOM.unmountComponentAtNodeでアンマウントしてから再度renderを行います。</li>
<li>componentDidUpdateのライフサイクルメソッドが第3引数としてprevContextを受け取らなくなりました。</li>
<li>ShallowRendererにunstable_batchedUpdatesはもう実装されません。</li>
</ul>


<p>下記はすでにwarningの対象で今回のバージョンで完全に削除されたものです。</p>

<ul>
<li><code>React.createClass</code>が削除されました。代わりに<code>create-react-class</code>を使います。</li>
<li><code>React.PropTypes</code>が削除されました。代わりに<code>pro-types</code>を使います。</li>
<li><code>React.DOM.xxx</code>が削除されました。代わりに<code>react-dom-factories</code>を使います。</li>
</ul>


<h2>JavaScript Environment Requirements</h2>

<p>動作環境として、<code>Map</code>と<code>Set</code>と<code>requestAnimationFrame</code>が必要になりました。
なので必要に応じてpolyfillを設定します。</p>

<p>```js
import &lsquo;core-js/es6/map&rsquo;;
import &lsquo;core-js/es6/set&rsquo;;</p>

<p>import raf from &lsquo;raf&rsquo;;
if (!window.requestAnimationFrame) {</p>

<pre><code>window.requestAnimationFrame = raf;
// or
window.requestAnimationFrame = cb =&gt; {
    setTimeout(cb, 0);
}
</code></pre>

<p>}
```</p>

<h2>React Fiber</h2>

<p>React Fiberについてはすでに書いたので省略しますが、v16の時点ではv15と互換性のある同期モードで動作します。
したがって、v16にあげたからといって、大きくパフォーマンスが向上したりするようなことはありません（多少のパフォーマンスが上がるかもですが）。</p>

<p>現時点では、いくつかの方法を使うことで、非同期renderingを試すことができるので紹介します。ただし、非同期rendering周りはまだ安定しておらず、コードもガンガン変わっているので注意が必要です。</p>

<h3>ReactDOM.unstable_deferredUpdates</h3>

<p><code>ReactDOM.unstable_deferredUpdates</code>で囲んだ中でのsetStateなどの更新処理は、Low Priorityとして扱われて、requestIdleCallbackを使って非同期に処理されます。</p>

<p>```js
ReactDOM.unstable_deferredUpdates(() => {</p>

<pre><code>this.setState(() =&gt; newState);
</code></pre>

<p>});
```</p>

<h3>React.unstable_AsyncComponent</h3>

<p><code>React.unstable_AsyncComponent</code>の中で起きた更新処理はLow Priorityとして扱われるようになります。
直接Componentとして使う方法と、PureComponentのようにextends対象として使う方法があります。</p>

<p>```js
const AsyncComponent = React.unstable_AsyncComponent;</p>

<p>ReactDOM.render(</p>

<pre><code>&lt;AsyncComponent&gt;&lt;App /&gt;&lt;/AsyncComponent&gt;,
container
</code></pre>

<p>);</p>

<p>// or</p>

<p>class App extends AsyncComponent {
}
```</p>

<h3>ReactDOM.flushSync</h3>

<p><code>ReactDOM.flushSync</code>で囲んだ中での更新処理は、同期(Sync)のPriorityとして扱われます。
v16ではデフォルトが同期のPriorityなので、効果ありませんが、上記のunstableなAPIの中で同期的な更新を行いたい場合に、使用します。</p>

<p>```js
ReactDOM.flushSync(() => {</p>

<pre><code>this.setState(() =&gt; newState);
</code></pre>

<p>});
```</p>

<p>あとは、今後の非同期renderingに備えて、既存のStateの値を元に更新処理を行う場合は、第1引数に関数を渡す方法でのsetState呼び出しをするようにしておいた方がいいと思います。</p>

<p><code>js
this.setState(newState)
// ↓↓↓
this.setState(prevState =&gt; newState);
</code></p>

<p>React Fiberでは、柔軟なスケジューリングを可能にすることで、UIのレスポンス性を向上させることが目的です。</p>

<h2>Custom Renderer</h2>

<p>Custom Rendererを実装するためのパッケージはv16には間に合いませんでしたが、下記のPRで作業中なので、気になる人はwatchしておくといいと思います。</p>

<ul>
<li><a href="https://github.com/facebook/react/pull/10758">https://github.com/facebook/react/pull/10758</a></li>
</ul>


<h2>Test Renderer</h2>

<p>主にsnapshot testingなどで使われていたTest Rendererに便利なAPIが追加されて使いやすくなりました。
Shallow Rendereは指定したComponentだけがrenderされますが、Test Rendererはツリー全体をrenderします。</p>

<p>下記のようにfind〜やfindAll〜のAPIが追加されており、インスタンスにもアクセスできるため、setStateを呼び出したりもできます。
また、Test RendererはReact Fiberに対するRendererとして実装されているため、React Fiberが提供する機能を利用できます。</p>

<p>```js
import React from &lsquo;react&rsquo;;
import TestRenderer from &lsquo;react-test-renderer&rsquo;;</p>

<p>const Child = props => <div>{props.children}</div>;
const Counter = props => <div>{props.count}</div>;</p>

<p>class App extends React.Component {
  constructor(props) {</p>

<pre><code>super(props);
this.state = {
  count: 0
};
</code></pre>

<p>  }
  render() {</p>

<pre><code>return (
  &lt;section&gt;
    &lt;div&gt;bar&lt;/div&gt;
    &lt;Child&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/Child&gt;
    &lt;div&gt;bar&lt;/div&gt;
    &lt;button onClick={() =&gt; this.setState({count: this.state.count + 1})}&gt;
      ++
    &lt;/button&gt;
    &lt;Counter count={this.state.count} /&gt;
  &lt;/section&gt;
);
</code></pre>

<p>  }
}</p>

<p>const root = TestRenderer.create(<App />).root;</p>

<p>// find a component by Type
console.assert(root.find(node => node.type === Child).props.children.type === &lsquo;p&rsquo;);
// find a component by Props
console.assert(root.findByProps({children: &lsquo;Hello&rsquo;}).type === &lsquo;p&rsquo;);</p>

<p>// find all components by Type
console.assert(root.findAllByType(&lsquo;div&rsquo;).length === 4);</p>

<p>// initial state
const instance = root.instance;
console.assert(root.findByType(Counter).props.count === 0);
console.assert(instance.state.count === 0);</p>

<p>// click the button
const button = root.findByType(&lsquo;button&rsquo;).props.onClick();
console.assert(root.findByType(Counter).props.count === 1);
console.assert(instance.state.count === 1);</p>

<p>// setState directly
instance.setState({count: instance.state.count + 1});
console.assert(root.findByType(Counter).props.count === 2);
console.assert(instance.state.count === 2);
```</p>

<p>後、DOMComponentのrefに対するMockの挙動を定義することもできます。</p>

<p>Test Rendererのドキュメントを書いてみたので、そちらも参照してみてください。</p>

<ul>
<li><a href="https://facebook.github.io/react/docs/test-renderer.html">https://facebook.github.io/react/docs/test-renderer.html</a></li>
</ul>


<p>英語ですがブログも書いたのでそっちも。</p>

<ul>
<li><a href="https://medium.com/@koba04/testing-react-components-with-react-test-renderer-b4df590d0320">https://medium.com/@koba04/testing-react-components-with-react-test-renderer-b4df590d0320</a></li>
</ul>


<h2>Enzyme</h2>

<p><code>enzyme</code>も同じタイミングでv3がリリースされました。
v3からはAdapterのアーキテクチャになっており、対象とするReactのバージョンに応じたAdapterをインストールして設定します。</p>

<p>```js
import Enzyme from &lsquo;enzyme&rsquo;;
import Adapter from &lsquo;enzyme-adapter-react-16&rsquo;;</p>

<p>Enzyme.configure({ adapter: new Adapter() });
```</p>

<p>上記をNodeやMochaの<code>--require</code>オプションに設定したり、Jestの<code>setupFiles</code>に定義すれば毎回書く必要はありません。</p>

<p>これにより、今後はpreactのアプリケーションもサポートできるようになるかもしれません。</p>

<ul>
<li><a href="https://github.com/aweary/preact-enzyme-adapater">https://github.com/aweary/preact-enzyme-adapater</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Fiber現状確認]]></title>
    <link href="http://blog.koba04.com/post/2017/04/25/a-state-of-react-fiber/"/>
    <updated>2017-04-25T02:00:55+09:00</updated>
    <id>http://blog.koba04.com/post/2017/04/25/a-state-of-react-fiber</id>
    <content type="html"><![CDATA[<p><a href="https://developers.facebook.com/videos/?category=f8_2017">F8</a>でもReact Fiberについての発表もあったので、気になっている人も多いReact Fiberの現状について簡単に書きたいと思います。</p>

<p>Reactの完全な書き換えということで、使い方も変わってしまうと思っている人もいると思いますが、内部実装の書き換えであり、利用者から見える部分ではほとんど変更はありません。</p>

<p>もちろん、react-fiberというパッケージをインストールするというわけでもありません。</p>

<p>むしろ、<code>v16</code>の時点では現在の実装と互換性を保たれているので、<code>v16</code>がリリースされた時に、<code>v15.5</code>を使っていればほとんどそのまま<code>v16</code>に更新できると思います。
そして、言われなければ内部実装が変わっていることに気づかないのではないかと思います。</p>

<h2>とりあえずどうなるのか知りたい人向けのまとめ</h2>

<ul>
<li>v16では、基本的にはv15の時と同じように動作します。逆に言うとパフォーマンスもそんなに変わらない（はず）です</li>
<li>renderメソッドから<code>[&lt;Foo /&gt;, &lt;Bar /&gt;]</code> みたいに配列で返したり、文字列をReactElementでラップすることなく返せるようになります</li>
<li>v17では、デフォルトで非同期のrendering（後述）になります。v16でも何らかのAPIでopt-inで試せるようにはなりそうです。現状は<code>ReactDOM.unstable_deferredUpdates</code>で一部試すことができます</li>
<li>v17では、劇的に高速になるというよりは、ユーザーの入力をブロックしないようにしたり、柔軟に更新処理をスケジューリング出来るようになる予定です</li>
</ul>


<h2>注意点</h2>

<p><strong>以下の情報は、Reactをただ使いたい人にとっては知る必要のない内部実装の話です。多くの人にとってはここまでの情報でReact FiberについてはOKだと思います。v17になるまでは。</strong></p>

<!-- more -->


<h2>Reactの構成</h2>

<p>新しいFiberについて説明するために、まずは現状の実装について確認しましょう。
Reactのソースコードは下記のような構成になっています。</p>

<p>```</p>

<pre><code>src
├── fb
├── isomorphic
│   ├── children
│   ├── classic
│   │   ├── class
│   │   ├── element
│   │   └── types
│   ├── hooks
│   └── modern
│       ├── class
│       └── element
├── renderers
│   ├── art
│   ├── dom
│   │   ├── fiber
│   │   ├── shared
│   │   └── stack
│   ├── native
│   ├── noop
│   ├── shared
│   │   ├── fiber
│   │   ├── hooks
│   │   ├── shared
│   │   ├── stack
│   │   └── utils
│   └── testing
│       └── stack
├── shared
│   ├── types
│   └── utils
└── test
(テストなどの一部ディレクトリは省略)
</code></pre>

<p>```</p>

<p>上記の通り、Fiberは<code>renderers</code> の中にありrendererの1つであることがわかります。<code>fiber</code> と同列にある<code>stack</code> は現在の実装のrendererです。</p>

<p><code>renderes/shared/</code> に<code>fiber</code> と<code>stack</code> のディレクトリがあって、<code>renderers/dom/</code> にも<code>stack</code> と<code>fiber</code> があります。rendererの中にはStackとFiberの2種類の実装があり、それぞれに対応するDOMやNativeなどの環境毎のrendererがさらにあるような構成になっています。</p>

<p>FiberやStackは、reconciliationと呼ばれる部分の役割を担っています。
reconciliationとは、ReactElementからComponentのインスタンスを生成したり差分を計算してHost(DOM)に反映したり、ライフサイクルメソッドの呼び出しといったことを行う部分です。
Hostに反映させる部分はHostが何かによっても異なり、反映方法もreconciliationによって異なるため、<code>renderers/dom/</code> 以下にもStackとFiberが存在します。</p>

<p>Hostとは各環境のことです。ブラウザー環境であればDOMであり、ReactNativeであればネイティブのビューとなります。</p>

<h2>Stack</h2>

<p>それでは、まずは現在使われているStackのrendererについて簡単に触れます。
Stackは、ReactElementがツリー構造になるのと同様に、親から子、子から孫に処理を行っていきます。</p>

<p><img src="/images/posts/a-state-of-react-fiber/ReactDOM.png" title="&lsquo;ReactDOM Stack&rsquo;" ></p>

<p>上記では、<code>mountComponent</code> がどんどん入れ子になって呼ばれているのがわかります。
加えてこれは同期的に行われます。</p>

<p>つまり、トップレベルのComponentから再renderした場合、</p>

<ul>
<li>子孫の全てのComponentに対するrender処理を行いReactElementのツリーを構築する</li>
<li>更新の場合は、前のReactElementツリーと比較を行う</li>
<li>差分をHostに適用する</li>
<li>ライフサイクルメソッドの呼び出しなどを行う</li>
</ul>


<p>という処理が同期的に処理されます。
そのため、例えば複雑なツリー構造を持っていて上記の処理に時間がかかる場合、UIを完全にブロックしてしまいます。</p>

<p>また、例えばアニメーションやユーザーのタイピングなど、即時に反映する必要のある処理を行っている時にサーバーから結果が返ってきた時を考えてみます。
Stackは全てが同期的に処理されるため、サーバーからの結果の反映処理が、アニメーションやタイピングの反映に割り込んでブロックしてしまうことも起きます。</p>

<p>これらは、単純なパフォーマンスのベンチマークでは現れない指標ですが、ユーザー体験という意味では重要です。</p>

<p>これらの問題を解決するためのものとしてReact Fiberはあります。</p>

<p>ちなみにStackに関連するソースは、v16のリリース時には削除されそうな感じではあります。</p>

<h2>Fiber</h2>

<p>Fiberは、wikipediaによると「軽量な実行スレッド」とされています。</p>

<p><a href="https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A1%E3%82%A4%E3%83%90%E3%83%BC_">https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A1%E3%82%A4%E3%83%90%E3%83%BC_</a>(%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF)</p>

<p>React Fiberでは、Fiberの単位でreconciliationが行われます。
Fiberは、基本的には1つのReactElementと対応すると考えることができます。</p>

<p>厳密にはReactElementの単位とFiberが必ずしも一致するわけでありません。
さらにFiberは、<code>fiber.alternate</code> として自身をcloneしたFiberを持っており再利用されています。
ただ、考える上ではFiberをReactElementの単位でイメージするとわかりやすいと思います。</p>

<p>FiberはFlowの型で下記のように指定されています。</p>

<p>```js</p>

<pre><code>// 一部省略
type Fiber = {
  tag: TypeOfWork,
  key: null | string,
  type: any,
  stateNode: any,
  return: Fiber | null,
  child: Fiber | null,
  sibling: Fiber | null,
  index: number,
  ref: null | (((handle: mixed) =&gt; void) &amp; {_stringRef: ?string}),
  pendingProps: any, // This type will be more specific once we overload the tag.
  memoizedProps: any, // The props used to create the output.
  updateQueue: UpdateQueue | null,
  memoizedState: any,
  effectTag: TypeOfSideEffect,
  nextEffect: Fiber | null,
  firstEffect: Fiber | null,
  lastEffect: Fiber | null,
  pendingWorkPriority: PriorityLevel,
  progressedPriority: PriorityLevel,
  progressedChild: Fiber | null,
  progressedFirstDeletion: Fiber | null,
  progressedLastDeletion: Fiber | null,
  alternate: Fiber | null,
};
</code></pre>

<p>```</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactFiber.js">https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactFiber.js</a></li>
</ul>


<p>各プロパティについては解説しませんが、<code>return</code> や<code>child</code> や<code>sibling</code> など、他のFiberへの参照を持っていることがわかります。
FiberはLinked Listの構造になっています。Stackの場合はTree構造を掘り下げていくように処理をしていましたが、Fiberでは、<code>return</code> や<code>child</code> や<code>sibling</code> などをたどることで順番にReactElementを処理していきます。
そのことは、下記のスタックツリーを見てもわかります。</p>

<p><img src="/images/posts/a-state-of-react-fiber/ReactDOMFiber.png" title="&lsquo;ReactDOM Fiber&rsquo;" ></p>

<p>上記の通り、Stackのようにスタックがたくさん積まれていないことがわかります。</p>

<p>Stackでは処理が1つのツリーを単位として行われていましたが、FiberではFiberの単位で処理されます。Stackでは処理を同期的に行うしかできませんでしたが、FiberではこのFiberに対する処理をスケジューリングすることができます。</p>

<p>つまり、A → B → C とLinkedListを構成しているFiberがあった時に、A → B まで処理して中断し、またB → Cから処理を再開できます。
これはStackのような構造では難しいことです。
Generatorsだとどうでしょうか？それに対しては、<a href="https://github.com/sebmarkbage">Sebastian Markbåge</a>が下記でGeneratorsを採用しなかった理由を書いているので興味のある人は見て見るといいと思います。</p>

<ul>
<li><a href="https://github.com/facebook/react/issues/7942">https://github.com/facebook/react/issues/7942</a></li>
</ul>


<h3>Fiberのスケジューリング</h3>

<p>では、具体的にどのようにスケジューリングが行われるのかを見ていきます。</p>

<p>Fiberは、<code>beginWork</code> と<code>completeWork</code> と<code>commitWork</code> という3つのフェーズがあります。
beginWorkはcomponentのインスタンス化やrenderメソッドの呼び出し、shouldComponentUpdateなどによる比較を行います。</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactFiberBeginWork.js">https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactFiberBeginWork.js</a></li>
</ul>


<p>completeWorkは副作用を示すeffectTagを設定したり、Hostインスタンスを作成したりなどを行います。（末端のHostなどでのみ実行される）</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactFiberCompleteWork.js">https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactFiberCompleteWork.js</a></li>
</ul>


<p>副作用は下記のように定義されています。</p>

<p>```js</p>

<pre><code>module.exports = {
  NoEffect: 0, //           0b0000000
  Placement: 1, //          0b0000001
  Update: 2, //             0b0000010
  PlacementAndUpdate: 3, // 0b0000011
  Deletion: 4, //           0b0000100
  ContentReset: 8, //       0b0001000
  Callback: 16, //          0b0010000
  Err: 32, //               0b0100000
  Ref: 64, //               0b1000000
};
</code></pre>

<p>```</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactTypeOfSideEffect.js">https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactTypeOfSideEffect.js</a></li>
</ul>


<p>commitWorkでは、componentDid(Mount|Update)などのライフサイクルメソッドの呼び出しや、completeWorkで設定されたeffectTagに基づいてHostに結果を反映します。</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactFiberCommitWork.js">https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactFiberCommitWork.js</a></li>
</ul>


<p>この中で、beginWorkとcompleteWorkはFiber単位で実行されます。
commitWorkは、全てのFiberに対する処理が終わった後にまとめて実行されます。</p>

<p>例えば、下記のような構成のComponentがある場合、</p>

<p>```js</p>

<pre><code>Text = () =&gt; '...';
List = () =&gt; [
  &lt;div&gt;...&lt;/div&gt;,
  &lt;div&gt;...&lt;/div&gt;,
  &lt;div&gt;...&lt;/div&gt;,
];

class App extends React.Component {
    render() {
        return (
            &lt;main&gt;
            &lt;h2&gt;...&lt;/h2&gt;
            &lt;p&gt;...&lt;/p&gt;
            &lt;div&gt;
                &lt;Text /&gt;
                &lt;List /&gt;
            &lt;/div&gt;
            &lt;/main&gt;
        );
    }
}
</code></pre>

<p>```</p>

<p>下記のような流れで処理されます。</p>

<ol>
<li><strong>beginWork</strong> … (HostRoot)</li>
<li><strong>beginWork …</strong>  <code>&lt;App&gt;</code> (ClassComponent)</li>
<li><strong>beginWork</strong> …  <code>&lt;main&gt;</code> (HostComponent)</li>
<li><strong>beginWork, completeWork …</strong>  <code>&lt;h2&gt;</code> (HostComponent)</li>
<li><strong>beginWork, completeWork …</strong> <code>&lt;p&gt;</code> (HostComponent)</li>
<li><strong>beginWork …</strong> <code>&lt;div&gt;</code> (HostComponent)</li>
<li><strong>beginWork …</strong> <code>&lt;Text&gt;</code> (FunctionalComponent)</li>
<li><strong>beginWork completeWork …</strong> &lsquo;&hellip;&rsquo; (HostText)</li>
<li><strong>beginWork …</strong> <code>&lt;List&gt;</code> (Functional Component)</li>
<li><strong>beginWork, completeWork …</strong> : <code>&lt;div&gt;</code> (HostComponent)</li>
<li><strong>beginWork, completeWork …</strong> : <code>&lt;div&gt;</code> (HostComponent)</li>
<li><strong>beginWork, completeWork …</strong> : <code>&lt;div&gt;</code> (HostComponent)</li>
<li><strong>commitAllWork …</strong> (HostRoot)</li>
</ol>


<p>React Fiberは、非同期renderingの場合には、後述する優先度が高くないものについてはrequestIdleCallback（サポートしてなければpolyfill実装）を使い、これらをスケジューリングして非同期に処理していきます。
requestIdleCallbackでは、アイドル時間を<code>timeRemaining</code>の関数から受け取ることができるため、この値を元に処理できる時間がなくなると再び<code>requestIdleCallback</code> に処理を登録して次のアイドル時間に処理するようになっています。
これにより、優先度が高くない処理がUIや他の処理をブロックしないようになっています。</p>

<ul>
<li><a href="https://developer.mozilla.org/ja/docs/Web/API/Window/requestIdleCallback">https://developer.mozilla.org/ja/docs/Web/API/Window/requestIdleCallback</a></li>
</ul>


<p>下記はFiberを同期モードで実行した時のスタックです。
全てが同期的に行われていることがわかります。この間はUIを完全にブロックしてしまいます。</p>

<p><img src="/images/posts/a-state-of-react-fiber/ReactDOMFiber-sync.png" title="&lsquo;ReactDOM Fiber Sync&rsquo;" ></p>

<p>下記は同じ処理を非同期で実行したスタックです。
スタックが途切れ途切れになっていることがわかります。そのためUIをブロックしません。
右端にある細いスタックはcommitWorkによるものです。
Renderingの処理はcommitWorkの以降でだけ発生していることがわかります。</p>

<p><img src="/images/posts/a-state-of-react-fiber/ReactDOMFiber-async.png" title="&lsquo;ReactDOM Fiber Async&rsquo;" ></p>

<p>このとき、HostのViewに反映するといった副作用をこのbeginWork〜completeWorkの中で行わないというのは1つのポイントです。
例えば、Viewへの反映をこの非同期処理の中で行ってしまうと、Viewが部分部分更新される形になり、UIがガタガタしてしまいます。
React Fiberでは、commitWorkで全てのViewへの更新をまとめて行うため、このようなことは起こりません。
逆にcommitWorkの部分は時間がかかりやすくframeを落としてしまうこともあるためパフォーマンスチューニングが注意深く行われています。
componentDid(Mount|Update)もこの中で行われるため、この中で重い処理を行わないように注意が必要です。</p>

<p>余談ですが、上記のようにライフサイクルメソッドがボトルネックになる場面が想定されるため、ライフサイクルメソッドをPromiseを返す非同期なAPIとする案もあります。
あと、実はマウント時はcompleteWorkでもSideEffectが処理されています。これはマウント時にはまだHostContainerはDOMに追加されていないため追加しても表示されず問題ないためです。
これもcommitWorkでframeを落とさないための工夫の1つです。</p>

<p>また、上記のようなrequestIdleCallbackを使ったスケジュール以外にも、優先度に応じたスケジューリングも可能です。
優先度は下記のように定義されています。</p>

<p>```js</p>

<pre><code>export type PriorityLevel = 0 | 1 | 2 | 3 | 4 | 5 | 6;

module.exports = {
  NoWork: 0, // No work is pending.
  SynchronousPriority: 1, // For controlled text inputs. Synchronous side-effects.
  TaskPriority: 2, // Completes at the end of the current tick.
  AnimationPriority: 3, // Needs to complete before the next frame.
  HighPriority: 4, // Interaction that needs to complete pretty soon to feel responsive.
  LowPriority: 5, // Data fetching, or result from updating stores.
  OffscreenPriority: 6, // Won't be visible but do the work in case it becomes visible.
};
</code></pre>

<p>```</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactPriorityLevel.js">https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactPriorityLevel.js</a></li>
</ul>


<p>更新処理に優先度を持たせることで、ユーザーインタラクションやアニメーションなどの更新処理を、APIレスポンスの反映など、優先度の低いタスクが邪魔しないようにすることができます。</p>

<p>下記はそれを表したサンプルです。「Async mode」の場合、5000個のlist itemは100ms毎に<code>LowPriority</code>で更新されます。「Sync mode」の場合は<code>SynchronousPriority</code>として同期的にレンダリングされます。</p>

<ul>
<li><a href="https://koba04.github.io/react-fiber-resources/examples/">https://koba04.github.io/react-fiber-resources/examples/</a></li>
</ul>


<p>上にある入力フィールドに何か入力してください。「Async mode」の場合は入力中はlist itemが更新されず、入力も多少引っかかりますがスムーズに反映されます。「Sync mode」の場合は入力中もlist itemが更新されてユーザーの入力を邪魔してしまっています。</p>

<p>優先度の低い処理はrequestIdleCallbackを使ってアイドル時間がある時に、優先度の高い処理はrequestAnimationFrameを使うか同期的にASAPで反映されます。</p>

<p>優先度の低いタスクを実行中に、優先度の高いタスクが割り込んで来た場合、優先度の低いタスクは中断されて、優先度の高いタスクが先に行われます。
優先度の高いタスクが終了後、再び優先度の低いタスクが実行されます。
この際、割り込まれる前に優先度の低いタスクが実行していたFiberのうち、優先度の高いタスクが処理しなかったものは再利用されます。</p>

<p>このように、タスクの割り込みによっては複数回Fiberが処理されることがあるため、非同期のレンダリングの場合には、componentWillMountなどのライフサイクルメソッドが複数回呼び出されることがあります。componentDidMountなどはcommitWorkで呼ばれるため複数回呼ばれることはありません。</p>

<p>また、OffscreenPriorityというPriorityがあります。これを利用することで初回のレンダリングでは必要ない部分をプリレンダリングしたり、ダブルバッファリングが可能となります。ReactDOMでは、<code>hidden</code>属性のあるものはOffscreenPriorityとして扱われます。</p>

<p>他にもAnimationPriorityなどのPriorityがありますが、現時点ではまだPriorityを制御するようなAPIはないため、どのように利用するのかは見えていません。（facebook.comでの非同期レンダリングの実験をやりながらAPIを決めていくらしい）</p>

<p>その他の細かい挙動については、<code>ReactIncremental-test.js</code>のテストを見るとどんなことができるのかわかるかと思います。</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/__tests__/ReactIncremental-test.js">https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/__tests__/ReactIncremental-test.js</a></li>
</ul>


<p>ここで使われている<code>ReactNoop</code> というrendererはテスト用のrendererです。UIは全く持っておらずテスト用に<code>timeRemaining</code> などが柔軟に制御可能であり、React Fiberの開発は初期の頃はこのrendererに対して行われていました。custom rendererを作る際の参考にもいいかもしれません。</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/noop/ReactNoop.js">https://github.com/facebook/react/blob/master/src/renderers/noop/ReactNoop.js</a></li>
</ul>


<h2>Error Boundary</h2>

<p>あと、Fiber自体には直接関係ないですが、Error Boundaryの機能も公式にサポートされるようになりそうです。
Error Boundaryとは、これまでは子孫Componentのrender時にエラーが発生した場合は、何も表示されなくなってしまいましたが、Error Boundaryの機能を使うことで握り潰したりエラーハンドリングができるようになるものです。</p>

<p>```js</p>

<pre><code>class App extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            error: null
        };
    }
    // エラーハンドリングを定義する
    unstable_handleError(error) {
        this.setState({error});
    }
    render() {
        if (this.state.error) {
            return &lt;div&gt;エラーが発生しました&lt;/div&gt;;
        }
        return this.props.children;
    }
}
</code></pre>

<p>```</p>

<h2>CoroutineComponent</h2>

<p>Fiberには<code>CoroutineComponent</code> や<code>CoroutineHandlerPhase</code> や<code>YieldComponent</code>といったComponentもあります。これはどうやら、親のComponentのレンダリングを途中で止めて、子のComponentからの結果を受けて親のComponentのレンダリングを再開するみたいなこともできるっぽいです（あんまりわかってない）。例えばレイアウトを行うComponentで子を実際にレンダリングしてみて、サイズなどの結果を持って親のComponentを再度レンダリングするみたいなことが、ユースケースとしてどこかで説明されていました。</p>

<p>これの動作については、上記であげた<code>ReactCoroutin-test.js</code> の中にあるので見てみるといいかと思います。状態としてはとりあえず動いてるっぽいという感じだとは思います。</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/__tests__/ReactCoroutine-test.js">https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/__tests__/ReactCoroutine-test.js</a></li>
</ul>


<h2>Custom Renderer</h2>

<p>Stackでは、Custom Rendererを作成するためにはハックが必要でしたが、React FiberではFlowによって型付けされているため、わかりやすくなりました。</p>

<p>```js</p>

<pre><code>export type HostConfig&lt;T, P, I, TI, PI, C, CX, PL&gt; = {
  getRootHostContext(rootContainerInstance: C): CX,
  getChildHostContext(parentHostContext: CX, type: T): CX,
  getPublicInstance(instance: I | TI): PI,

  createInstance(
    type: T,
    props: P,
    rootContainerInstance: C,
    hostContext: CX,
    internalInstanceHandle: OpaqueHandle,
  ): I,
  appendInitialChild(parentInstance: I, child: I | TI): void,
  finalizeInitialChildren(
    parentInstance: I,
    type: T,
    props: P,
    rootContainerInstance: C,
  ): boolean,

  prepareUpdate(
    instance: I,
    type: T,
    oldProps: P,
    newProps: P,
    rootContainerInstance: C,
    hostContext: CX,
  ): null | PL,
  commitUpdate(
    instance: I,
    updatePayload: PL,
    type: T,
    oldProps: P,
    newProps: P,
    internalInstanceHandle: OpaqueHandle,
  ): void,
  commitMount(
    instance: I,
    type: T,
    newProps: P,
    internalInstanceHandle: OpaqueHandle,
  ): void,

  shouldSetTextContent(props: P): boolean,
  resetTextContent(instance: I): void,
  shouldDeprioritizeSubtree(type: T, props: P): boolean,

  createTextInstance(
    text: string,
    rootContainerInstance: C,
    hostContext: CX,
    internalInstanceHandle: OpaqueHandle,
  ): TI,
  commitTextUpdate(textInstance: TI, oldText: string, newText: string): void,

  appendChild(parentInstance: I | C, child: I | TI): void,
  insertBefore(parentInstance: I | C, child: I | TI, beforeChild: I | TI): void,
  removeChild(parentInstance: I | C, child: I | TI): void,

  scheduleAnimationCallback(callback: () =&gt; void): number | void,
  scheduleDeferredCallback(
    callback: (deadline: Deadline) =&gt; void,
  ): number | void,

  prepareForCommit(): void,
  resetAfterCommit(): void,

  useSyncScheduling?: boolean,
};
</code></pre>

<p>```</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactFiberReconciler.js">https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactFiberReconciler.js</a></li>
</ul>


<p>実際に実装する際には、先ほど紹介した<code>ReactNoop</code> や、Test用のrendererでありReactElementからJSONを返す<code>ReactTestRenderer</code> や<code>ReactART</code> などが参考になると思います。</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/testing/ReactTestRendererFiber.js">https://github.com/facebook/react/blob/master/src/renderers/testing/ReactTestRendererFiber.js</a></li>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/art/ReactARTFiber.js">https://github.com/facebook/react/blob/master/src/renderers/art/ReactARTFiber.js</a></li>
</ul>


<p>ただ、Reactはv16からFlat bundleになり、内部ライブラリーを<code>react/lib/xxx</code>のように利用出来なくなったので、Custom Renderer作る人向けに何かが提供されるのかは不明なところです。</p>

<h2>Server Side Rendering</h2>

<p>サーバーサイドレンダリングについては、Facebookで使っていないということもあり後回しになっていて、まだ実装されていません。
ただ、今までの<code>renderToString</code> は完全に同期でしたが、ReactFiberになることでイベントループをブロックしないようにHTML文字列を生成することは簡単になりそうです（v16には入るかどうかは不明）。<code>renderToStream</code> みたいなのは、副作用はcommitWorkでまとめてやるというところからは外れてしまうのでどうなんでしょうね。</p>

<h2>v16でも非同期レンダリングを試したい</h2>

<ul>
<li>現時点では、<code>ReactDOMFeatureFlags</code> に<code>fiberAsyncScheduling</code> というフラグがあるので、それを無理やり<code>true</code> に書き換えることでデフォルトで非同期のレンダリングに出来ます。ただまだそんなにテストされていないと思うのでバグなどはありそうです</li>
<li>または、<code>ReactDOM.unstable_deferredUpdates</code> を使うとその中の更新処理は<code>lowPriority</code> として処理されるため、非同期となります</li>
</ul>


<h2>その他リソース</h2>

<p>Fiberで何が嬉しいのかを知りたい人は、F8のTom OcchinoのTalkがとてもわかりやすいと思います。</p>

<ul>
<li>The Evolution of React and GraphQL at Facebook and Beyond

<ul>
<li><a href="https://developers.facebook.com/videos/f8-2017/the-evolution-of-react-and-graphql-at-facebook-and-beyond/">https://developers.facebook.com/videos/f8-2017/the-evolution-of-react-and-graphql-at-facebook-and-beyond/</a></li>
</ul>
</li>
</ul>


<p>Lin ClarkがReact ConfでCode Cartoonを使ってReact Fiberについて説明していたのもわかりと思います。</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/ZCuYPiUIONs?ecver=1" frameborder="0" allowfullscreen></iframe>


<p>あとはSebastian MarkbågeのReact ConfのキーノートでもReact Fiberについて触れられています。</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/bvFpe5j9-zQ?ecver=1" frameborder="0" allowfullscreen></iframe>


<p>あとは、個人的にReact Fiberについてまとめたリポジトリもあります。</p>

<ul>
<li><a href="https://github.com/koba04/react-fiber-resources">https://github.com/koba04/react-fiber-resources</a></li>
</ul>


<h2>で結局何が嬉しいの？</h2>

<p>React Fiberに変わることで、よくフレームワークのパフォーマンス比較にあるようなベンチマークのスコアがよくなるといったことはおそらくないと思います。
React Fiberになることで、これまで同期的にツリーを処理していくしかなかったものが非同期に、より柔軟に処理出来るようになるのがメリットです。
これにより、アニメーションやユーザーのインタラクションに対して可能な限り早く反応出来るように出来ます。また、このような基盤としてReact Fiberがあるので、今後そういった機能追加が行われていくのではないかと思います。</p>

<p>というで、v16ではそんなに変わりませんが、今後の機能追加を楽しみにしましょう。
また、React Fiberの実装も勉強になるので興味のある人は是非読んでみてください。</p>

<p>ちなみにReact Fiberの最初のPRはこれのようですね。</p>

<ul>
<li><a href="https://github.com/facebook/react/pull/6690">https://github.com/facebook/react/pull/6690</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React v15.5(6) and v16]]></title>
    <link href="http://blog.koba04.com/post/2017/04/14/react-dot-js-v155-and-v16/"/>
    <updated>2017-04-14T14:00:05+09:00</updated>
    <id>http://blog.koba04.com/post/2017/04/14/react-dot-js-v155-and-v16</id>
    <content type="html"><![CDATA[<p>Reactのv15.5がリリースされたので、v15.5での変更点とv16についてのまとめです。</p>

<ul>
<li><a href="https://facebook.github.io/react/blog/2017/04/07/react-v15.5.0.html">https://facebook.github.io/react/blog/2017/04/07/react-v15.5.0.html</a></li>
</ul>


<p>v15.5はバグフィックスとv16での変更点に対する準備なので、可能ならあげておいた方がスムーズにv16がリリースされた時に対応できると思います。</p>

<p>基本的には、v16で色々と廃止するための警告が主になります。
最近のバージョンと同様に、コアから必要なもの以外をどんどん削ぎ落としていく流れです。</p>

<p>この警告に対応するために、Enzymeなどでは利用するために必要なライブラリーが変更されているので更新する際には注意が必要です。</p>

<p>また、当初の予定ではv15.5がv15系の最後のリリースになる予定でしたが、上記のような混乱もあったためフォローアップとしてv15.6もリリースされることになりました。
なので、v15.6がリリースされてから対応するのもアリだと思います。</p>

<p>廃止されるものは色々ありますが、基本的に全てのものに対してマイグレーションのパスは提供されているので対応可能だと思います。
ただ、アクティブにメンテされていないくて15.5対応版をリリースしていないライブラリーを使っていると色々警告が出ると思います。
場合によっては、その警告によってテストが壊れることがあるかもしれません。</p>

<!-- more -->


<h2>Deprecated React.createClass</h2>

<p>廃止されること自体は前から言われていたので、使わないようにしていた人も多いと思いますが、<code>create-react-class</code>として別パッケージとなり、v16では<code>react</code>から削除されます。</p>

<p><code>js
import createReactClass from 'create-react-class';
</code></p>

<p>そのためv15.5では、<code>React.createClass</code>を使おうとすると警告が出ます。</p>

<p>自分の書いたコードで<code>React.createClass</code>を使っている場合は、<code>React.Component</code>を使ったComponent定義かStateless Functional Componentsに書き換える必要があります。</p>

<p>mixinを使っているなど、どうしても<code>React.createClass</code>を使いたい場合は<code>create-react-class</code>を使うこともできますが、可能な限りReact本体が提供する方法を利用する方がいいと思います。</p>

<p><code>React.createClass</code>から<code>React.Component</code>の定義に書き換えるcodemodも提供されているので、使ってみるのもいいかもしれません。</p>

<ul>
<li><a href="https://github.com/reactjs/react-codemod">https://github.com/reactjs/react-codemod</a></li>
</ul>


<p>このcodemodでは、<code>React.createClass</code>が提供するautobindを実現するために、property initializerのシンタックスを利用します。そのため、変換後は<code>babel-plugin-transform-class-properties</code>を使用する必要があります。(Stage 2)</p>

<ul>
<li><a href="http://babeljs.io/docs/plugins/transform-class-properties/">http://babeljs.io/docs/plugins/transform-class-properties/</a></li>
</ul>


<p>v16になった時点で<code>React.createClass</code>を使っているライブラリーを利用している場合には、PR送って対応してもらうか、<code>React.createClass</code>に<code>create-react-class</code>を代入するなどの対応が必要になるかもしれません。
(v15.5では、警告を出すために<code>React.createClass</code>には<code>Object.defineProperty</code>でgetterが設定されており、<code>configurable</code>でないので置き換えることはできません)</p>

<h2>Deprecated React.PropTypes</h2>

<p>これも、<code>React.createClass</code>と同様にずっと言われていましたが、<code>prop-types</code>として別パッケージとなり、v16では<code>react</code>から削除されます。</p>

<p><code>js
import PropTypes from 'prop-types';
</code></p>

<p>そのためv15.5では、<code>React.PropTypes</code>を使おうとすると警告が出るようになりました。</p>

<p>これもcodemodが提供されているので、それを使って一括で変換することができます。</p>

<ul>
<li><a href="https://github.com/reactjs/react-codemod#react-proptypes-to-prop-types">https://github.com/reactjs/react-codemod#react-proptypes-to-prop-types</a></li>
</ul>


<p>PropTypesに関しては、FlowやTypeScriptへの移行が勧められているもののハードルもあるので、別パッケージ化された<code>prop-types</code>をしばらく使い続けるのは選択肢としてあるのかなと思います。
今回別パッケージとなったのは組み込みのPropTypesのvalidationロジックであり、PropTypesのチェック機構自体がなくなることは、まだ予定されていないので。</p>

<p>ちなみに、将来的にAPIの変更が予定されているContextを使う場合にも、変わらず<code>prop-types</code>を使って指定します。
（実際には<code>contextTypes</code>の定義でマスクしているだけなので、<code>prop-types</code>を使う必要はないのですが）</p>

<h2>Deprecated Addons</h2>

<p>React本体がアドオンとして提供していた諸々が、廃止されたり別パッケージ化したり、移動したりしています。
v16では、<code>react-with-addons</code>のUMDビルドも提供されなくなります。</p>

<ul>
<li><code>react-addons-create-fragment</code>は、v16のFiber化により配列を返すことができるようになるため、多くの場面で不要となるので削除されます。</li>
<li><code>react-addons-css-transition-group</code>と<code>react-addons-transition-group</code>は、<code>react-transition-group</code>の別パッケージになりました。<code>CSSTransitionGroup</code>と<code>TransitionGroup</code>して利用できます。ただし、全く実装が一緒というわけではないので移行する際には注意が必要です。すでに修正済みですが下記のようなバグとかもあったりするので&hellip;。

<ul>
<li><a href="https://github.com/reactjs/react-transition-group">https://github.com/reactjs/react-transition-group</a></li>
<li><a href="https://github.com/reactjs/react-transition-group/pull/13">https://github.com/reactjs/react-transition-group/pull/13</a></li>
</ul>
</li>
<li><code>react-addons-linked-state-mixin</code>と<code>react-linked-input</code>は、明示的に<code>value</code>と<code>onChange</code>を指定すればいいので削除されます。</li>
<li><code>react-addons-pure-render-mixin</code>と<code>react-addons-shallow-compare</code>は、<code>React.PureComponent</code>を代わりに利用できます。</li>
<li><code>react-addons-update</code>は<code>immutability-helper</code>が代わりに利用できます。

<ul>
<li><a href="https://github.com/kolodny/immutability-helper">https://github.com/kolodny/immutability-helper</a></li>
</ul>
</li>
</ul>


<p><code>react-addons-test-utils</code>は、<code>react-dom</code>のrendererに依存している部分が多いため、<code>react-dom/test-utils</code>に移動されました。</p>

<p><code>js
import TestUtils from 'react-dom/test-utils';
</code></p>

<p>ShallowRenderに関しては<code>react-dom</code>に依存していないため、<code>react-test-renderer/shallow</code>に移動されました。
ちなみに<code>react-test-renderer</code>はJestがsnapshot testingで使っていたりする、ReactElementをJSONとして返すrendererです。
ShallowRenderは、これのトップレベルのComponentまでしかrenderしない版として考えることができます。</p>

<p><code>js
import {createRenderer} from 'react-test-renderer/shallow';
</code></p>

<p><del><code>react-addons-perf</code>だけは、特に何もなくこのままですが、<code>react-addons-perf</code>は同期的なrenderが前提となっているため、将来的にFiberで非同期的なrenderをする場合には正しく計測できません。</del></p>

<p><strong>[修正]</strong> <code>react-addons-perf</code>は同期的なrenderが前提となっていてFiberへの対応が難しいため、v16(Fiber)への対応は行われません。
Perfに変わる何かについては検討されるので、将来的に何か提供される可能性もありますが、とりあえずは<code>?react_perf</code>によるBrowser Timelineを使った計測が推奨されています。</p>

<ul>
<li><a href="https://facebook.github.io/react/docs/optimizing-performance.html#profiling-components-with-chrome-timeline">https://facebook.github.io/react/docs/optimizing-performance.html#profiling-components-with-chrome-timeline</a></li>
</ul>


<h2>15.6（予定）</h2>

<p><a href="https://github.com/facebook/react/issues/9398">https://github.com/facebook/react/issues/9398</a></p>

<ul>
<li><code>React.DOM.{p, div,...}</code>として提供されていたファクトリ関数が廃止となります。</li>
<li>APIの廃止などの警告は、これまでは<code>console.error</code>として出力されていましたが、<code>console.warn</code>で出力されるようになります。</li>
</ul>


<h2>16に向けて</h2>

<p>v16はすでに<code>@next</code>でインストールできます。
そのため、まだ実装されていないサーバーサイドレンダリングとShallowRenderを使っていない部分では試すことが可能です。</p>

<p><code>
npm i react@next react-dom@next
</code></p>

<h3>Fiber</h3>

<p>v16の一番大きな目玉は、Fiberに内部実装が置き換えられることです。
ただし、v16の時点ではFiberは現在のStackのrendererと互換性のあるモードで動作します。
そのため、Fiberの特徴である<code>requestIdleCallback</code>によってスケジューリングされた非同期なrenderではなく、同期的なrenderとなるため、利用者として大きな違いは感じないかもしれません。
（call stack見ると全く変わっていることがわかると思いますが）</p>

<p>文字列や配列をComponentでラップすることなく直接返すことができるのは嬉しい部分かもしれません。</p>

<p><code>js
const Text = ({text}) =&gt; text;
const List = () =&gt; [1, 2, 3];
</code></p>

<p>ちなみに、v16の時点でも<code>ReactDOM.unstable_deferredUpdates</code>を使うことで、非同期なrenderが出来るようにはなりそうです。
あとは、<code>ReactDOMFiber.js</code>にある<code>useSyncScheduling</code>というフラグを無理やり<code>false</code>にすればデフォルトで非同期なrenderになります。（軽く試した感じだと問題なく動いていた）</p>

<p>非同期のrenderをどのようにユーザー側のAPIとして見せるのかは、まだ明らかになっていなくてこれから議論していくようです。</p>

<p>Fiberについては、下記に集めたリソースを読むとわかると思います。（今後紹介的な何かを書くかも）</p>

<ul>
<li><a href="https://github.com/koba04/react-fiber-resources">https://github.com/koba04/react-fiber-resources</a></li>
</ul>


<p>最初に見るものとしてのおすすめは、Lin ClarkによるA Cartoon Intro to Fiber(React.js Conf 2017)です。</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/ZCuYPiUIONs?ecver=1" frameborder="0" allowfullscreen></iframe>


<p>互換モードによるFiber自体はfacebook.comでも問題なく動作しているようです。
ただし、サーバーサイドレンダリングに対する対応は、まだ全く入っておらず今後どうなっていくのかは不明です。FiberになるとStreaming renderingもやりやすくなるのではとは思いますが。</p>

<h3>No more direct import!</h3>

<p>v16からは、それぞれのエントリーポイントがRollupを使ってバンドルされたものになります。
なので下のような構造になります。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">react@next and react-dom@next are flat bundles! 👀 <a href="https://twitter.com/hashtag/reactjs?src=hash">#reactjs</a> <a href="https://t.co/5ezjjf08sd">pic.twitter.com/5ezjjf08sd</a></p>&mdash; Toru Kobayashi (@koba04) <a href="https://twitter.com/koba04/status/850180571653222400">April 7, 2017</a></blockquote>


<script async src="http://blog.koba04.com//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>これにより、初期ロード時間の短縮やサーバーサイドでのパフォーマンスの向上が見込まれています。
また、利用者側には関係ないですがビルド周りが見直されており、GruntやgulpやBrowserifyのタスクがリポジトリから削除されています。すっきり。</p>

<p>この変更による、一番大きな影響は<code>react/lib/xxxx</code>として直接Reactの内部ライブラリを利用しているライブラリが動作しなくなることです。
<code>enzyme</code>などのメジャーなライブラリはReact側でもケアされていますが、それ以外のライブラリーは壊れてどうにもならなくなることがあるかもしれません。
したがって、そのようなハックをしているライブラリーを利用している場合は注意した方がよさそうです。</p>

<h3>リリース？</h3>

<p>ちなみにv16は、夏くらい(?)をターゲットに考えているようです。</p>

<p>また何か動きがあれば追記するかも。</p>
]]></content>
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: react.js | blog.koba04.com]]></title>
  <link href="http://blog.koba04.com/blog/categories/react-dot-js/atom.xml" rel="self"/>
  <link href="http://blog.koba04.com/"/>
  <updated>2015-09-21T23:45:11+09:00</updated>
  <id>http://blog.koba04.com/</id>
  <author>
    <name><![CDATA[koba04]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[React.js v0.14 changes]]></title>
    <link href="http://blog.koba04.com/post/2015/09/22/react-js-v014-changes/"/>
    <updated>2015-09-22T00:00:00+09:00</updated>
    <id>http://blog.koba04.com/post/2015/09/22/react-js-v014-changes</id>
    <content type="html"><![CDATA[<p>React v0.14のRC版が出たので紹介したいと思います。
<a href="http://facebook.github.io/react/blog/2015/09/10/react-v0.14-rc1.html">http://facebook.github.io/react/blog/2015/09/10/react-v0.14-rc1.html</a></p>

<p>インストールはnpmからバージョン指定でインストールするかscriptを読み込むことで試すことが出来ます。
<code>react-dom</code>が何なのかは後ほど説明します。</p>

<p><code>
npm install react@0.14.0-rc1
npm install react-dom@0.14.0-rc1
</code></p>

<p>or</p>

<p>```html</p>

<script src="https://fb.me/react-0.14.0-rc1.js"></script>


<!--  https://fb.me/react-with-addons-0.14.0-rc1.js -->


<script src="https://fb.me/react-dom-0.14.0-rc1.js"></script>


<p>```</p>

<!-- more -->


<h2>Major changes</h2>

<h3>ReactとReactDOMのパッケージが分割されました</h3>

<p><code>react-native</code>や<code>react-canvas</code>など、DOM以外の環境で使われるようになってくる中で、Reactのコアの部分とDOMに関わる部分がパッケージとして分割されるようになりました。</p>

<p>Reactのパッケージには、<code>React.createElement</code>、<code>React.createClass</code>、<code>React.Component</code>、<code>React.PropTypes</code>、<code>React.Children</code>が含まれています。</p>

<p>ReactDOMのパッケージには、<code>ReactDOM.render</code>、<code>ReactDOM.unmountComponentAtNode</code>、<code>ReactDOM.findDOMNod</code>が含まれています。
また、ReactDOMのパッケージには<code>react-dom/server</code>として<code>ReactDOMServer.renderToString</code>と<code>ReactDOMServer.renderToStaticMarkup</code>が含まれています。</p>

<p>```js
import React from &lsquo;react&rsquo;;
import ReactDOM from &lsquo;react-dom&rsquo;;</p>

<p>class App extends React.Component {
  render() [</p>

<pre><code>return &lt;div&gt;Hello&lt;/div&gt;
</code></pre>

<p>  ]
}</p>

<p>ReactDOM.render(<App />, document.getElementById(&lsquo;app&rsquo;));</p>

<p>// サーバーサイド
import ReactDOMServer from &lsquo;react-dom/server&rsquo;;
const html  = ReactDOMServer.renderToString(<App />);
```</p>

<p>scriptタグで読み込んで利用する場合は、ReactとReactDOMそれぞれを読み込んで利用する必要があります。</p>

<p>```html</p>

<script src="https://fb.me/react-0.14.0-rc1.js"></script>


<script src="https://fb.me/react-dom-0.14.0-rc1.js"></script>


<div id="app"></div>


<script>
var App = React.createClass({
    render: function() {
        return React.createElement('div', {}, 'hello', 'world');
    }
});

ReactDOM.render(React.createElement(App), document.getElementById('app'));
</script>


<p>```</p>

<p>codemodも提供されているので既存のコードを一括で変換したい場合は使ってみるといいかもしれません。
<a href="https://github.com/facebook/react/blob/master/packages/react-codemod/README.md">https://github.com/facebook/react/blob/master/packages/react-codemod/README.md</a></p>

<h4>Addons</h4>

<p>また、Addonもそれぞれ個別のパッケージに分割されたので必要に応じてnpmでインストールするようになりました。</p>

<ul>
<li>react-addons-clone-with-props</li>
<li>react-addons-create-fragment</li>
<li>react-addons-css-transition-group</li>
<li>react-addons-linked-state-mixin</li>
<li>react-addons-perf</li>
<li>react-addons-pure-render-mixin</li>
<li>react-addons-shallow-compare</li>
<li>react-addons-test-utils</li>
<li>react-addons-transition-group</li>
<li>react-addons-update</li>
</ul>


<p>これによって、1つのAddonを使いたい時にその他全部のAddonがbundleされることがなくなりました。
scriptタグで読み込むための<code>react-with-addons</code>のJSにはこれまで通り全てのAddonが含まれています。</p>

<p>また、<code>batched_updates</code>としてあったReactのイベントやライフサイクル以外でもバッチによる一括アップデートを行えるAddonは<code>ReactDOM.unstable_batchedUpdates</code>に移動しました。</p>

<p><code>js
let count = 0;
cost component = ReactDOM.render(&lt;App /&gt;, document.getElementById('app'));
ReactDOM.unstable_batchedUpdates(() =&gt; {
  component.setState({count: ++count});
  component.setState({count: ++count});
});
</code></p>

<p>ちなみにunstable_batchedUpdatesという名前になっているけど今後どうする予定なのかを聞いたところ、全ての更新をバッチ更新にしたいということだったので最終的には不必要にしたいようです。</p>

<p><strong>ReactとReactDOMやAddon</strong> のパッケージは意図しない挙動を避けるために同じバージョンを使うことが推奨されています。</p>

<h3>DOMComponentに対するrefによる参照でDOM Nodeが取得出来るようになりました</h3>

<p>これまでDOM node<code>React.findDOMNode(this.refs.div)</code> のようにする必要がありましたが、<code>this.refs.div</code>で直接DOM nodeを取得することが出来るようになりました。
findDOMNodeの呼び出しを書かなくてもいいというだけですが簡単になりました。
それと同時にrefでのComponentの参照はDOM Component以外では使わないようにしておかないと混乱を招きそうではあります。</p>

<p>また、<code>ReactDOM.render(&lt;div&gt;foo&lt;/div&gt;)</code> とした場合の返り値もDOM Nodeになります。
ReactDOM.findDOMNodeは以降もComposite Componentに対するDOM nodeを取得する場合に利用することが出来ます。</p>

<h3>Stateless Components</h3>

<p>Propsだけに依存するような状態を持たないComponentを定義するための新しい方法が追加されました。</p>

<p>```js
function Hello(props) {
  return <div>Hello {props.name}
}</p>

<p>// Arrow Functions
const Hello = (props) => {
  return <div>Hello {props.name}</div>;
};</p>

<p>// Arror Functions and Destructuring Assignment
const Hello = ({name}) => {
  return <div>Hello {name}</div>;
}
```</p>

<p>また、PropTypesやdefaultPropsも定義することが出来ます。</p>

<p><code>js
function Hello(props) {
  return &lt;div&gt;Hello {props.name}
}
Hello.propTypes = {
  name: React.PropTypes.string
};
Hello.defaultProps = {
  name: 'World'
};
</code></p>

<p>あとContextも。</p>

<p><code>js
function Hello(props, context) {
  return &lt;div&gt;{context.version}&lt;/div&gt;
}
Hello.contextTypes = {
  version: React.PropTypes.number
}
</code></p>

<p>v0.14では最低限の実装のみになっていますが、以降のバージョンではStateless Componentsで書いておくことでパフォーマンス最適化の恩恵が受けられるようになる予定です。
v0.14以降ではStateless ComponentsがComponent定義の第一の選択肢になっていきそうです。</p>

<h3>react-toolsは廃止されました</h3>

<p>これは以前にもブログで紹介されていましたが、<code>react-tools</code>は非推奨になります(もう更新されない)。代わりにBabelを利用しましょう。</p>

<p><a href="http://facebook.github.io/react/blog/2015/06/12/deprecating-jstransform-and-react-tools.html">http://facebook.github.io/react/blog/2015/06/12/deprecating-jstransform-and-react-tools.html</a></p>

<ul>
<li>jsxコマンドは<code>babel</code>コマンドになります。</li>
<li>browserifyのtransformであるreactifyは<code>babelify</code>になります。</li>
<li>webpackのjsx-loaderは<code>babel-loader</code>になります</li>
<li>Node.jsのサーバー上で動かすときに<code>require('node-jsx').install()</code>としていたものは<code>require('babel/register')</code>になります。</li>
<li>ブラウザでJSXを変換するために使うJSXTransformはbabel-core/browser.jsを読み込んでtypeを<code>text/babel</code>にして使用します。</li>
</ul>


<p>```html</p>

<script src="https://fb.me/react-0.14.0-rc1.js"></script>


<script src="https://fb.me/react-dom-0.14.0-rc1.js"></script>


<script src="node_modules/babel-core/browser.js"></script>


<script type="text/babel">
const Hello = ({name}) => <div>{name}</div>
</script>


<p>```</p>

<p>ちなみにBabelは6.0でTransformが全て外出しになり使う場合はpluginとして読み込みようになることが予定されています。</p>

<p><code>
"plugins": ["preset-es2015", "preset-react"]
</code></p>

<h3>Babelによるコンパイル最適化が実施されるようになりました</h3>

<p>Babel5.8.23以降のバージョンを利用することで、<code>inlineElements</code>と<code>constantElements</code>を２つの最適化を行うことが出来るようになります。
これらは開発用のwarningやPropTypesによるチェックを無効化するので、productionモードの場合だけで有効にすることが推奨されています。</p>

<p>下記のコードを元に変換内容を確認してみます。</p>

<p>```js
// hello.js
class App extends React.Component {
  render() {</p>

<pre><code>return (
  &lt;div&gt;
    &lt;p&gt;Hello&lt;/p&gt;
    &lt;p&gt;{this.props.name}&lt;/p&gt;
  &lt;/div&gt;
)
</code></pre>

<p>  }
}
```</p>

<p>最適化なし</p>

<p>```js
var App = (function (<em>React$Component) {
  </em>inherits(App, _React$Component);</p>

<p>  function App() {</p>

<pre><code>_classCallCheck(this, App);

_get(Object.getPrototypeOf(App.prototype), "constructor", this).apply(this, arguments);
</code></pre>

<p>  }</p>

<p>  _createClass(App, [{</p>

<pre><code>key: "render",
value: function render() {
  return React.createElement(
    "div",
    null,
    React.createElement(
      "p",
      null,
      "Hello"
    ),
    React.createElement(
      "p",
      null,
      this.props.name
    )
  );
}
</code></pre>

<p>  }]);</p>

<p>  return App;
})(React.Component);
```</p>

<h4>inlineElements</h4>

<p>inlineElementsの最適化を行うことでJSXの変換が<code>React.createElement</code>への変換ではなくてただのオブジェクトへの変換となります。</p>

<p><code>
babel --optional optimisation.react.inlineElements test.js
</code></p>

<p>```js
_createClass(App, [{
  key: &ldquo;render&rdquo;,
  value: function render() {</p>

<pre><code>return {
  $$typeof: _typeofReactElement,
  type: "div",
  key: null,
  ref: null,
  props: {
    children: [{
      $$typeof: _typeofReactElement,
      type: "p",
      key: null,
      ref: null,
      props: {
        children: "Hello"
      },
      _owner: null
    }, {
      $$typeof: _typeofReactElement,
      type: "p",
      key: null,
      ref: null,
      props: {
        children: this.props.name
      },
      _owner: null
    }]
  },
  _owner: null
};
</code></pre>

<p>  }
}]);</p>

<p>return App;
})(React.Component);
```</p>

<h4>constantElements</h4>

<p><code>constantElements</code>では、変数の含まれていないReactElementに対する呼び出しを<code>render</code>の外に出すことで不必要な<code>React.createElement</code>の呼び出しを避ける事が出来ます。</p>

<p><code>
babel --optional optimisation.react.constantElements test.js
</code></p>

<p>```js
var _ref = React.createElement(
  &ldquo;p&rdquo;,
  null,
  &ldquo;Hello&rdquo;
);</p>

<p>var App = (function (<em>React$Component) {
  </em>inherits(App, _React$Component);</p>

<p>  function App() {</p>

<pre><code>_classCallCheck(this, App);

_get(Object.getPrototypeOf(App.prototype), "constructor", this).apply(this, arguments);
</code></pre>

<p>  }</p>

<p>  _createClass(App, [{</p>

<pre><code>key: "render",
value: function render() {
  return React.createElement(
    "div",
    null,
    _ref,
    React.createElement(
      "p",
      null,
      this.props.name
    )
  );
}
</code></pre>

<p>  }]);</p>

<p>  return App;
})(React.Component);
```</p>

<h2>Breaking changes</h2>

<p>ここでのBreaking changeはv0.13でwarningとして出力されていたものです。</p>

<ul>
<li>Propsは変更不可として扱われます。開発用のビルドでは<code>Object.freeze</code>されています。Propsの値を変更したい場合は、<code>React.cloneElement</code>によって再生成する必要があります。</li>
<li>childrenにオブジェクト形式で渡すことはサポートされなくなりました。配列に変更するか<code>react-addons-create-fragment</code>を使う必要があります。</li>
<li><code>classSet</code>は削除されたので代わりに<code>classnames</code>のnpm packageを利用してください。</li>
</ul>


<hr />

<p>以下はv0.13でwarningが出力されていなかったものですが、簡単に修正することが出来る変更点です。</p>

<ul>
<li><code>React.initializeTouchEvents</code>は不要になったので削除してください。タッチイベントはデフォルトでサポートされるようになりました。</li>
<li>前述したDOM Componentに対するrefの変更により、<code>TestUtils.findAllInRenderedTree</code>とそれに関連するhelperはComposite Componentのみを受け取るようになりました。(<code>scryRendered〜</code>、<code>findRendered〜</code>系のTestUtils)</li>
</ul>


<h2>Deprecations</h2>

<ul>
<li><code>getDOMNode</code>は非推奨になったので代わりに<code>ReactDOM.findDOMNode</code>を利用してください。前述したとおりDOM Componentの場合は<code>ReactDOM.findDOMNode</code>も不要です。</li>
<li><code>setProps</code>と<code>replaceProps</code>は非推奨になります。代わりに親のComponentから再度<code>ReactDOM.render</code>を呼んでください。</li>
<li>ES6 ClassesによるComponent定義で<code>React.Component</code>を継承することが必須になりました。<a href="http://facebook.github.io/react/blog/2015/01/27/react-v0.13.0-beta-1.html#other-languages">ES3 module pattern</a>はまだ使用することが出来ます。</li>
<li><code>style</code>のPropsを別のrenderと共有し変更することはPropsが変更不可として扱われる影響で非推奨となりました。</li>
<li><code>react-addons-clone-with-props</code>は非推奨になりました。代わりに<code>React.cloneElement</code>を使用してください。<code>cloneElement</code>は<code>cloneWithProps</code>と違い、<code>className</code>と<code>style</code>のmergeは行いません。必要であれば開発者がmergeする必要があります。</li>
<li>信頼性向上のために<code>react-addons-css-transition-group</code>がtransition eventをlistenしなくなりました。そのため<code>transitionEnterTimeout={500}</code>のように明示的にdurationをPropsに指定する必要があります。</li>
</ul>


<h2>Enhancements</h2>

<ul>
<li><code>React.Children.toArray</code>が追加されました。ネストしたchildrenを受け取りkeyを設定したフラットな配列として返すことが出来ます。また<code>React.Children.map</code>もただの配列を返すようになりました。</li>
</ul>


<p>```js
React.Children.toArray(
  [</p>

<pre><code>&lt;div&gt;foo&lt;/div&gt;, &lt;div&gt;bar&lt;/div&gt;,
[&lt;div&gt;baz&lt;/div&gt;]
</code></pre>

<p>  ]
);</p>

<p>// [<div key=".0">foo</div>, <div key=".1">bar</div>, <div key=".2:0">baz</div>]
```</p>

<ul>
<li><p><code>console.warn</code>の代わりに<code>console.error</code>でwarningを出力するようになりました(stack traceを出すため)。<code>console.error</code>として出力されるwarningは将来のバージョンで壊れるような使い方をしていた場合であり、<code>must-fix</code>なエラーとして扱われるべきです。</p></li>
<li><p>可能であればReactDOMがXHTML互換なHTMLを生成するようになりました。</p></li>
<li><p>ReactDOMが<code>capture、challenge、inputMode、is、keyParams、keyType、minLength、summary、wrap</code>といった標準の属性や<code>autoSave、results、security</code>といった非標準な属性をサポートするようになりました。</p></li>
<li><p>SVG属性のサポートが追加されました。</p></li>
</ul>


<p><code>
xlinkActuate、xlinkArcrole、xlinkHref、xlinkRole、xlinkShow、xlinkTitle、xlinkType、xmlBase、xmlLang、xmlSpace
</code></p>

<ul>
<li><p><code>image</code>のSVGタグがサポートされました。</p></li>
<li><p>custome elementsで任意の属性がサポートされるようになりました。</p></li>
<li><p><code>audio</code>と<code>video</code>タグに対するイベントのサポートが追加されました。</p></li>
</ul>


<p><code>
onAbort、onCanPlay、onCanPlayThrough、onDurationChange、onEmptied、onEncrypted、onEnded、onError
onLoadedData、onLoadedMetadata、onLoadStart、onPause、onPlay、onPlaying
onProgress、onRateChange、onSeeked、onSeeking、onStalled、onSuspend、onTimeUpdate、onVolumeChange、onWaiting
</code></p>

<ul>
<li><p><code>shallowCompare</code>のAddonがES6 ClassesのComponentで<code>PureRenderMixn</code>を使うためのマイグレーションのパスとして用意されました。</p></li>
<li><p><code>CSSTransitionGroup</code>が<code>xxx-enter-active</code>のようにclassNameに追加する名前を任意に指定出来るようになりました。</p></li>
</ul>


<p>```js
&lt;ReactCSSTransitionGroup
   transitionName={</p>

<pre><code> enter: 'enter',
 enterActive: 'enterActive',
 leave: 'leave',
 leaveActive: 'leaveActive',
 appear: 'appear',
 appearActive: 'appearActive'
</code></pre>

<p>   }>
   {item}
 </ReactCSSTransitionGroup></p>

<p> &lt;ReactCSSTransitionGroup
   transitionName={</p>

<pre><code> enter: 'enter',
 leave: 'leave',
 appear: 'appear'
</code></pre>

<p>   }>
   {item2}
 </ReactCSSTransitionGroup>
```</p>

<h2>Helpful warnings</h2>

<ul>
<li><p>ReactDOMがHTML構造と不正な要素を受け取った時点でwarningを出力するようになり、更新時に突然エラーとして表面化するよりわかりやすくなりました。</p></li>
<li><p><code>document.body</code>に対して<code>ReactDOM.render</code>使用するとwarningを出力するようになりました。</p></li>
<li><p>複数の異なるReactのオブジェクトを同時に利用しようとした場合に、warningを出力するようになりました。これはnpmとbrowserifyなどを組み合わせている場合に意図せずに起こってしまうことがあります。</p></li>
</ul>


<h2>Bug fixes</h2>

<ul>
<li><p>Mobile Browsersにおいてのクリックイベントのハンドリング(cursor: pointer周り？)にあったバグが修正されました。(特にMobile Safari)</p></li>
<li><p>SVG Elementが多くの場合で正しい名前空間と一緒に描画されるようになりました。</p></li>
<li><p>ReactDOMで複数のchildrenを持ったoptionの場合(<code>&lt;select&gt;&lt;option value={val}&gt;{label}:{val}&lt;/option&gt;&lt;/select&gt;</code>)にエラーとなっていたバグが修正されました。</p></li>
<li><p>サーバーサイドレンダリング時にselectタグのvalueがoptionタグのselectedとして反映されるようになりました。</p></li>
<li><p>同じdocumentに対して複数のReactのオブジェクトで要素を追加した状態になった時、イベントハンドリングのタイミングで発生していたエラーがなるべく起きないようになりました。但し、radio buttonを同じnameでrenderしていた場合などエラーになる状況は残っています。</p></li>
<li><p>小文字でないHTMLタグ名をReactDOMで使った場合でも問題にならないようになりました。ただしDOM Componentの場合には小文字で指定することを変わらずに推奨します。</p></li>
<li><p>ReactDOMが<code>animationIterationCount</code>、<code>boxOrdinalGroup</code>、<code>flexOrder</code>、<code>tabSize</code>、<code>stopOpacity</code>のCSSプロパティに対して'px'を追加しないようになりました。</p></li>
<li><p><code>react-addons-test-utils</code>で<code>Simulate.mouseEnter</code>と<code>Simulate.mouseLeave</code>が利用可能になりました。</p></li>
<li><p><code>react-addons-transition-group</code>で複数のnodeが同時に削除された場合にも正しく処理出来るようになりました。</p></li>
</ul>


<h2>ReactElement tags by Symbol</h2>

<p><a href="https://github.com/facebook/react/pull/4832">https://github.com/facebook/react/pull/4832</a></p>

<p>Reactではv0.14から<code>React.createElement</code>でReactElementのインスタンスではなくてただのオブジェクトが返ってくるようになっていたり、上の方で紹介したBabelによるinlineElementsの最適化によってcreateElementの呼び出しがただのオブジェクトに変換されることからも分かる通り、オブジェクトをそのままVIRTUAL DOMとして扱いDOMを生成することが出来ます。
前提としてユーザーが任意のオブジェクトをそのままReactElementとして描画出来ること自体が問題でありますが、ユーザーによって作成されるオブジェクトをそのままrenderに渡していると意図しないコンテンツを表示されたりXSSのリスクがあります。</p>

<ul>
<li><a href="https://github.com/facebook/react/issues/3473">How Much XSS Vulnerability Protection is React Responsible For? #3473</a></li>
</ul>


<p>そのため、信頼されたReactElementかどうかを判別するための方法が議論されていました。セキュリティに興味のある人はこの辺りのissueを見てみると面白いと思います。</p>

<ul>
<li><a href="https://github.com/facebook/react/pull/3583">[RFC] Trusted sources for React elements. #3583</a></li>
</ul>


<p>Reactでは最初はinstanceofでReactElementかどうかのチェックが行われていたのですが、それだと常にReactElementのインスタンスである必要がありオブジェクト化による最適化や複数のReactを使っていた場合にチェックが失敗するなど制限が多くなってしまいます。そのため、<code>_isReactElement</code>というがtrueかどうかをみるように変わりましたがこれでは信頼されたオブジェクトであるかを判定することは出来ません。</p>

<p>ユーザーが<code>_isReactElement</code>をオブジェクトに指定することでReactElementとして評価され、さらにReactには<code>dangerouslySetInnerHTML</code>というPropでHTMLをそのまま渡すことが出来るので&hellip;。</p>

<p>```js
{
  type:&ldquo;div&rdquo;,
  _isReactElement: true,
  props: {</p>

<pre><code>dangerouslySetInnerHTML: {
  __html: "&lt;img onload='alert(123)' src='http://blog.koba04.com/favicon.ico' /&gt;".
}
</code></pre>

<p>  }
}
```</p>

<p>v0.14ではSymbolを使って信頼されたReactElementかどうかを判定するようになります。</p>

<ul>
<li><a href="https://github.com/facebook/react/pull/4832">Use a Symbol to tag every ReactElement #4832</a></li>
</ul>


<h3>How it works?</h3>

<p>```js
var TYPE_SYMBOL = (typeof Symbol === &lsquo;function&rsquo; &amp;&amp; Symbol.for &amp;&amp;</p>

<pre><code>              Symbol.for('react.element')) || 0xeac7;
</code></pre>

<p>```
* <a href="https://github.com/sebmarkbage/react/blob/031fc24daeae6bcdc5e5f6959b778e1c2ed5f378/src/isomorphic/classic/element/ReactElement.js#L20-L21">https://github.com/sebmarkbage/react/blob/031fc24daeae6bcdc5e5f6959b778e1c2ed5f378/src/isomorphic/classic/element/ReactElement.js#L20-L21</a></p>

<p>上記のようにSymbolを保持していおいて、それを<code>React.createElement</code>で作成したObjectにも<code>$$typeof</code>というpropertyとして渡しておいて、ReactElementが有効であるかを返す<code>isValidElement</code>という関数の中の比較で利用しています。</p>

<p><code>Symbol.for</code>は指定されたSymbolがあればそれを返しなければ作成して返すので、グローバルなSymbolとして扱うことが出来ます。これによってただのオブジェクトも複数のReactを使っていた場合もサポートすることが出来ます。
(複数のReactがある場合は既に書いた通り別途warningが出ます)</p>

<p>Symbolが実装されていないような環境だと固定の値(0xeac7)になるので、この機能を有効にしたい場合はSymbolのpolyfillを入れておく必要があります。</p>

<p><a href="https://kangax.github.io/compat-table/es6/#Symbol">https://kangax.github.io/compat-table/es6/#Symbol</a></p>

<p>また、BabelのinlineElementsの最適化を使った場合にどうなるんだと思った人もいると思いますがすでに対応されて5.8.24としてリリースにされています。</p>

<p><a href="https://github.com/babel/babel/pull/2352">https://github.com/babel/babel/pull/2352</a></p>

<h2>v0.15?</h2>

<p>v0.15はGarbage collection releaseと位置づけられていて、つまりAPIの整理などに重点が置かれたリリースになる予定でv0.14のリリースから遠くないタイミングで出るそうです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React.js meetup #2を開催しました]]></title>
    <link href="http://blog.koba04.com/post/2015/09/09/reactjs-meetup2/"/>
    <updated>2015-09-09T22:53:58+09:00</updated>
    <id>http://blog.koba04.com/post/2015/09/09/reactjs-meetup2</id>
    <content type="html"><![CDATA[<ul>
<li><a href="http://reactjs-meetup.connpass.com/event/19504/">http://reactjs-meetup.connpass.com/event/19504/</a></li>
<li><a href="http://eventdots.jp/eventreport/568979">http://eventdots.jp/eventreport/568979</a></li>
</ul>


<p>4月に#1をやってから約4ヶ月くらい経ちましたがReact.js meetup #2を開催しました。</p>

<p>雨の中来てくださった方、発表者の方、運営のお手伝いをしてくださった方ありがとうございました！</p>

<!-- more -->


<h2>開催の経緯</h2>

<p>最初は今回発表してくださったViktorさんが来日されるのでそれにあわせてイベントをやるという話があり、せっかくなのでということでReact.js meetupの2回目としてやることになりました。</p>

<h2>dots</h2>

<p>開催予定日まで時間もなくてその時点で話す人も決まっていたので後は会場を決めればなんとかなりそうということで、いくつかの選択肢の中から今回はdotsさんで開催することになりました。
渋谷の駅から近くて、人数も200人近く入れるし会場もオシャレな感じだったのでここだ！という感じで決めました。</p>

<blockquote class="twitter-tweet" lang="en"><p lang="ja" dir="ltr"><a href="https://twitter.com/hashtag/reactjs_meetup?src=hash">#reactjs_meetup</a> #2 at dots!! (@ dots. in 渋谷区, 東京都) <a href="https://t.co/os56mGdfFu">https://t.co/os56mGdfFu</a> <a href="http://t.co/2BhpBeIK9H">pic.twitter.com/2BhpBeIK9H</a></p>&mdash; Toru Kobayashi (@koba04) <a href="https://twitter.com/koba04/status/641186091891073024">September 8, 2015</a></blockquote>


<script async src="http://blog.koba04.com//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>募集開始の際にはご迷惑をお掛けしましたが&hellip;dotsさん、ありがとうございました！</p>

<h2>準備など</h2>

<p>今回は <a href="https://twitter.com/yoshiko_pg">@yoshiko_pg</a> さんから話をもらって、その後の色々な準備もほとんどやってもらって本当に感謝でした。ありがとうございます！
当日の準備や受付は <a href="http://goodpatch.com/jp">Goodpatch</a> の方々がやってくださり、お菓子も提供して頂いて本当にありがたかったです。仲良さそうな感じが印象的でした。ありがとうございます！</p>

<h2>Talk</h2>

<p>各Talkのスライドはここにあるので見てください。</p>

<p><a href="http://reactjs-meetup.connpass.com/event/19504/">http://reactjs-meetup.connpass.com/event/19504/</a></p>

<p>自分のTalkはReactの次のバージョンである0.14での変更点について話しました。予想としてはRC版が出てるはずだったのですが&hellip;。
Stateless Componentsが加わったりはしていますが、基本的には無駄な機能は削ぎ落としたりメンテナンス性を維持していくための変更が多い印象で正しい方向に向かっている印象を持っています。</p>

<p>全体を通してReduxのような最近注目されているようなTopicから、Flowtypeのような型付けやDDDなどReact.jsやFluxを使って実際に大規模なアプリを作っていく中で求められるようなTopicについての話まであって面白かったです。</p>

<p>FlowtypeがもっとFacebook以外でも使いやすくコントリビュートしやすくなっていくといいなーと思いながら、それには壁がいくつもありそうだなとViktorさんと話して感じたり。</p>

<p>後、LTを一句で締めるのとてもよかったです。</p>

<h2>当日の様子</h2>

<p><a href="http://togetter.com/li/871189">http://togetter.com/li/871189</a></p>

<p>感想とか書いてもらえると嬉しいです！</p>

<h2>次回？</h2>

<p>まったく何も考えていないので、聞きたいテーマなどあれば教えてもらえると嬉しいです！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React.js meetup #1 を開催しました]]></title>
    <link href="http://blog.koba04.com/post/2015/04/25/reactjs-meetup1/"/>
    <updated>2015-04-25T17:11:35+09:00</updated>
    <id>http://blog.koba04.com/post/2015/04/25/reactjs-meetup1</id>
    <content type="html"><![CDATA[<p><a href="http://reactjs-meetup.connpass.com/event/11232/">http://reactjs-meetup.connpass.com/event/11232/</a></p>

<p>一人Advent Calendar書いた時にやりたいと言っていたのでReact.js meetup #1 を<a href="http://twitter.com/yosuke_furukawa">@yosuke_furukawa</a>さんと開催しました。</p>

<p> DeNAさんが会場から懇親会のお酒や寿司、当日の運営まで全てやってくださったので自分はほとんど何もしてないですが..。
 本当にありがとうございました！！</p>

<p>やりたいって言ってこの規模の勉強会を開催させてもらえるの本当にスゴいなぁと思います&hellip;。</p>

<p> <blockquote class="twitter-tweet" lang="en"><p><a href="https://twitter.com/hashtag/reactjs_meetup?src=hash">#reactjs_meetup</a> <a href="https://twitter.com/hashtag/react_sushi?src=hash">#react_sushi</a> です <a href="http://t.co/GdpyF7Paqk">pic.twitter.com/GdpyF7Paqk</a></p>&mdash; Toru Kobayashi (@koba04) <a href="https://twitter.com/koba04/status/591580062702383107">April 24, 2015</a></blockquote></p>

<script async src="http://blog.koba04.com//platform.twitter.com/widgets.js" charset="utf-8"></script>




<!-- more -->


<p>ある程度予想はしていたのですが、Talkが10分と短かったりで押して慌ただしい感じになってしまったのは申し訳なかったなぁと思ってます。
ただ、色んなテーマのTalkを一度に聞くことが出来たのはよかったかなと思っています。</p>

<h2>Talks</h2>

<p>各Talkの資料についてはconpassのページに追加しておいたのでそちらを見て頂くとして簡単な一言感想です。</p>

<p><a href="http://reactjs-meetup.connpass.com/event/11232/presentation/">http://reactjs-meetup.connpass.com/event/11232/presentation/</a></p>

<h3><a href="https://twitter.com/naoya_ito">@naoya_ito</a> &ndash; React概論</h3>

<p>Reactの特徴をわかりやすく説明していてReact.js触ってない人にとってもわかりやすい説明だったんじゃないかなと思います。</p>

<h3><a href="https://twitter.com/hokaccha">@hokaccha</a> &ndash; react-rails</h3>

<p>Railsと一緒に使いたい人にとってはかなり有益な情報だったんじゃないかなと思います。Turbolinksどうするのとか。</p>

<h3><a href="https://twitter.com/azu_re">@azu_re</a> &ndash; 10分で実装するFlux</h3>

<p>Fluxを最小限の構成にしてデータの流れを一方向にするということがどういうことなのか説明していてわかりやすかったです。console.traceを使っての説明もなるほどなぁと思いました。</p>

<h3><a href="http://twitter.com/yosuke_furukawa">@yosuke_furukawa</a> &ndash; mercury/mithril.js</h3>

<p>React.jsのVIRTUAL DOMのdiffアルゴリズムの説明からmercuryやmithril.jsといった他のライブラリがどうやってReact.jsより高速化しているのかという説明で面白かったです。</p>

<h3><a href="https://twitter.com/mizchi">@mizchi</a> &ndash; React/FluxでSPAを開発してぶちあたった問題</h3>

<p>KobitoをReact.js + Fluxで作った時の問題になった点と解決方法について説明していて、ないものは作る姿勢がスゴイなぁ思いました。</p>

<h3><a href="https://twitter.com/sugyan">@sugyan</a> &ndash; React.jsと、 Railsとかアイドルとか (LT)</h3>

<p>React.jsとRailsでReactRouter使ったり色々組み合わてみた話でツラいと言いながらちゃんと作ってしまうところがスゴイなぁと思いました。</p>

<h3><a href="https://twitter.com/making">@making</a> &ndash; Java + React.jsでSever Side Rendering (LT)</h3>

<p>SPAで作ったブログが検索に引っかからないからReact.js + Javaでserver-side renderingするようにしたという話で、最後のオチも含めて面白かったです。</p>

<h3><a href="https://twitter.com/tyshgc">@tyshgc</a> &ndash; Rapid React Prototyping : React.jsでUIデザインプロトタイプを作る (LT)</h3>

<p>React.jsでプロトタイプを作る話で、Photoshopのレイヤー情報からReact.jsのComponentを生成するようにしていてスゴかったです。</p>

<h3><a href="https://twitter.com/teppeis">@teppeis</a> &ndash; Flowtype (LT)</h3>

<p>懇親会の時にFlowtypeについてのLTをしてくれて、デモもあったりFacebookが開発中のElectron(旧:AtomShell)ベースのNuclideの話まであって面白かったです。</p>

<h2>LiveCodingやった</h2>

<p>ぼっちでも懇親会に参加して欲しかったので、ぼーっと見ていたり会話のネタになるかなと思ってLiveCodeingをやってみました。</p>

<p>最近だとJSの環境を作るにも何を使えばいいのかわからないという声も聞くので、0から簡単なアプリを作るところまでの流れを伝えられればと思い、HackerNewsのAPIを使ってTopStoryの一覧を表示するものを作ってみました。</p>

<p>あと、3分間クッキングみたいに事前に色々用意しておくのもライブ感がないなぁと思ったので<code>mkdir</code>から全部その場で作ることにしました。</p>

<p><a href="https://github.com/koba04/react-hacker-news-stories/tree/meetup">https://github.com/koba04/react-hacker-news-stories/tree/meetup</a></p>

<p>環境構築は、browserifyとwatchifyとbabelifyで変換を行ってlivereloadするためのbrowser-syncを使いました。</p>

<p>LiveCodingの流れとしては</p>

<ul>
<li>ディレクトリ作ったり<code>npm init</code>したり<code>npm install</code>したりして環境を作る</li>
<li>Hello Worldしてみる(Hellって書いたけど&hellip;)</li>
<li>各Componentを作成する</li>
<li>HackerNewsのAPI叩いて一覧が出るようにする</li>
<li><code>React.addons.Perf</code>を使ってDOMが無駄に更新されていることとkeyが指定されていないwarningが出ていることを確認</li>
<li>keyを指定することで無駄のDOM操作がなくなることを確認</li>
<li>diffの時間を減らすために<code>Immutable.js</code>を使いつつ<code>shouldComponentUpdate</code>を実装</li>
</ul>


<p>という感じで行いました。</p>

<p>ライブコーディングが初めてで緊張していたのとお酒が入っていたのもあって(言い訳)、いつもと同じ感覚でコーディング出来なくてtypoしまくってしまい、「これ終わらないかも&hellip;」とかなり駆け足になってしまったのは反省です&hellip;。
(事前に練習はしたんですが&hellip;)</p>

<p>でも、とりあえず最後まで出来てよかった&hellip;。</p>

<h2>まとめ</h2>

<p>イベントの管理者側でやるのは初めてだったので色々至らない点があったかもしれませんが、準備してくださったDeNAの方々、発表者の方々、参加者の皆様、本当にありがとうございました！！</p>

<p>感想とかブログに書いてもらえると嬉しいです！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setting up minimum single page application]]></title>
    <link href="http://blog.koba04.com/post/2015/03/19/setting-up-minimum-single-page-application/"/>
    <updated>2015-03-19T18:54:49+09:00</updated>
    <id>http://blog.koba04.com/post/2015/03/19/setting-up-minimum-single-page-application</id>
    <content type="html"><![CDATA[<p>React.jsなどを試そうとするときに、browserify? gulp? grunt? webpack? どれ使えばいいのとか、テストは何を使えばいいのかとかよくわからないというのをたまに聞くので、最低限の設定だけどES6で書けたりautobuildやlivereloadが出来る構成のサンプルを作ってみました。</p>

<p>あと、テストはkarma + mocha + power-assertでchromeでテスト出来るようにしています。</p>

<!-- more -->


<p>本当はpackage.jsonだけにしたかったのですがkarmaの設定だけは別ファイルになってます&hellip;。
テストが必要ない場合は、package.jsonの指定だけで大丈夫です。</p>

<ul>
<li><a href="https://github.com/koba04/minimum-spa-boilerplate">https://github.com/koba04/minimum-spa-boilerplate</a></li>
</ul>


<p>git cloneして<code>npm install</code>して<code>npm start</code>すればいいだけの設定になっています。</p>

<p><code>
git clone git@github.com:koba04/minimum-spa-boilerplate.git
npm install
npm start
</code></p>

<p><img src="http://i.gyazo.com/f906464bfb325437c5c905f80a5b976d.gif" alt="gif" /></p>

<h2>概要</h2>

<h3>tree</h3>

<p><code>
➜  tree -L 1
.
├── README.md
├── index.js         // エントリーポイント
├── karma.conf.js    // karmaの設定
├── lib              // ソース
├── node_modules
├── package.json     // 設定はこの中
├── public           // document root
└── test             // テスト
</code></p>

<h3>package.json</h3>

<p>基本的には<code>npm init</code>で作ったものに色々インストールしてnpm scriptの設定をしているだけです。</p>

<p>```json
  &ldquo;scripts&rdquo;: {</p>

<pre><code>"build": "NODE_ENV=production browserify index.js -t babelify | uglifyjs &gt; public/bundle.js",
"watch": "watchify -d index.js -t babelify -o public/bundle.js -v",
"server": "browser-sync start --server public --files public/**/*",
"test": "karma start",
"start": "npm run watch &amp; npm run server &amp; npm test"
</code></pre>

<p>  },</p>

<p>  &ldquo;dependencies&rdquo;: {</p>

<pre><code>"react": "^0.13.1"
</code></pre>

<p>  },
  &ldquo;devDependencies&rdquo;: {</p>

<pre><code>"babelify": "^5.0.4",
"browser-sync": "^2.3.1",
"browserify": "^9.0.3",
"espowerify": "^0.10.0",
"karma": "^0.12.31",
"karma-browserify": "^4.0.0",
"karma-chrome-launcher": "^0.1.7",
"karma-cli": "0.0.4",
"karma-mocha": "^0.1.10",
"mocha": "^2.2.1",
"power-assert": "^0.10.2",
"uglify-js": "^2.4.17",
"watchify": "^2.4.0"
</code></pre>

<p>  }
```
<a href="https://github.com/koba04/minimum-spa-boilerplate/blob/master/package.json">https://github.com/koba04/minimum-spa-boilerplate/blob/master/package.json</a></p>

<ul>
<li><code>npm run build</code></li>
</ul>


<p>これはReactに依存したビルドになっているのですが、production用にビルドされたファイルを生成することを想定しています。</p>

<ul>
<li><code>npm run watch</code></li>
</ul>


<p>watchifyによってファイルが変更されたら自動的にbrowserifyのビルドが走るようになっています。
watchifyはキャッシュするので二回目以降のビルドが高速化されるのもポイントです。</p>

<ul>
<li><code>npm run server</code></li>
</ul>


<p>BrowserSyncによって<code>public</code>をrootにしたserverを立ちあげつつ、<code>public</code>以下のファイルを監視してlivereloadするようになっています。</p>

<ul>
<li><code>npm test</code></li>
</ul>


<p>テストはkarmaを使うので<code>karma start</code>しているだけです。<code>karma</code>の設定は<code>karma.conf.js</code>にあります。</p>

<ul>
<li><code>npm start</code></li>
</ul>


<p>上記のweatchとbrowserとtestをまとめて実行するコマンドで、これだけ実行すれば開発を始められるようになっています。</p>

<h3>karma</h3>

<p>karmaは<code>karma init</code>で対話的に作成出来る<code>karma.conf.js</code>にbrowserifyの設定を追加したくらいです。</p>

<p>```js
// frameworks to use
// available frameworks: <a href="https://npmjs.org/browse/keyword/karma-adapter">https://npmjs.org/browse/keyword/karma-adapter</a>
frameworks: [&lsquo;mocha&rsquo;, &lsquo;browserify&rsquo;],</p>

<p>// list of files / patterns to load in the browser
files: [
  &lsquo;test/<em>*/</em>.js&rsquo;
],</p>

<p>// list of files to exclude
exclude: [
],</p>

<p>// preprocess matching files before serving them to the browser
// available preprocessors: <a href="https://npmjs.org/browse/keyword/karma-preprocessor">https://npmjs.org/browse/keyword/karma-preprocessor</a>
preprocessors: {
  &lsquo;test/<em>*/</em>.js&rsquo;: &lsquo;browserify&rsquo;
},</p>

<p>browserify: {
  debug: true,
  transform: [</p>

<pre><code>"babelify",
"espowerify"
</code></pre>

<p>  ]
},
```</p>

<p>karmaについては以前にも書いたのでそちらも。</p>

<ul>
<li><a href="http://blog.koba04.com/post/2014/06/23/karma-for-javascript-test-runner/">http://blog.koba04.com/post/2014/06/23/karma-for-javascript-test-runner/</a></li>
</ul>


<p>今回はカジュアルさを優先したので設定していませんが、travis-ciを使いたい場合は、<code>karma-phantomjs-launcher</code>を入れて<code>npm test</code>でPhantomJSで実行出来るようにすればOKだと思います。</p>

<h3>Code</h3>

<p>コードはこんな感じで書けます。</p>

<p>```js
import React from &lsquo;react&rsquo;;</p>

<p>export default class App extends React.Component {
  render() {</p>

<pre><code>return &lt;div&gt;Hello World&lt;/div&gt;;
</code></pre>

<p>  }
}
```
<a href="https://github.com/koba04/minimum-spa-boilerplate/blob/master/lib/components/app.js">https://github.com/koba04/minimum-spa-boilerplate/blob/master/lib/components/app.js</a></p>

<h3>Test</h3>

<p>テストはこんな感じ</p>

<p>```js
import assert from &lsquo;power-assert&rsquo;;
import React from &lsquo;react/addons&rsquo;;
import App from &lsquo;../../lib/components/app&rsquo;;</p>

<p>const {TestUtils} = React.addons;</p>

<p>describe(&ldquo;App&rdquo;, () => {
  let component;</p>

<p>  beforeEach(() => {</p>

<pre><code>component = TestUtils.renderIntoDocument(&lt;App /&gt;);
</code></pre>

<p>  });</p>

<p>  it(&ldquo;returns Hello World in div&rdquo;, () => {</p>

<pre><code>const div = TestUtils.findRenderedDOMComponentWithTag(component, 'div');
assert(
  React.findDOMNode(div).textContent
  ===
  'Hello World'
);
</code></pre>

<p>  });
});
```</p>

<h2>おまけ</h2>

<h3>karma-browserify + power-assert + babel</h3>

<p>npm scriptでbrowserifyとwatchifyの引数に<code>babelify</code>を指定していますが、本当は↓のようにbrowserifyのtransformフィールドにだけ指定してkarmaには<code>espowerify</code>だけを指定したいところなのですが、<code>karma-browserify</code>に指定するtransformはbrowserifyにoptionとしてそのまま渡されるのではなくて事前にtransformするので、<code>espowerify</code>が<code>babelify</code>される前のコードを対象としてしまいエラーになります&hellip;。</p>

<p>なのでここでは、それぞれに個別に設定する形になっています&hellip;。
レアケースですがなんとかしたいなぁと思いつつ&hellip;。</p>

<p>```
&ldquo;browserify&rdquo;: {
  &ldquo;transform&rdquo;: [</p>

<pre><code>["babelify"]
</code></pre>

<p>  ]
}
```</p>

<hr />

<p>そこそこカジュアルな感じになっているかなぁと思います。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React.js v0.13 changes]]></title>
    <link href="http://blog.koba04.com/post/2015/03/05/react-js-v013-changes/"/>
    <updated>2015-03-05T09:23:28+09:00</updated>
    <id>http://blog.koba04.com/post/2015/03/05/react-js-v013-changes</id>
    <content type="html"><![CDATA[<p>React.js v0.13のRC2がリリースされたのでまとめてみます。</p>

<ul>
<li><a href="http://facebook.github.io/react/blog/2015/02/24/react-v0.13-rc1.html">http://facebook.github.io/react/blog/2015/02/24/react-v0.13-rc1.html</a></li>
<li><a href="http://facebook.github.io/react/blog/2015/03/03/react-v0.13-rc2.html">http://facebook.github.io/react/blog/2015/03/03/react-v0.13-rc2.html</a></li>
<li><a href="http://facebook.github.io/react/blog/2015/02/24/streamlining-react-elements.html">http://facebook.github.io/react/blog/2015/02/24/streamlining-react-elements.html</a></li>
</ul>


<p>今回のバージョンで何か大きく変更があるというよりもv0.14でやりたいことに向けての布石が多いように感じます。</p>

<p>試すときはこの辺りから。</p>

<p><code>
npm install react@0.13.0-rc2
npm install react-tools@0.13.0-rc2
</code></p>

<p><code>
http://fb.me/react-0.13.0-rc2.js
http://fb.me/react-0.13.0-rc2.min.js
http://fb.me/react-with-addons-0.13.0-rc2.js
http://fb.me/react-with-addons-0.13.0-rc2.min.js
http://fb.me/JSXTransformer-0.13.0-rc2.js
</code></p>

<!-- more -->


<h2>Propを変更するとwarninngが出ます (Breaking Change)</h2>

<p>development環境でPropをelement作成後に変更することはdeprecatedになってwarningが出るようになりました。
つまりimmutableなものとして扱う必要があります。</p>

<p><code>js
var element = &lt;Foo bar={false} /&gt;;
if (shouldUseFoo) {
  element.props.foo = 10;
  element.props.bar = true;
}
</code></p>

<h3>これまでの問題点</h3>

<ul>
<li>Propを直接変更してしまうと元の値を破棄してしまうのでdiffがなくなってしまいます。この場合、<code>shouldComponentUpdate</code>を実装している場合に比較時に差分を検出出来なくてDOM構造に差分があるはずなのに実際には反映されない可能性がありました。</li>
<li>またPropが変更されることがあるためcreateElementの時点でPropTypesのValidationも出来ず、それによってエラー時のstacktraceが深くなったりFlowによる静的解析にとっても都合がよくなかったりという面もありました。</li>
</ul>


<h4>それに対しての提案</h4>

<ul>
<li>動的にしたい場合は↓のような形で書くことでも可能です。</li>
</ul>


<p>```js
if (shouldUseFoo) {
  return <Foo foo={10} bar={true} />;
} else {
  return <Foo bar={false} />;
}</p>

<p>var props = { bar: false };
if (shouldUseFoo) {
  props.foo = 10;
  props.bar = true;
}
return <Foo {...props} />;
```</p>

<ul>
<li>現時点ではネストしたオブジェクトについては変更してもwarningは出ません。基本的にはimmutable.jsなどを使って完全にimmutableに扱った方がいいですが、mutableなオブジェクトは多くの場面で便利だし今回はネストしたオブジェクトはwarningの対象外となりました。</li>
</ul>


<p><code>js
return &lt;Foo nestedObject={this.state.myModel} /&gt;;
</code></p>

<ul>
<li>PropTypesのwarningをReactElementの作成時に行うなうようになりました。Propを変更するために↓のようにcloneしてReactElementにPropに値を追加するのは正しい方法です。</li>
</ul>


<p><code>js
var element1 = &lt;Foo /&gt;; // extra prop is optional
var element2 = React.addons.cloneWithProps(element1, { extra: 'prop' });
</code></p>

<h2>statics内のメソッドに対してautobindingされなくなりました (Breaking Change)</h2>

<p><code>statics</code>に定義したメソッドをonClickなどにバインドした時にcomponentをバインドしなくなりました。</p>

<p>```js
var Hello = React.createClass({
  statics: {</p>

<pre><code>foo () {
  this.bar();  // v0.13では呼べない
},
bar() {
  console.log("bar");
}
</code></pre>

<p>  },
  render() {</p>

<pre><code>return &lt;div&gt;hello &lt;button onClick={Hello.foo}&gt;click&lt;/button&gt;&lt;/div&gt;;
</code></pre>

<p>  }
});
```</p>

<h2>refを設定する処理の順番が変わりました (Breaking Change)</h2>

<p><code>ref</code>に指定されたcomponentの<code>componentDidMount</code>が呼ばれた後になります。
これは親componentのcallbackを<code>componentDidMount</code>の中で読んでいる場合だけ気にする必要があります。そもそれもこれはアンチパターンなので避けるべきですが&hellip;。</p>

<ul>
<li><code>componentDidMount</code>は子componentから順番に呼ばれるので下記の<code>refDiv</code>はChildの<code>componentDidMount</code>の時点では設定されていません。</li>
</ul>


<p>```js
var Hello = React.createClass({
  foo() {</p>

<pre><code>console.log(this.refs.refDiv);
</code></pre>

<p>  },
  render() {</p>

<pre><code>return (
  &lt;div&gt;
    &lt;Child foo={this.foo} /&gt;
    &lt;div ref="refDiv"&gt;hello&lt;/div&gt;
  &lt;/div&gt;
);
</code></pre>

<p>  }
});</p>

<p>var Child = React.createClass({
  componentDidMount() {</p>

<pre><code>this.props.foo(); // v0.13 "undefined"
</code></pre>

<p>  },
  render() {</p>

<pre><code>return &lt;div&gt;child&lt;/div&gt;;
</code></pre>

<p>  }
});
```</p>

<h2><code>this.setState()</code>が第1引数に関数を受け取れるようになりました</h2>

<p><code>js
this.setState((state, props) =&gt; ({count: state.count + 1}));
</code></p>

<p>のようにすることで<code>this._pendingState</code>を使うことなくトランザクションが必要とされるstateの更新を行うことが出来ます。</p>

<p>```js
console.log(this.state.count) // 0
this.setState({ count: this.state.count + 1 })
this.setState({ count: this.state.count + 1 })
// state.count will render as 1</p>

<p>console.log(this.state.count) // 0
this.setState(function(state, props) { return { count: state.count + 1 } });
this.setState(function(state, props) { return { count: state.count + 1 } });
// state.count will render as 2
```</p>

<h2>setStateの呼び出しが常に非同期になります (Breaking Change)</h2>

<p>ライフサイクルメソッドの中での<code>setState</code>の呼び出しが常に非同期でバッチとして処理されます。以前は最初のマウント時の呼び出しは同期的に行われていました。</p>

<p><code>
componentDidMount() {
  console.log(this.state.count) // 0
  this.setState({ count: this.state.count + 1 })
  this.setState({ count: this.state.count + 1 })
  console.log(this.state.count) // v0.13 is 0 (v0.12 is 2)
}
</code></p>

<h2>setStateとforceUpdateをunmountされたcomponentに対して呼んだ時に、エラーではなくwarningが出るようになりました (Breaking Change)</h2>

<p>非同期処理の結果を<code>setState</code>して反映させるときに、<code>isMounted</code>でブロックしなくてもよくなったのはいいですね。</p>

<h2>privateなプロパティが整理されました (Breaking Change)</h2>

<p><code>this._pendingState</code>や<code>this._rootNodeID</code>などのprivateなプロパティが削除されました。</p>

<h2>ES6 classesによるReactComponentの作成がサポートされました</h2>

<p>これについては↓に書きましたが、ES6 classesによって作成されたcomponentには<code>createClass</code>にはある<code>getDOMNode</code>、<code>setProps</code>、<code>replaceState</code>が含まれていなかったりmixinが指定出来ないなど注意点がいくつかあります。</p>

<ul>
<li><a href="http://blog.koba04.com/post/2015/01/28/published-react-v0.13.0-beta1/">http://blog.koba04.com/post/2015/01/28/published-react-v0.13.0-beta1/</a></li>
</ul>


<h2><code>React.findDOMNode(component)</code>のAPIが追加されました</h2>

<p>これは既存の<code>component.getDOMNode()</code>を置き換えるAPIです。
<code>getDOMNode()</code>はES6 classesによって作成されたcomponentでは提供されていません。</p>

<h2><code>ref</code>がcallbackスタイルで指定できるようになりました。</h2>

<p><code>js
&lt;Photo ref={(c) =&gt; this._photo = c} /&gt;
</code></p>

<p>この変更はこの後で書く<code>owner</code>の扱いの変更に関係しています。</p>

<h2>childrenにiteratorやimmutable-jsのsequenceを指定出来るようになりました</h2>

<p>immutable-jsを使っている人にとってはいいですね。</p>

<h2><code>ComponentClass.type</code>はdeprecatedになりました</h2>

<p>代わりに<code>ComponentClass</code>をそのまま使ってください。</p>

<h2>ownerベースのcontextを使っていてparentベースのcontextと一致しない場合にwarningが出るようになります</h2>

<p>そもそもowner? parent?という感じかと思うので簡単に説明します。</p>

<h3>owner and parent</h3>

<p>Reactは"parent"と"owner"を持っています。"owner"はReactElementを作ったcomponentです。</p>

<p>```js
class Foo {
  render() {</p>

<pre><code>return &lt;div&gt;&lt;span /&gt;&lt;/div&gt;;
</code></pre>

<p>  }
}
```</p>

<p>この場合、<code>span</code>のownerは<code>Foo</code>でparentは<code>div</code>になります。</p>

<h3>context</h3>

<p>これはdocument化されてないfeatureですが、"owner"から子や孫に渡すことが出来る"context"というものがあります。</p>

<p>簡単にコードを書くとこんな感じです。見てもらえればどんなfeatureなのかわかるかと思います。</p>

<p>```js
var Parent = React.createClass({</p>

<pre><code>childContextTypes: {
  name: React.PropTypes.string,
  age: React.PropTypes.number
},
getChildContext: function() {
  return {
    name: "parent",
    age: 50
  };
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return &lt;Child /&gt;;
</code></pre>

<p>  }
});</p>

<p>var Child = React.createClass({</p>

<pre><code>contextTypes: {
  name: React.PropTypes.string,
  age: React.PropTypes.number
},
componentDidMount: function() {
  console.log("Child",this.context); // {name: "parent", age: 50}
},
render: function() {
  return &lt;GrandChild /&gt;;
}
</code></pre>

<p>});</p>

<p>var GrandChild = React.createClass({</p>

<pre><code>contextTypes: {
  name: React.PropTypes.string
},
componentDidMount: function() {
  console.log("GrandChild",this.context); // {name: "parent"}
},
render: function() {
  return &lt;div&gt;hello&lt;/div&gt;;
}
</code></pre>

<p>});</p>

<p>React.render(<Parent />, document.body);
```</p>

<p><code>react-router</code>ではparentベースのcontextに依存していたので対応が大変そうでした。</p>

<h3>問題点</h3>

<ul>
<li>ownerは密かにReactElementに追加されているので気づかないうちに挙動が変わることが発生します。↓の場合はそれぞれのinputのownerが異なりますし、<code>React.addons.cloneWithProps</code>を使った場合もownerが変わります。</li>
</ul>


<p>```js
var foo = <input className="foo" />;
class Component {
  render() {</p>

<pre><code>return bar ? &lt;input className="bar" /&gt; : foo;
</code></pre>

<p>  }
}
```</p>

<ul>
<li>ownerは実行時のstackによって決定します。↓の場合、<code>span</code>のonwerは実際は<code>B</code>で<code>A</code>ではありません。これはcallbackが実行されたタイミングに依存するからです。</li>
</ul>


<p>```js
class A {
  render() {</p>

<pre><code>return &lt;B renderer={text =&gt; &lt;span&gt;{text}&lt;/span&gt;} /&gt;;
</code></pre>

<p>  }
}
class B {
  render() {</p>

<pre><code>return this.props.renderer('foo');
</code></pre>

<p>  }
}
```</p>

<ul>
<li>また、JSXが書いているscope内にReactが必要なのは、Reactが現在のownerを保持していてJSXの変換がそれに依存しているからという意外なところに影響があったりもします。</li>
</ul>


<h3>それに対する提案</h3>

<ul>
<li>ownerベースのcontextの代わりにparentベースのcontextの導入を考えているのでそれを使うことです。ほとんどのケースはparentベースのcontextでも問題ないです。</li>
<li>ownerベースのcontextが必要になる場合はほとんどないはずだしコードを見直すべきです。</li>
</ul>


<h3>未解決</h3>

<ul>
<li><code>ref</code>はまだownerベースのままで、これについてはまだ完全に解決出来ていません。

<ul>
<li>v0.13ではcallbackでもrefが定義出来るようなりましたがこれまでの宣言的な定義方法も残されています。宣言的な定義方法に代わる何かいい方法がない限りこのAPIは廃止されません。</li>
</ul>
</li>
</ul>


<h2><code>{key: element}</code>(Keyed Object)の形式でchildに渡すとwarningが出るようになりました</h2>

<p>v0.12では<code>{key: element}</code>の形式でkeyが指定したらelementを渡すことが出来ましたが、これはあまり使われてないし問題となる場合があるので使うべきではないのでwarningが出るようになりました。</p>

<p>```js</p>

<div>{ {a: <span />, b: <span />} }</div>


<p>```</p>

<h3>問題点</h3>

<ul>
<li>列挙される順番はkeyに数値を指定した場合を除いては仕様として定義されてないので実装次第になってしまいます。</li>
<li>一般的にobjectをmapとして扱うことは型システムやVMの最適化やコンパイラーにとって好ましくないし、さらにセキュリティ上のリスクもあって↓のような場合にもし<code>item.title === '__proto__'</code> を指定されたら&hellip;.</li>
</ul>


<p><code>js
var children = {};
items.forEach(item =&gt; children[item.title] = &lt;span /&gt;);
return &lt;div&gt;{children}&lt;/div&gt;;
</code></p>

<h3>それに対する解決</h3>

<ul>
<li>ほとんどの場合、<code>key</code>を設定したReactElementの配列にすれば問題ないはずです。</li>
</ul>


<p>```js
var children = items.map(item => <span key={item.title} />);</p>

<div>{children}</div>


<p>```</p>

<ul>
<li><code>this.props.children</code>を使った場合など、<code>key</code>を指定することが出来ない場合もあるかもしれません。その場合はv0.13で追加された<code>React.addons.createFragment</code>を使うことでKeyed ObjectからReactElementを作成することが出来ます。

<ul>
<li>注意として、これはまだrenderの戻り値として直接渡せるものではないので<div>などでラップしてあげる必要があります。</li>
</ul>
</li>
</ul>


<p>```js</p>

<p><div>{React.addons.createFragment({ a: <div />, b: this.props.children })}</div>
```</p>

<h2><code>React.cloneElement</code>が追加されました</h2>

<p>これはこれまで<code>React.addons.cloneWithProps</code>と似たAPIです。
異なる点としては、<code>style</code>や<code>className</code>のmergeが行われなかったり<code>ref</code>が保持される点があります。
<code>cloneWithProps</code>を使ってchildrenを複製した時に<code>ref</code>が保持されなくて問題となるという報告が多くあったのでこのAPIでは<code>ref</code>を保持するようになりました。
<code>cloneElement</code>時に<code>ref</code>を指定すると上書きされます。</p>

<p><code>js
var newChildren = React.Children.map(this.props.children, function(child) {
  return React.cloneElement(child, { foo: true })
});
</code></p>

<p>このAPIはv0.13でPropがimmutableなものとして扱われるようになったことで、Propを変更するためにelementをcloneする機会が増えたため必要となりました。
<code>React.addons.cloneWithProps</code>はそのうちdeprecateになりますが今回のタイミングではなりません。</p>

<h2><code>React.addons.classSet</code>がdeprecatedになりました</h2>

<p>必要な場合は<a href="https://www.npmjs.com/package/classnames">classnames</a>などを使用してください。</p>

<h2>jsxコマンドで<code>--target</code>optionとしてECMAScript versionを指定出来るようになりました。 (Breaking Change)</h2>

<p><code>es5</code>がデフォルトです。
<code>es3</code>はこれまでの挙動ですが追加で予約語を安全に扱うようになりました(eg <code>this.static</code>は<code>this['static']</code>にIE8での互換性のために変換されます)。</p>

<h2>jsxコマンドでES6 syntaxで変換した際にclassメソッドがdefaultではenumerableではなくなりました</h2>

<p><code>Object.defineProperty</code>を使用しているため、IE8などをサポートしたい場合は<code>--target es3</code>optionを渡す必要があります。</p>

<ul>
<li>Original</li>
</ul>


<p>```js
class Hello extends React.Component {
  foo() {</p>

<pre><code>console.log("foo");
</code></pre>

<p>  }
  render() {</p>

<pre><code>return &lt;div&gt;hello&lt;/div&gt;;
</code></pre>

<p>  }
}
Hello.static = {
  bar() {</p>

<pre><code>console.log("bar");
</code></pre>

<p>  }
};
```</p>

<ul>
<li>ES5</li>
</ul>


<p>```js
var <strong><strong>Class0=React.Component;for(var </strong></strong>Class0<strong><strong>Key in </strong></strong>Class0){if(<strong><strong>Class0.hasOwnProperty(</strong></strong>Class0<strong><strong>Key)){Hello[</strong></strong>Class0<strong><strong>Key]=</strong></strong>Class0[<strong><strong>Class0</strong></strong>Key];}}var <strong><strong>SuperProtoOf</strong></strong>Class0=<strong><strong>Class0===null?null:</strong></strong>Class0.prototype;Hello.prototype=Object.create(<strong><strong>SuperProtoOf</strong></strong>Class0);Hello.prototype.constructor=Hello;Hello.<strong>superConstructor</strong>=<strong><strong>Class0;function Hello(){&ldquo;use strict&rdquo;;if(</strong></strong>Class0!==null){____Class0.apply(this,arguments);}}
  Object.defineProperty(Hello.prototype,&ldquo;foo&rdquo;,{writable:true,configurable:true,value:function() {&ldquo;use strict&rdquo;;</p>

<pre><code>console.log("foo");
</code></pre>

<p>  }});
  Object.defineProperty(Hello.prototype,&ldquo;render&rdquo;,{writable:true,configurable:true,value:function() {&ldquo;use strict&rdquo;;</p>

<pre><code>return React.createElement("div", null, "hello");
</code></pre>

<p>  }});</p>

<p>Hello.static = {
  bar:function() {</p>

<pre><code>console.log("bar");
</code></pre>

<p>  }
};
```</p>

<ul>
<li>ES3</li>
</ul>


<p>```js
var <strong><strong>Class0=React.Component;for(var </strong></strong>Class0<strong><strong>Key in </strong></strong>Class0){if(<strong><strong>Class0.hasOwnProperty(</strong></strong>Class0<strong><strong>Key)){Hello[</strong></strong>Class0<strong><strong>Key]=</strong></strong>Class0[<strong><strong>Class0</strong></strong>Key];}}var <strong><strong>SuperProtoOf</strong></strong>Class0=<strong><strong>Class0===null?null:</strong></strong>Class0.prototype;Hello.prototype=Object.create(<strong><strong>SuperProtoOf</strong></strong>Class0);Hello.prototype.constructor=Hello;Hello.<strong>superConstructor</strong>=<strong><strong>Class0;function Hello(){&ldquo;use strict&rdquo;;if(</strong></strong>Class0!==null){____Class0.apply(this,arguments);}}
  Hello.prototype.foo=function() {&ldquo;use strict&rdquo;;</p>

<pre><code>console.log("foo");
</code></pre>

<p>  };
  Hello.prototype.render=function() {&ldquo;use strict&rdquo;;</p>

<pre><code>return React.createElement("div", null, "hello");
</code></pre>

<p>  };</p>

<p>Hello[&ldquo;static&rdquo;] = {
  bar:function() {</p>

<pre><code>console.log("bar");
</code></pre>

<p>  }
};
```</p>

<h2>JSXによる変換でharmony optionを有効にすることでspread operatorを使えるようになりました</h2>

<p>JSXの中ではこれまでもspread attributesとしてサポートしていましたが、JSのコード内でも使えるようになりました。</p>

<p><code>js
var [a, b, ...other] = [1,2,3,4,5];
</code></p>

<h2>JSXのparseに変更があります (Breaking Change)</h2>

<p>elementの内側に<code>&gt;</code> or <code>}</code> を使った時に以前は文字列として扱われましたがparseエラーになるようになりました。</p>

<p><code>js
render() {
  return &lt;div&gt;} or &gt;&lt;/div&gt;; // parse error!
}
</code></p>

<h2>v0.14に向けて</h2>

<p>今回の変更を踏まえてReact v0.14では静的な要素においていくつかの最適化が可能になります。
これらの最適化は以前はtemplate-baseなフレームワークでのみ可能でしたが、ReactでもJSXと<code>React.createElement/Factory</code>のどちらでも可能になります。</p>

<p>詳細は下記のissueにあります。
まだ議論もされてないので変わる可能性は大きいと思いますが。</p>

<h3>Reuse Constant Value Types</h3>

<ul>
<li><a href="https://github.com/facebook/react/issues/3226">https://github.com/facebook/react/issues/3226</a></li>
</ul>


<p>これは静的なelementに変更できないものとして扱うことでdiffのコストを減らすというものです。</p>

<p>例えばこんな感じにするとか</p>

<p><code>js
function render() {
   return &lt;div className="foo" /&gt;;
}
↓
var foo = &lt;div className="foo" /&gt;;
function render() {
   return foo;
}
</code></p>

<h3>Tagging ReactElements</h3>

<ul>
<li><a href="https://github.com/facebook/react/issues/3227">https://github.com/facebook/react/issues/3227</a></li>
</ul>


<p>これはReactElementにtag付けをしてそれを使ってdiffアルゴリズムを最適化するというもののようです。</p>

<h3>Inline ReactElements</h3>

<ul>
<li><a href="https://github.com/facebook/react/issues/3228">https://github.com/facebook/react/issues/3228</a></li>
</ul>


<p>これはproductionビルドのときに、React.createElementではなくてinline objectに変換することでReact.createElementのコストを削減するというものです。</p>

<p>こんな感じ</p>

<p><code>js
&lt;div className="foo"&gt;{bar}&lt;Baz key="baz" /&gt;&lt;/div&gt;
↓
{ type: 'div', props: { className: 'foo', children:
  [ bar, { type: Baz, props: { }, key: 'baz', ref: null } ]
}, key: null, ref: null }
</code></p>

<p>こうするとReact.createElementの時に行っているPropTypesやkeyに対するvalidationが出来ないので、developmentビルドの時には適用しないことを想定しているようです。</p>

<hr />

<p>というわけで、React v0.13をダラダラと書いてみました。</p>
]]></content>
  </entry>
  
</feed>

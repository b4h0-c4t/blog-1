<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: react.js | blog.koba04.com]]></title>
  <link href="http://blog.koba04.com/blog/categories/react-dot-js/atom.xml" rel="self"/>
  <link href="http://blog.koba04.com/"/>
  <updated>2017-10-01T23:18:53+09:00</updated>
  <id>http://blog.koba04.com/</id>
  <author>
    <name><![CDATA[koba04]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[React v16でのサーバーサイドレンダリング]]></title>
    <link href="http://blog.koba04.com/post/2017/10/01/serverside-rendering-in-react-v16/"/>
    <updated>2017-10-01T23:02:46+09:00</updated>
    <id>http://blog.koba04.com/post/2017/10/01/serverside-rendering-in-react-v16</id>
    <content type="html"><![CDATA[<p>React v16について書いたブログの中の、サーバーサイドレンダリングについての部分に間違いがあったので修正しつつ、v16のサーバーサイドレンダリングについて補足します。</p>

<p><a href="http://blog.koba04.com/post/2017/09/27/react-v16-changes/">http://blog.koba04.com/post/2017/09/27/react-v16-changes/</a></p>

<p><strong>Hydrationしたい場合は、renderToStringまたはrenderToNodeStreamで行う必要があります。</strong></p>

<p>renderToStringまたはrenderToNodeStreamには、<code>data-reactroot</code>以外にも変数部分を識別するためのコメントノードなどが挿入されていて、それが必要であるためです。</p>

<p>それでは、v15とv16でのサーバーサイドレンダリングの違いを見てみます。</p>

<!-- more -->


<p>以下、長いのでサーバーサイドレンダリングはSSRと略します。</p>

<h2>v15まで</h2>

<p>ReactでSSRしたコンテンツをクライアントでも再利用したい場合、これまではSSRしたHTMLを元に生成されたchecksumとクライアントサイドで構築したReactElementから生成したchecksumが一致する必要がありました。</p>

<p>これはつまり、ReactDOMServer.renderToStringのエントリーポイントと、ReactDOM.renderのエントリーポイントが一致する必要があることを示します。</p>

<p>つまりHTML全体をReactで構築しようとするとこんな感じになります。</p>

<ul>
<li>App.js</li>
</ul>


<p>```js
import React from &lsquo;react&rsquo;;
const App = (props) => {</p>

<pre><code>return &lt;div&gt;Hello {props.name}&lt;/div&gt;;
</code></pre>

<p>};
export default App;
```</p>

<ul>
<li>Html.js</li>
</ul>


<p>```js
import React from &lsquo;react&rsquo;;</p>

<p>const Html = (props) => {</p>

<pre><code>return (
    &lt;html&gt;
        &lt;head&gt;
            &lt;title&gt;App&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;div id="app" dangerouslySetInnerHTML={ {__html: props.markup} }&gt;&lt;/div&gt;
            &lt;script id="initial-data" type="text/plain" data-json={props.initialData}&gt;&lt;/script&gt;
            &lt;script src="http://blog.koba04.com/static/bundle.js"&gt;&lt;/script&gt;
        &lt;/body&gt;
    &lt;/html&gt;
);
</code></pre>

<p>};</p>

<p>export default Html;
```</p>

<ul>
<li>server.js</li>
</ul>


<p>```js
import React from &lsquo;react&rsquo;;
import ReactDOMServer from &lsquo;react-dom/server&rsquo;;
import express from &lsquo;express&rsquo;;</p>

<p>import Html from &lsquo;./Html&rsquo;;
import App from &lsquo;./App&rsquo;;</p>

<p>const app = express();</p>

<p>const initialData = {</p>

<pre><code>name: 'World'
</code></pre>

<p>};</p>

<p>app.get(&lsquo;/&rsquo;, (req, res) => {</p>

<pre><code>res.send(
    ReactDOMServer.renderToStaticMarkup(
        &lt;Html
            markup={ReactDOMServer.renderToString(&lt;App {...initialData} /&gt;)}
            initialData={JSON.stringify(initialData)}
        /&gt;
    )
);
</code></pre>

<p>});</p>

<p>app.listen(3000);
```</p>

<ul>
<li>browser.js</li>
</ul>


<p>```js
import React from &lsquo;react&rsquo;;
import ReactDOM from &lsquo;react-dom&rsquo;;
import App from &lsquo;./App&rsquo;;</p>

<p>const initialData = JSON.parse(document.getElementById(&lsquo;initial-data&rsquo;).getAttribute(&lsquo;data-json&rsquo;));</p>

<p>ReactDOM.render(<App {...initialData} />, document.getElementById(&lsquo;app&rsquo;));
```</p>

<p>上記のように<code>Html.js</code>ではdangerouslySetInnerHTMLを使い、アプリケーションのComponentをrenderToStringによりchecksumなどが付与されたHTML文字列として埋め込む必要があります。</p>

<p>また<code>server.js</code>では、HTML全体の部分はrenderToStaticMarkupで、アプリケーションの部分はrenderToStringでと、別々に生成する必要があります。</p>

<p>これにより、renderToStringとReactDOM.renderで構築される内容が一致するため、SSRによって生成されたDOMが再利用されます。</p>

<h2>v16</h2>

<p>v16では、checksumによりチェックは行われず、可能な限りすでに構築されているDOMを再利用しようとします。
また、ReactDOM.hydrateという明示的なAPIを使うことで、サーバー側とクライアント側でエントリーポイントを合わせる必要はありません。
（ReactDOM.renderを使う場合は、<code>data-reactroot</code>の属性がDOMにあるかをチェックしているのでエントリーポイントを合わせる必要があります）</p>

<p>そのためv15のように、エントリーポイントを一致させるために、アプリケーションのComponentを別途HTML文字列として生成する必要はありません。</p>

<p>したがって、上記の例は、v16で追加されたrenderToNodeStreamを使うと</p>

<ul>
<li>App.js</li>
</ul>


<p>```js
import React from &lsquo;react&rsquo;;
const App = (props) => {</p>

<pre><code>return &lt;div&gt;Hello {props.name}&lt;/div&gt;;
</code></pre>

<p>};
export default App;
```</p>

<ul>
<li>Html.js</li>
</ul>


<p>```js
import React from &lsquo;react&rsquo;;</p>

<p>const Html = (props) => {</p>

<pre><code>return (
    &lt;html&gt;
        &lt;head&gt;
            &lt;title&gt;App&lt;/title&gt;
        &lt;/head&gt;
        &lt;body&gt;
            &lt;div id="app"&gt;{props.children}&lt;/div&gt;
            &lt;script id="initial-data" type="text/plain" data-json={props.initialData}&gt;&lt;/script&gt;
            &lt;script src="http://blog.koba04.com/static/bundle.js"&gt;&lt;/script&gt;
        &lt;/body&gt;
    &lt;/html&gt;
);
</code></pre>

<p>};</p>

<p>export default Html;
```</p>

<ul>
<li>server.js</li>
</ul>


<p>```js
import React from &lsquo;react&rsquo;;
import ReactDOMServer from &lsquo;react-dom/server&rsquo;;
import express from &lsquo;express&rsquo;;</p>

<p>import Html from &lsquo;./Html&rsquo;;
import App from &lsquo;./App&rsquo;;</p>

<p>const app = express();</p>

<p>const initialData = {</p>

<pre><code>name: 'World'
</code></pre>

<p>};</p>

<p>app.get(&lsquo;/&rsquo;, (req, res) => {</p>

<pre><code>ReactDOMServer.renderToNodeStream(
    &lt;Html initialData={JSON.stringify(initialData)}&gt;
        &lt;App {...initialData} /&gt;
    &lt;/Html&gt;
).pipe(res);
</code></pre>

<p>});</p>

<p>app.listen(3000);
```</p>

<ul>
<li>browser.js</li>
</ul>


<p>```js
import React from &lsquo;react&rsquo;;
import ReactDOM from &lsquo;react-dom&rsquo;;
import App from &lsquo;./App&rsquo;;</p>

<p>const initialData = JSON.parse(document.getElementById(&lsquo;initial-data&rsquo;).getAttribute(&lsquo;data-json&rsquo;));</p>

<p>ReactDOM.hydrate(<App {...initialData} />, document.getElementById(&lsquo;app&rsquo;));
```</p>

<p>上記ではHtmlのComponent内で、アプリケーションのComponentを、ReactDOM.hydrateの対象となるDOMの子要素として渡しているだけです。
HTML文字列として渡したりする必要はありません。</p>

<p>また全体もrenderToNodeStreamでまとめて構築できるため、コードもシンプルになります。</p>

<p>というわけで、v16ではSSRのコードもよりシンプルに書けるように効率的になっています。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React v16 changes]]></title>
    <link href="http://blog.koba04.com/post/2017/09/27/react-v16-changes/"/>
    <updated>2017-09-27T16:34:07+09:00</updated>
    <id>http://blog.koba04.com/post/2017/09/27/react-v16-changes</id>
    <content type="html"><![CDATA[<p>Reactのv16がリリースされたので、変更点などを整理したいと思います。</p>

<ul>
<li><a href="https://facebook.github.io/react/blog/2017/09/26/react-v16.0.html">https://facebook.github.io/react/blog/2017/09/26/react-v16.0.html</a></li>
<li><a href="https://code.facebook.com/posts/1716776591680069/react-16-a-look-inside-an-api-compatible-rewrite-of-our-frontend-ui-library/">https://code.facebook.com/posts/1716776591680069/react-16-a-look-inside-an-api-compatible-rewrite-of-our-frontend-ui-library/</a></li>
</ul>


<p>React v16やReact Fiberについては、下記で書いたりもしているのでそちらも参考にしてみてください。</p>

<ul>
<li><a href="http://blog.koba04.com/post/2017/04/25/a-state-of-react-fiber/">React Fiber現状確認</a></li>
<li><a href="https://speakerdeck.com/koba04/capability-of-react-fiber">Capability of React Fiber</a></li>
<li><a href="https://speakerdeck.com/koba04/react-v16-and-beyond-react-fiber">React v16 and beyond React Fiber</a></li>
<li><a href="https://html5experts.jp/shumpei-shiraishi/23265/">ReactはなぜFiberで書き直されたのか？Reactの課題と将来像を探る</a></li>
</ul>


<!-- more -->


<h2>新機能</h2>

<h3>render関数から文字列や配列を直接返せるように</h3>

<p>地味に嬉しい機能ですね。これまでは無駄にspanやdivで囲むしかなかったのが、直接文字列や配列を返すことができるようになります。</p>

<p><code>``js
// 文字列を直接返す
const DisplayName = ({user}) =&gt;</code>${user.name} (@${user.id})`;</p>

<p>// 配列
const Row = ({children}) => <tr>{children}</tr>;
const Columns = ({items}) => (
  items.map((item, id) => <td key={i}>{item}</td>)
);
<Row></p>

<pre><code>&lt;Columns items={['foo', 'bar', 'baz']} /&gt;
</code></pre>

<p></Row>
```</p>

<p>配列を返す場合は、<code>key</code>を必ずつける必要があります。
それをJSXのSyntaxレベルでサポートするという議論もあったりします。</p>

<ul>
<li><a href="https://github.com/facebook/jsx/issues/84">https://github.com/facebook/jsx/issues/84</a></li>
</ul>


<p>```js
[</p>

<pre><code>&lt;li key={1}&gt;foo&lt;/li&gt;,
&lt;li key={2}&gt;bar&lt;/li&gt;,
&lt;li key={3}&gt;baz&lt;/li&gt;,
</code></pre>

<p>]</p>

<p>↓↓↓</p>

<p>// こんな感じで書けるようにしたいという議論
&lt;>
  <li>foo</li>
  <li>bar</li>
  <li>baz</li>
</>
```</p>

<h3>Error Boundaries</h3>

<p>子のComponentのrender関数やライフサイクルメソッドで起きたエラーを、<code>componentDidCatch</code>というライフサイクルメソッドでキャッチできるようになります。
これによって、エラーが起きたことをユーザーに伝えたり、エラーリポートのサービスに送信できるようになります。</p>

<p>```js
class Child extends React.Component {</p>

<pre><code>componentDidMount() {
    // 〜 is not a functionみたいなエラーでも同様
    throw new Error('Something went wrong!!');
}
render() {
  return &lt;p&gt;Child!&lt;/p&gt;;
}
</code></pre>

<p>}</p>

<p>class App extends React.Component {
  constructor(props) {</p>

<pre><code>super(props);
this.state = {
  error: null
};
</code></pre>

<p>  }
  componentDidCatch(error, info) {</p>

<pre><code>this.setState({error});
console.log(error.message, info.componentStack);
// Something went wrong!! 
// in Child (created by App)
// in section (created by App)
// in App
</code></pre>

<p>  }
  render() {</p>

<pre><code>return (
  &lt;section&gt;
    {this.state.error ? &lt;p&gt;エラーが発生しました&lt;/p&gt; : &lt;Child /&gt;}
  &lt;/section&gt;
);
</code></pre>

<p>  }
}
```</p>

<p>上記のように、componentDidCatchの引数には、Errorオブジェクト以外に<code>info</code>というオブジェクトを受け取ります。infoは今のところ<code>componentStack</code>のプロパティしか持っていません。<code>componentStack</code>には、Compnentのスタックトレースが文字列で入っています。したがって、これをエラーと一緒に送信すると、どこのComponentでどのエラーが発生したのかがわかります。</p>

<p><strong>Error Boundariesの対象になるのは、render関数とライフサイクルメソッドの中のエラーだけです。</strong>なので、イベントハンドラーの中で起きたエラーや、ライフサイクルメソッドの中での非同期処理（HTTP Requestなど)で起きたエラーは対象になりません。</p>

<p>また、もう一点、上記のError Boundariesの対象となるエラーに対する扱いが変更されています。</p>

<p>v15までは、エラーが発生したらそこで処理が中断されていました。したがって、途中のComponentのrenderで処理が止まるなど、不整合なViewをユーザーに見せてしまう可能性がありました。</p>

<p>v16では、エラーが発生すると、ReactDOM.renderで指定したRoot Containerから全てアンマウント（DOMから削除）されるようになります。
それを避けたい場合には、上記の例のようにcomponentDidCatchを定義してsetStateするなどしてエラー用の表示を行う必要があります。
なので、親のComponentでcomponentDidCatchを定義したり、componentDidCatchを定義したComponentでアプリケーション全体のComponentをラップしておくと安心かと思います。</p>

<h3>Portals</h3>

<p><code>ReactDOM.createPortal</code>というAPIが追加されました。</p>

<ul>
<li><a href="https://facebook.github.io/react/docs/portals.html">https://facebook.github.io/react/docs/portals.html</a></li>
</ul>


<p>これは、Componentツリーの外側に対するrenderをComponentツリーの一部として扱えるようにする機能です。
文字だけで書くとわかりにくいので例として、どこかアプリケーションの外側にモーダル用のDOMがあって、アプリケーションのStateによってモーダルを表示したい場合を考えてみます。</p>

<p>Portalを使わずに書くと、</p>

<p>```js
class App extends React.Component {</p>

<pre><code>componentDidUpdate() {
    const container = document.querySelector('.modal-container');
    if (this.state.modal) {
        ReactDOM.render(
            &lt;Modal
                type={this.state.modal}
                onClose={() =&gt; {
                    this.setState(
                        () =&gt; ({modal: null}),
                        () =&gt; ReactDOM.unmountComponentAtNode(container)
                    )
                }}
            &gt;
        );
    }
}
render() {
    // ....
}
</code></pre>

<p>}
```</p>

<p>とcomponentDidUpdateやcomponentDidMountのライフサイクルメソッドの中で扱う形になりますが、Portalを使うと、</p>

<p>```js
class App extends React.Component {</p>

<pre><code>render() {
    &lt;section&gt;
        &lt;Contents /&gt;
        {this.state.modal &amp;&amp; ReactDOM.createPortal(
            &lt;Modal
                type={this.state.modal}
                onClose={() =&gt; {
                    this.setState(() =&gt; ({modal: null}))
                }}
            /&gt;,
            document.querySelector('.modal-container')
        )}
    &lt;/section&gt;
}
</code></pre>

<p>}
```</p>

<p>というように、render関数の中に書くことが出来ます。
この場合Modalは、Contentsの隣に配置されたComponentと同様に処理されます。</p>

<p>なので、</p>

<p>```js
<section></p>

<pre><code>&lt;div onClick={() =&gt; console.log('click')}&gt;
    {ReactDOM.createPortal(
        &lt;p&gt;Portal&lt;/p&gt;,
        document.querySelector('.somewhere')
    )}
&lt;/div&gt;
</code></pre>

<p></section>
```</p>

<p>とあった場合、<code>&lt;p&gt;Portal&lt;/p&gt;</code>をクリックした場合にも、<code>cosole.log('click')</code>が呼ばれます。</p>

<h3>ServerSide Rendering</h3>

<p>サーバーサイドレンダリングは完全にリライトされました（既存の実装をベースに）。
これまでは、クライアントでのDOM構築と同じ流れでHTMLを構築していたのですが、下記の1ファイルに切り離されました。</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/shared/server/ReactPartialRenderer.js">https://github.com/facebook/react/blob/master/src/renderers/shared/server/ReactPartialRenderer.js</a></li>
</ul>


<p>これにより、無駄な処理が減ったことによる高速化やStreamサポートが簡単に行えるようになりました。
また、独立したファイルになったことで、今後のパフォーマンスチューニングもやりやすくなったと思います。</p>

<p>その他サーバーサイドレンダリングに対する変更は、Node Stream対応のAPIの追加とHydarationの方法の変更です。</p>

<p>Node Streamの対応については、<code>renderToNodeStream</code>と<code>renderToStaticNodeStream</code>のAPIが追加されたので、それを使うだけです。</p>

<p>```js
import ReactDOMServer from &lsquo;react-dom/server&rsquo;;</p>

<p>const App = () => (</p>

<pre><code>&lt;div&gt;
    &lt;p&gt;Hello Stream&lt;/p&gt;
&lt;/div&gt;
</code></pre>

<p>);</p>

<p>ReactDOMServer.renderToNodeStream(<App />).pipe(process.stdin);
// <div data-reactroot=""><p>Hello Stream!</p></div></p>

<p>ReactDOM.server.renderToStaticNodeStream(<App />).pipe(process.stdin);
// <div><p>Hello Stream!</p></div>
```</p>

<p>Hydrationの方法の変更については、クライアント側の変更とバリデーションロジックの変更があります。</p>

<p>ここでいうHydrationとは、サーバーサイドレンダリングで返したHTMLが生成したDOM要素を、クライアント側でのレンダリング時に再利用することを指します。</p>

<p>クライアント側でのAPIの変更については、ReactDOM.renderの代わりに<code>ReactDOM.hydrate</code>という専用のAPIを使うようになります。
v16の段階では、ReactDOM.renderによるHydrationもサポートされますが、将来的に廃止される予定です。</p>

<p><del>ちなみに、renderToNodeStreamとrenderToStaticNodeStreamによる出力の違いは、Rootの要素に<code>data-reactroot</code>があるかないかの違いだけです。このdata-reactrootはReactDOM.renderでHydrationするかどうかの判定に使われているだけです。
なので、将来的にはどちらか1つのAPIだけになると思います。ReactDOM.hydrateを使う場合は、renderToStaticNodeStreamで生成したHTMLに対してもHydration出来ます。</del></p>

<hr />

<p><strong>[2017/10/01:訂正]</strong></p>

<p>renderToNodeStreamとrenderToStaticNodeStreamによる出力の違いは、Rootの要素に<code>data-reactroot</code>以外にも、変数部分を識別するためのコメントノードの差し込みがあります。
したがって、Hydrationする場合にはrenderToNodeStreamを、それ以外の場合はrenderToStaticNodeStreamという使い分けになります。</p>

<hr />

<p>Hydrationの方法については、v15まではrenderToStringで生成したHTMLの<code>data-react-check-sum</code>という属性につけられたチェックサムを使い、クライアント側で生成したReactElementの構造が一致するかどうか判定し、一致すればDOMを再利用して一致しなければDOMを再構築する方法を採用していました。</p>

<p>v16では、サーバーサイドレンダリングで構築したDOMを、React.hydrateの際に可能な限り再利用しようとします。
ReactElementの構造が一致するかどうかの確認が、ReactElementの単位で行われるようになります。
（一致しない場合は、引き続きwarningが出力されます）
ただし、バリデーションするというよりも可能な限り再利用する方針であるため、サーバーサイドレンダリングした内容とのdiff次第では、意図しない結果となる場合があります。</p>

<ul>
<li><a href="https://github.com/facebook/react/issues/10591">https://github.com/facebook/react/issues/10591</a></li>
</ul>


<p>サーバーサイドレンダリングで意図的に異なるコンテンツを返している場合は、一度DOMをリセットする方がいいかもしれません。</p>

<p>これにより、<code>data-react-check-sum</code>だけでなく、<code>react-text</code>のコメントや<code>data-react-id</code>もHTMLに付加されなりました。</p>

<p>サーバーサイドレンダリングについては、補足記事書きました。</p>

<ul>
<li><a href="http://blog.koba04.com/post/2017/10/01/serverside-rendering-in-react-v16/">http://blog.koba04.com/post/2017/10/01/serverside-rendering-in-react-v16/</a></li>
</ul>


<h3>DOM Attributes</h3>

<p>これまでは、ホワイトリストで管理された属性以外は、warningを出しつつDOMには反映されなかったのですが、v16からは反映されるようになります。
これにより、ng-xxとかv-xxみたいな属性や、一部ブラウザーが実装しているけどまだ標準化されていないような属性値も使えるようになります。
ただし、on〜といった属性値については、セキュリティ的なリスクから反映されません。</p>

<p>また、属性が期待している型とは異なる値を渡した場合に、値が反映されなくなります。
例えばclassNameにfalseを渡した場合は、v15までは"false"という文字列がクラス名と設定されていましたが、v16からはwarningが出て反映されなくなります。</p>

<p>詳細は、下のブログに。</p>

<ul>
<li><a href="https://facebook.github.io/react/blog/2017/09/08/dom-attributes-in-react-16.html">https://facebook.github.io/react/blog/2017/09/08/dom-attributes-in-react-16.html</a></li>
</ul>


<h3>Bundle Size</h3>

<p>Browserifyを使ったビルドからRollupを使ったビルドに変更されて、フラットバンドルになりました。
Rollupを使って1つのモジュールとしてビルドすることで、Browserifyが付加する依存関係解決のためのコードが不要になります。
その結果、ファイルサイズの削減やブラウザー上での初回読み込みの時間が短縮されます。</p>

<p>reactとreact-domのv16をnpmからインストールすると、下記のような構造になっており、内部モジュールの構造は維持されていません。</p>

<ul>
<li>react</li>
</ul>


<p>```
node_modules/react/
├── LICENSE
├── README.md
├── cjs
│   ├── react.development.js
│   └── react.production.min.js
├── index.js
├── node_modules
├── package.json
└── umd</p>

<pre><code>├── react.development.js
└── react.production.min.js
</code></pre>

<p>```</p>

<ul>
<li>react-dom</li>
</ul>


<p><code>
node_modules/react-dom/
├── LICENSE
├── README.md
├── cjs
│   ├── react-dom-server.browser.development.js
│   ├── react-dom-server.browser.production.min.js
│   ├── react-dom-server.node.development.js
│   ├── react-dom-server.node.production.min.js
│   ├── react-dom-test-utils.development.js
│   ├── react-dom-unstable-native-dependencies.development.js
│   ├── react-dom-unstable-native-dependencies.production.min.js
│   ├── react-dom.development.js
│   └── react-dom.production.min.js
├── index.js
├── node_modules
├── package.json
├── server.browser.js
├── server.js
├── test-utils.js
├── umd
│   ├── react-dom-server.browser.development.js
│   ├── react-dom-server.browser.production.min.js
│   ├── react-dom-unstable-native-dependencies.development.js
│   ├── react-dom-unstable-native-dependencies.production.min.js
│   ├── react-dom.development.js
│   └── react-dom.production.min.js
└── unstable-native-dependencies.js
</code></p>

<p>上記の<code>cjs</code>がcommonJSのビルドが入っているディレクトリです。<code>〜.development.js</code>と<code>〜.production.min.js</code>があるのは本番用のビルドと開発用のビルドを分けるためです。
この分岐はindex.jsの中で<code>process.env.NODE_ENV</code>によって行われています。</p>

<ul>
<li><code>node_modules/react/index.js</code></li>
</ul>


<p>```js
&lsquo;use strict&rsquo;;</p>

<p>if (process.env.NODE_ENV === &lsquo;production&rsquo;) {
  module.exports = require(&lsquo;./cjs/react.production.min.js&rsquo;);
} else {
  module.exports = require(&lsquo;./cjs/react.development.js&rsquo;);
}
```</p>

<p>これにより、Direct importと言われている<code>react/lib/xxx</code>のような形での内部モジュール参照が出来なくなります。これは、主にカスタムレンダラーの実装や内部の挙動を変更させるために行われており、そういったライブラリーを使っている場合には注意が必要です。</p>

<p>ちなみに、下記をwebpackとBabel(es2015とreactのprest)でビルドして、比較してみるとこんな感じでした。</p>

<p>```js
import React from &lsquo;react&rsquo;;
import ReactDOM from &lsquo;react-dom&rsquo;;</p>

<p>const App = () => <div>Hello</div>;</p>

<p>ReactDOM.render(<App />, document.getElementById(&lsquo;app&rsquo;));
```</p>

<ul>
<li>v15.6.2</li>
</ul>


<p><code>
bundle.js  742 kB
bundle.js  151 kB // with `-p` option
</code></p>

<ul>
<li>16.0.0</li>
</ul>


<p><code>
bundle.js  794 kB
bundle.js  117 kB // with `-p` option
</code></p>

<p>production buildは小さくなってますね。</p>

<p>また、UMDビルドのディレクトリ名とファイル名が変更になっているので、CDNから利用する場合などは注意してください。</p>

<h3>License</h3>

<p>ライセンスがBSD + PATENTSからMITになりました。</p>

<ul>
<li><a href="https://code.facebook.com/posts/300798627056246/relicensing-react-jest-flow-and-immutable-js/">https://code.facebook.com/posts/300798627056246/relicensing-react-jest-flow-and-immutable-js/</a></li>
</ul>


<h3>Addons</h3>

<p>v15.5の時点で、廃止するアナウンスが出ていましたが、<code>react-addons-xxx</code>のパッケージは廃止になります。
基本的には、別パッケージになったりしているので使っているものがあれば下記で移行パスを確認してみてください。</p>

<ul>
<li><a href="https://facebook.github.io/react/blog/2017/04/07/react-v15.5.0.html#discontinuing-support-for-react-addons">https://facebook.github.io/react/blog/2017/04/07/react-v15.5.0.html#discontinuing-support-for-react-addons</a></li>
</ul>


<p>react-addons-perfに関しては、<code>?react_perf</code>をURLにつけてBrowserのPerformanceのTimelineで計測する方法になります。</p>

<ul>
<li><a href="https://facebook.github.io/react/docs/optimizing-performance.html#profiling-components-with-the-chrome-performance-tab">https://facebook.github.io/react/docs/optimizing-performance.html#profiling-components-with-the-chrome-performance-tab</a></li>
</ul>


<p>react-with-addons.jsのようなUMDビルドももう提供されません。</p>

<h2>Breaking Changes</h2>

<p>React Fiberに実装が変わったことによる、処理順の変更などが多いです。</p>

<ul>
<li>ReactDOM.renderとReactDOM.unstable_renderIntoContainerをライフサイクルメソッドの中で読んだ場合にはnullが返るようになります。</li>
<li>setStateでnullを渡した場合、更新処理が行われなくなります。</li>
<li>renderの中でのsetStateは常に更新処理が行われるようになります（以前はされない場合があったらしい）。そもそもrenderの中でsetStateを呼び出すべきではないですが。</li>
<li>setStateの第2引数のコールバックはcomponentDidMountとcomponentDidUpdateの後すぐに呼び出されるようになります。以前は全てのComponentがrenderされた後に呼び出されていました。 <strong>???以前のバージョンの挙動が確認できなかった</strong></li>
<li><code>&lt;A /&gt;</code>から<code>&lt;B /&gt;</code>に置き換えたとき、B.componentWillMountが常にA.componentWillUnmountの前に呼ばれるようになります。</li>
<li>以前は、refを更新する際のデタッチ(nullでの呼び出し)はComponentのrender関数の前に呼ばれていましたが、render関数の後に変更になります。</li>
<li>React以外によって、編集されたDOMに対して再度ReactDOM.renderを行った時にwarningが出るようになりました。この場合は一度ReactDOM.unmountComponentAtNodeでアンマウントしてから再度renderを行います。</li>
<li>componentDidUpdateのライフサイクルメソッドが第3引数としてprevContextを受け取らなくなりました。</li>
<li>ShallowRendererにunstable_batchedUpdatesはもう実装されません。</li>
</ul>


<p>下記はすでにwarningの対象で今回のバージョンで完全に削除されたものです。</p>

<ul>
<li><code>React.createClass</code>が削除されました。代わりに<code>create-react-class</code>を使います。</li>
<li><code>React.PropTypes</code>が削除されました。代わりに<code>pro-types</code>を使います。</li>
<li><code>React.DOM.xxx</code>が削除されました。代わりに<code>react-dom-factories</code>を使います。</li>
</ul>


<h2>JavaScript Environment Requirements</h2>

<p>動作環境として、<code>Map</code>と<code>Set</code>と<code>requestAnimationFrame</code>が必要になりました。
なので必要に応じてpolyfillを設定します。</p>

<p>```js
import &lsquo;core-js/es6/map&rsquo;;
import &lsquo;core-js/es6/set&rsquo;;</p>

<p>import raf from &lsquo;raf&rsquo;;
if (!window.requestAnimationFrame) {</p>

<pre><code>window.requestAnimationFrame = raf;
// or
window.requestAnimationFrame = cb =&gt; {
    setTimeout(cb, 0);
}
</code></pre>

<p>}
```</p>

<h2>React Fiber</h2>

<p>React Fiberについてはすでに書いたので省略しますが、v16の時点ではv15と互換性のある同期モードで動作します。
したがって、v16にあげたからといって、大きくパフォーマンスが向上したりするようなことはありません（多少のパフォーマンスが上がるかもですが）。</p>

<p>現時点では、いくつかの方法を使うことで、非同期renderingを試すことができるので紹介します。ただし、非同期rendering周りはまだ安定しておらず、コードもガンガン変わっているので注意が必要です。</p>

<h3>ReactDOM.unstable_deferredUpdates</h3>

<p><code>ReactDOM.unstable_deferredUpdates</code>で囲んだ中でのsetStateなどの更新処理は、Low Priorityとして扱われて、requestIdleCallbackを使って非同期に処理されます。</p>

<p>```js
ReactDOM.unstable_deferredUpdates(() => {</p>

<pre><code>this.setState(() =&gt; newState);
</code></pre>

<p>});
```</p>

<h3>React.unstable_AsyncComponent</h3>

<p><code>React.unstable_AsyncComponent</code>の中で起きた更新処理はLow Priorityとして扱われるようになります。
直接Componentとして使う方法と、PureComponentのようにextends対象として使う方法があります。</p>

<p>```js
const AsyncComponent = React.unstable_AsyncComponent;</p>

<p>ReactDOM.render(</p>

<pre><code>&lt;AsyncComponent&gt;&lt;App /&gt;&lt;/AsyncComponent&gt;,
container
</code></pre>

<p>);</p>

<p>// or</p>

<p>class App extends AsyncComponent {
}
```</p>

<h3>ReactDOM.flushSync</h3>

<p><code>ReactDOM.flushSync</code>で囲んだ中での更新処理は、同期(Sync)のPriorityとして扱われます。
v16ではデフォルトが同期のPriorityなので、効果ありませんが、上記のunstableなAPIの中で同期的な更新を行いたい場合に、使用します。</p>

<p>```js
ReactDOM.flushSync(() => {</p>

<pre><code>this.setState(() =&gt; newState);
</code></pre>

<p>});
```</p>

<p>あとは、今後の非同期renderingに備えて、既存のStateの値を元に更新処理を行う場合は、第1引数に関数を渡す方法でのsetState呼び出しをするようにしておいた方がいいと思います。</p>

<p><code>js
this.setState(newState)
// ↓↓↓
this.setState(prevState =&gt; newState);
</code></p>

<p>React Fiberでは、柔軟なスケジューリングを可能にすることで、UIのレスポンス性を向上させることが目的です。</p>

<h2>Custom Renderer</h2>

<p>Custom Rendererを実装するためのパッケージはv16には間に合いませんでしたが、下記のPRで作業中なので、気になる人はwatchしておくといいと思います。</p>

<ul>
<li><a href="https://github.com/facebook/react/pull/10758">https://github.com/facebook/react/pull/10758</a></li>
</ul>


<h2>Test Renderer</h2>

<p>主にsnapshot testingなどで使われていたTest Rendererに便利なAPIが追加されて使いやすくなりました。
Shallow Rendereは指定したComponentだけがrenderされますが、Test Rendererはツリー全体をrenderします。</p>

<p>下記のようにfind〜やfindAll〜のAPIが追加されており、インスタンスにもアクセスできるため、setStateを呼び出したりもできます。
また、Test RendererはReact Fiberに対するRendererとして実装されているため、React Fiberが提供する機能を利用できます。</p>

<p>```js
import React from &lsquo;react&rsquo;;
import TestRenderer from &lsquo;react-test-renderer&rsquo;;</p>

<p>const Child = props => <div>{props.children}</div>;
const Counter = props => <div>{props.count}</div>;</p>

<p>class App extends React.Component {
  constructor(props) {</p>

<pre><code>super(props);
this.state = {
  count: 0
};
</code></pre>

<p>  }
  render() {</p>

<pre><code>return (
  &lt;section&gt;
    &lt;div&gt;bar&lt;/div&gt;
    &lt;Child&gt;&lt;p&gt;Hello&lt;/p&gt;&lt;/Child&gt;
    &lt;div&gt;bar&lt;/div&gt;
    &lt;button onClick={() =&gt; this.setState({count: this.state.count + 1})}&gt;
      ++
    &lt;/button&gt;
    &lt;Counter count={this.state.count} /&gt;
  &lt;/section&gt;
);
</code></pre>

<p>  }
}</p>

<p>const root = TestRenderer.create(<App />).root;</p>

<p>// find a component by Type
console.assert(root.find(node => node.type === Child).props.children.type === &lsquo;p&rsquo;);
// find a component by Props
console.assert(root.findByProps({children: &lsquo;Hello&rsquo;}).type === &lsquo;p&rsquo;);</p>

<p>// find all components by Type
console.assert(root.findAllByType(&lsquo;div&rsquo;).length === 4);</p>

<p>// initial state
const instance = root.instance;
console.assert(root.findByType(Counter).props.count === 0);
console.assert(instance.state.count === 0);</p>

<p>// click the button
const button = root.findByType(&lsquo;button&rsquo;).props.onClick();
console.assert(root.findByType(Counter).props.count === 1);
console.assert(instance.state.count === 1);</p>

<p>// setState directly
instance.setState({count: instance.state.count + 1});
console.assert(root.findByType(Counter).props.count === 2);
console.assert(instance.state.count === 2);
```</p>

<p>後、DOMComponentのrefに対するMockの挙動を定義することもできます。</p>

<p>Test Rendererのドキュメントを書いてみたので、そちらも参照してみてください。</p>

<ul>
<li><a href="https://facebook.github.io/react/docs/test-renderer.html">https://facebook.github.io/react/docs/test-renderer.html</a></li>
</ul>


<p>英語ですがブログも書いたのでそっちも。</p>

<ul>
<li><a href="https://medium.com/@koba04/testing-react-components-with-react-test-renderer-b4df590d0320">https://medium.com/@koba04/testing-react-components-with-react-test-renderer-b4df590d0320</a></li>
</ul>


<h2>Enzyme</h2>

<p><code>enzyme</code>も同じタイミングでv3がリリースされました。
v3からはAdapterのアーキテクチャになっており、対象とするReactのバージョンに応じたAdapterをインストールして設定します。</p>

<p>```js
import Enzyme from &lsquo;enzyme&rsquo;;
import Adapter from &lsquo;enzyme-adapter-react-16&rsquo;;</p>

<p>Enzyme.configure({ adapter: new Adapter() });
```</p>

<p>上記をNodeやMochaの<code>--require</code>オプションに設定したり、Jestの<code>setupFiles</code>に定義すれば毎回書く必要はありません。</p>

<p>これにより、今後はpreactのアプリケーションもサポートできるようになるかもしれません。</p>

<ul>
<li><a href="https://github.com/aweary/preact-enzyme-adapater">https://github.com/aweary/preact-enzyme-adapater</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React Fiber現状確認]]></title>
    <link href="http://blog.koba04.com/post/2017/04/25/a-state-of-react-fiber/"/>
    <updated>2017-04-25T02:00:55+09:00</updated>
    <id>http://blog.koba04.com/post/2017/04/25/a-state-of-react-fiber</id>
    <content type="html"><![CDATA[<p><a href="https://developers.facebook.com/videos/?category=f8_2017">F8</a>でもReact Fiberについての発表もあったので、気になっている人も多いReact Fiberの現状について簡単に書きたいと思います。</p>

<p>Reactの完全な書き換えということで、使い方も変わってしまうと思っている人もいると思いますが、内部実装の書き換えであり、利用者から見える部分ではほとんど変更はありません。</p>

<p>もちろん、react-fiberというパッケージをインストールするというわけでもありません。</p>

<p>むしろ、<code>v16</code>の時点では現在の実装と互換性を保たれているので、<code>v16</code>がリリースされた時に、<code>v15.5</code>を使っていればほとんどそのまま<code>v16</code>に更新できると思います。
そして、言われなければ内部実装が変わっていることに気づかないのではないかと思います。</p>

<h2>とりあえずどうなるのか知りたい人向けのまとめ</h2>

<ul>
<li>v16では、基本的にはv15の時と同じように動作します。逆に言うとパフォーマンスもそんなに変わらない（はず）です</li>
<li>renderメソッドから<code>[&lt;Foo /&gt;, &lt;Bar /&gt;]</code> みたいに配列で返したり、文字列をReactElementでラップすることなく返せるようになります</li>
<li>v17では、デフォルトで非同期のrendering（後述）になります。v16でも何らかのAPIでopt-inで試せるようにはなりそうです。現状は<code>ReactDOM.unstable_deferredUpdates</code>で一部試すことができます</li>
<li>v17では、劇的に高速になるというよりは、ユーザーの入力をブロックしないようにしたり、柔軟に更新処理をスケジューリング出来るようになる予定です</li>
</ul>


<h2>注意点</h2>

<p><strong>以下の情報は、Reactをただ使いたい人にとっては知る必要のない内部実装の話です。多くの人にとってはここまでの情報でReact FiberについてはOKだと思います。v17になるまでは。</strong></p>

<!-- more -->


<h2>Reactの構成</h2>

<p>新しいFiberについて説明するために、まずは現状の実装について確認しましょう。
Reactのソースコードは下記のような構成になっています。</p>

<p>```</p>

<pre><code>src
├── fb
├── isomorphic
│   ├── children
│   ├── classic
│   │   ├── class
│   │   ├── element
│   │   └── types
│   ├── hooks
│   └── modern
│       ├── class
│       └── element
├── renderers
│   ├── art
│   ├── dom
│   │   ├── fiber
│   │   ├── shared
│   │   └── stack
│   ├── native
│   ├── noop
│   ├── shared
│   │   ├── fiber
│   │   ├── hooks
│   │   ├── shared
│   │   ├── stack
│   │   └── utils
│   └── testing
│       └── stack
├── shared
│   ├── types
│   └── utils
└── test
(テストなどの一部ディレクトリは省略)
</code></pre>

<p>```</p>

<p>上記の通り、Fiberは<code>renderers</code> の中にありrendererの1つであることがわかります。<code>fiber</code> と同列にある<code>stack</code> は現在の実装のrendererです。</p>

<p><code>renderes/shared/</code> に<code>fiber</code> と<code>stack</code> のディレクトリがあって、<code>renderers/dom/</code> にも<code>stack</code> と<code>fiber</code> があります。rendererの中にはStackとFiberの2種類の実装があり、それぞれに対応するDOMやNativeなどの環境毎のrendererがさらにあるような構成になっています。</p>

<p>FiberやStackは、reconciliationと呼ばれる部分の役割を担っています。
reconciliationとは、ReactElementからComponentのインスタンスを生成したり差分を計算してHost(DOM)に反映したり、ライフサイクルメソッドの呼び出しといったことを行う部分です。
Hostに反映させる部分はHostが何かによっても異なり、反映方法もreconciliationによって異なるため、<code>renderers/dom/</code> 以下にもStackとFiberが存在します。</p>

<p>Hostとは各環境のことです。ブラウザー環境であればDOMであり、ReactNativeであればネイティブのビューとなります。</p>

<h2>Stack</h2>

<p>それでは、まずは現在使われているStackのrendererについて簡単に触れます。
Stackは、ReactElementがツリー構造になるのと同様に、親から子、子から孫に処理を行っていきます。</p>

<p>{% img /images/posts/a-state-of-react-fiber/ReactDOM.png &lsquo;ReactDOM Stack&rsquo; %}</p>

<p>上記では、<code>mountComponent</code> がどんどん入れ子になって呼ばれているのがわかります。
加えてこれは同期的に行われます。</p>

<p>つまり、トップレベルのComponentから再renderした場合、</p>

<ul>
<li>子孫の全てのComponentに対するrender処理を行いReactElementのツリーを構築する</li>
<li>更新の場合は、前のReactElementツリーと比較を行う</li>
<li>差分をHostに適用する</li>
<li>ライフサイクルメソッドの呼び出しなどを行う</li>
</ul>


<p>という処理が同期的に処理されます。
そのため、例えば複雑なツリー構造を持っていて上記の処理に時間がかかる場合、UIを完全にブロックしてしまいます。</p>

<p>また、例えばアニメーションやユーザーのタイピングなど、即時に反映する必要のある処理を行っている時にサーバーから結果が返ってきた時を考えてみます。
Stackは全てが同期的に処理されるため、サーバーからの結果の反映処理が、アニメーションやタイピングの反映に割り込んでブロックしてしまうことも起きます。</p>

<p>これらは、単純なパフォーマンスのベンチマークでは現れない指標ですが、ユーザー体験という意味では重要です。</p>

<p>これらの問題を解決するためのものとしてReact Fiberはあります。</p>

<p>ちなみにStackに関連するソースは、v16のリリース時には削除されそうな感じではあります。</p>

<h2>Fiber</h2>

<p>Fiberは、wikipediaによると「軽量な実行スレッド」とされています。</p>

<p><a href="https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A1%E3%82%A4%E3%83%90%E3%83%BC_">https://ja.wikipedia.org/wiki/%E3%83%95%E3%82%A1%E3%82%A4%E3%83%90%E3%83%BC_</a>(%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF)</p>

<p>React Fiberでは、Fiberの単位でreconciliationが行われます。
Fiberは、基本的には1つのReactElementと対応すると考えることができます。</p>

<p>厳密にはReactElementの単位とFiberが必ずしも一致するわけでありません。
さらにFiberは、<code>fiber.alternate</code> として自身をcloneしたFiberを持っており再利用されています。
ただ、考える上ではFiberをReactElementの単位でイメージするとわかりやすいと思います。</p>

<p>FiberはFlowの型で下記のように指定されています。</p>

<p>```js</p>

<pre><code>// 一部省略
type Fiber = {
  tag: TypeOfWork,
  key: null | string,
  type: any,
  stateNode: any,
  return: Fiber | null,
  child: Fiber | null,
  sibling: Fiber | null,
  index: number,
  ref: null | (((handle: mixed) =&gt; void) &amp; {_stringRef: ?string}),
  pendingProps: any, // This type will be more specific once we overload the tag.
  memoizedProps: any, // The props used to create the output.
  updateQueue: UpdateQueue | null,
  memoizedState: any,
  effectTag: TypeOfSideEffect,
  nextEffect: Fiber | null,
  firstEffect: Fiber | null,
  lastEffect: Fiber | null,
  pendingWorkPriority: PriorityLevel,
  progressedPriority: PriorityLevel,
  progressedChild: Fiber | null,
  progressedFirstDeletion: Fiber | null,
  progressedLastDeletion: Fiber | null,
  alternate: Fiber | null,
};
</code></pre>

<p>```</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactFiber.js">https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactFiber.js</a></li>
</ul>


<p>各プロパティについては解説しませんが、<code>return</code> や<code>child</code> や<code>sibling</code> など、他のFiberへの参照を持っていることがわかります。
FiberはLinked Listの構造になっています。Stackの場合はTree構造を掘り下げていくように処理をしていましたが、Fiberでは、<code>return</code> や<code>child</code> や<code>sibling</code> などをたどることで順番にReactElementを処理していきます。
そのことは、下記のスタックツリーを見てもわかります。</p>

<p>{% img /images/posts/a-state-of-react-fiber/ReactDOMFiber.png &lsquo;ReactDOM Fiber&rsquo; %}</p>

<p>上記の通り、Stackのようにスタックがたくさん積まれていないことがわかります。</p>

<p>Stackでは処理が1つのツリーを単位として行われていましたが、FiberではFiberの単位で処理されます。Stackでは処理を同期的に行うしかできませんでしたが、FiberではこのFiberに対する処理をスケジューリングすることができます。</p>

<p>つまり、A → B → C とLinkedListを構成しているFiberがあった時に、A → B まで処理して中断し、またB → Cから処理を再開できます。
これはStackのような構造では難しいことです。
Generatorsだとどうでしょうか？それに対しては、<a href="https://github.com/sebmarkbage">Sebastian Markbåge</a>が下記でGeneratorsを採用しなかった理由を書いているので興味のある人は見て見るといいと思います。</p>

<ul>
<li><a href="https://github.com/facebook/react/issues/7942">https://github.com/facebook/react/issues/7942</a></li>
</ul>


<h3>Fiberのスケジューリング</h3>

<p>では、具体的にどのようにスケジューリングが行われるのかを見ていきます。</p>

<p>Fiberは、<code>beginWork</code> と<code>completeWork</code> と<code>commitWork</code> という3つのフェーズがあります。
beginWorkはcomponentのインスタンス化やrenderメソッドの呼び出し、shouldComponentUpdateなどによる比較を行います。</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactFiberBeginWork.js">https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactFiberBeginWork.js</a></li>
</ul>


<p>completeWorkは副作用を示すeffectTagを設定したり、Hostインスタンスを作成したりなどを行います。（末端のHostなどでのみ実行される）</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactFiberCompleteWork.js">https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactFiberCompleteWork.js</a></li>
</ul>


<p>副作用は下記のように定義されています。</p>

<p>```js</p>

<pre><code>module.exports = {
  NoEffect: 0, //           0b0000000
  Placement: 1, //          0b0000001
  Update: 2, //             0b0000010
  PlacementAndUpdate: 3, // 0b0000011
  Deletion: 4, //           0b0000100
  ContentReset: 8, //       0b0001000
  Callback: 16, //          0b0010000
  Err: 32, //               0b0100000
  Ref: 64, //               0b1000000
};
</code></pre>

<p>```</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactTypeOfSideEffect.js">https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactTypeOfSideEffect.js</a></li>
</ul>


<p>commitWorkでは、componentDid(Mount|Update)などのライフサイクルメソッドの呼び出しや、completeWorkで設定されたeffectTagに基づいてHostに結果を反映します。</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactFiberCommitWork.js">https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactFiberCommitWork.js</a></li>
</ul>


<p>この中で、beginWorkとcompleteWorkはFiber単位で実行されます。
commitWorkは、全てのFiberに対する処理が終わった後にまとめて実行されます。</p>

<p>例えば、下記のような構成のComponentがある場合、</p>

<p>```js</p>

<pre><code>Text = () =&gt; '...';
List = () =&gt; [
  &lt;div&gt;...&lt;/div&gt;,
  &lt;div&gt;...&lt;/div&gt;,
  &lt;div&gt;...&lt;/div&gt;,
];

class App extends React.Component {
    render() {
        return (
            &lt;main&gt;
            &lt;h2&gt;...&lt;/h2&gt;
            &lt;p&gt;...&lt;/p&gt;
            &lt;div&gt;
                &lt;Text /&gt;
                &lt;List /&gt;
            &lt;/div&gt;
            &lt;/main&gt;
        );
    }
}
</code></pre>

<p>```</p>

<p>下記のような流れで処理されます。</p>

<ol>
<li><strong>beginWork</strong> … (HostRoot)</li>
<li><strong>beginWork …</strong>  <code>&lt;App&gt;</code> (ClassComponent)</li>
<li><strong>beginWork</strong> …  <code>&lt;main&gt;</code> (HostComponent)</li>
<li><strong>beginWork, completeWork …</strong>  <code>&lt;h2&gt;</code> (HostComponent)</li>
<li><strong>beginWork, completeWork …</strong> <code>&lt;p&gt;</code> (HostComponent)</li>
<li><strong>beginWork …</strong> <code>&lt;div&gt;</code> (HostComponent)</li>
<li><strong>beginWork …</strong> <code>&lt;Text&gt;</code> (FunctionalComponent)</li>
<li><strong>beginWork completeWork …</strong> &lsquo;&hellip;&rsquo; (HostText)</li>
<li><strong>beginWork …</strong> <code>&lt;List&gt;</code> (Functional Component)</li>
<li><strong>beginWork, completeWork …</strong> : <code>&lt;div&gt;</code> (HostComponent)</li>
<li><strong>beginWork, completeWork …</strong> : <code>&lt;div&gt;</code> (HostComponent)</li>
<li><strong>beginWork, completeWork …</strong> : <code>&lt;div&gt;</code> (HostComponent)</li>
<li><strong>commitAllWork …</strong> (HostRoot)</li>
</ol>


<p>React Fiberは、非同期renderingの場合には、後述する優先度が高くないものについてはrequestIdleCallback（サポートしてなければpolyfill実装）を使い、これらをスケジューリングして非同期に処理していきます。
requestIdleCallbackでは、アイドル時間を<code>timeRemaining</code>の関数から受け取ることができるため、この値を元に処理できる時間がなくなると再び<code>requestIdleCallback</code> に処理を登録して次のアイドル時間に処理するようになっています。
これにより、優先度が高くない処理がUIや他の処理をブロックしないようになっています。</p>

<ul>
<li><a href="https://developer.mozilla.org/ja/docs/Web/API/Window/requestIdleCallback">https://developer.mozilla.org/ja/docs/Web/API/Window/requestIdleCallback</a></li>
</ul>


<p>下記はFiberを同期モードで実行した時のスタックです。
全てが同期的に行われていることがわかります。この間はUIを完全にブロックしてしまいます。</p>

<p>{% img /images/posts/a-state-of-react-fiber/ReactDOMFiber-sync.png &lsquo;ReactDOM Fiber Sync&rsquo; %}</p>

<p>下記は同じ処理を非同期で実行したスタックです。
スタックが途切れ途切れになっていることがわかります。そのためUIをブロックしません。
右端にある細いスタックはcommitWorkによるものです。
Renderingの処理はcommitWorkの以降でだけ発生していることがわかります。</p>

<p>{% img /images/posts/a-state-of-react-fiber/ReactDOMFiber-async.png &lsquo;ReactDOM Fiber Async&rsquo; %}</p>

<p>このとき、HostのViewに反映するといった副作用をこのbeginWork〜completeWorkの中で行わないというのは1つのポイントです。
例えば、Viewへの反映をこの非同期処理の中で行ってしまうと、Viewが部分部分更新される形になり、UIがガタガタしてしまいます。
React Fiberでは、commitWorkで全てのViewへの更新をまとめて行うため、このようなことは起こりません。
逆にcommitWorkの部分は時間がかかりやすくframeを落としてしまうこともあるためパフォーマンスチューニングが注意深く行われています。
componentDid(Mount|Update)もこの中で行われるため、この中で重い処理を行わないように注意が必要です。</p>

<p>余談ですが、上記のようにライフサイクルメソッドがボトルネックになる場面が想定されるため、ライフサイクルメソッドをPromiseを返す非同期なAPIとする案もあります。
あと、実はマウント時はcompleteWorkでもSideEffectが処理されています。これはマウント時にはまだHostContainerはDOMに追加されていないため追加しても表示されず問題ないためです。
これもcommitWorkでframeを落とさないための工夫の1つです。</p>

<p>また、上記のようなrequestIdleCallbackを使ったスケジュール以外にも、優先度に応じたスケジューリングも可能です。
優先度は下記のように定義されています。</p>

<p>```js</p>

<pre><code>export type PriorityLevel = 0 | 1 | 2 | 3 | 4 | 5 | 6;

module.exports = {
  NoWork: 0, // No work is pending.
  SynchronousPriority: 1, // For controlled text inputs. Synchronous side-effects.
  TaskPriority: 2, // Completes at the end of the current tick.
  AnimationPriority: 3, // Needs to complete before the next frame.
  HighPriority: 4, // Interaction that needs to complete pretty soon to feel responsive.
  LowPriority: 5, // Data fetching, or result from updating stores.
  OffscreenPriority: 6, // Won't be visible but do the work in case it becomes visible.
};
</code></pre>

<p>```</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactPriorityLevel.js">https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactPriorityLevel.js</a></li>
</ul>


<p>更新処理に優先度を持たせることで、ユーザーインタラクションやアニメーションなどの更新処理を、APIレスポンスの反映など、優先度の低いタスクが邪魔しないようにすることができます。</p>

<p>下記はそれを表したサンプルです。「Async mode」の場合、5000個のlist itemは100ms毎に<code>LowPriority</code>で更新されます。「Sync mode」の場合は<code>SynchronousPriority</code>として同期的にレンダリングされます。</p>

<ul>
<li><a href="https://koba04.github.io/react-fiber-resources/examples/">https://koba04.github.io/react-fiber-resources/examples/</a></li>
</ul>


<p>上にある入力フィールドに何か入力してください。「Async mode」の場合は入力中はlist itemが更新されず、入力も多少引っかかりますがスムーズに反映されます。「Sync mode」の場合は入力中もlist itemが更新されてユーザーの入力を邪魔してしまっています。</p>

<p>優先度の低い処理はrequestIdleCallbackを使ってアイドル時間がある時に、優先度の高い処理はrequestAnimationFrameを使うか同期的にASAPで反映されます。</p>

<p>優先度の低いタスクを実行中に、優先度の高いタスクが割り込んで来た場合、優先度の低いタスクは中断されて、優先度の高いタスクが先に行われます。
優先度の高いタスクが終了後、再び優先度の低いタスクが実行されます。
この際、割り込まれる前に優先度の低いタスクが実行していたFiberのうち、優先度の高いタスクが処理しなかったものは再利用されます。</p>

<p>このように、タスクの割り込みによっては複数回Fiberが処理されることがあるため、非同期のレンダリングの場合には、componentWillMountなどのライフサイクルメソッドが複数回呼び出されることがあります。componentDidMountなどはcommitWorkで呼ばれるため複数回呼ばれることはありません。</p>

<p>また、OffscreenPriorityというPriorityがあります。これを利用することで初回のレンダリングでは必要ない部分をプリレンダリングしたり、ダブルバッファリングが可能となります。ReactDOMでは、<code>hidden</code>属性のあるものはOffscreenPriorityとして扱われます。</p>

<p>他にもAnimationPriorityなどのPriorityがありますが、現時点ではまだPriorityを制御するようなAPIはないため、どのように利用するのかは見えていません。（facebook.comでの非同期レンダリングの実験をやりながらAPIを決めていくらしい）</p>

<p>その他の細かい挙動については、<code>ReactIncremental-test.js</code>のテストを見るとどんなことができるのかわかるかと思います。</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/__tests__/ReactIncremental-test.js">https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/__tests__/ReactIncremental-test.js</a></li>
</ul>


<p>ここで使われている<code>ReactNoop</code> というrendererはテスト用のrendererです。UIは全く持っておらずテスト用に<code>timeRemaining</code> などが柔軟に制御可能であり、React Fiberの開発は初期の頃はこのrendererに対して行われていました。custom rendererを作る際の参考にもいいかもしれません。</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/noop/ReactNoop.js">https://github.com/facebook/react/blob/master/src/renderers/noop/ReactNoop.js</a></li>
</ul>


<h2>Error Boundary</h2>

<p>あと、Fiber自体には直接関係ないですが、Error Boundaryの機能も公式にサポートされるようになりそうです。
Error Boundaryとは、これまでは子孫Componentのrender時にエラーが発生した場合は、何も表示されなくなってしまいましたが、Error Boundaryの機能を使うことで握り潰したりエラーハンドリングができるようになるものです。</p>

<p>```js</p>

<pre><code>class App extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            error: null
        };
    }
    // エラーハンドリングを定義する
    unstable_handleError(error) {
        this.setState({error});
    }
    render() {
        if (this.state.error) {
            return &lt;div&gt;エラーが発生しました&lt;/div&gt;;
        }
        return this.props.children;
    }
}
</code></pre>

<p>```</p>

<h2>CoroutineComponent</h2>

<p>Fiberには<code>CoroutineComponent</code> や<code>CoroutineHandlerPhase</code> や<code>YieldComponent</code>といったComponentもあります。これはどうやら、親のComponentのレンダリングを途中で止めて、子のComponentからの結果を受けて親のComponentのレンダリングを再開するみたいなこともできるっぽいです（あんまりわかってない）。例えばレイアウトを行うComponentで子を実際にレンダリングしてみて、サイズなどの結果を持って親のComponentを再度レンダリングするみたいなことが、ユースケースとしてどこかで説明されていました。</p>

<p>これの動作については、上記であげた<code>ReactCoroutin-test.js</code> の中にあるので見てみるといいかと思います。状態としてはとりあえず動いてるっぽいという感じだとは思います。</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/__tests__/ReactCoroutine-test.js">https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/__tests__/ReactCoroutine-test.js</a></li>
</ul>


<h2>Custom Renderer</h2>

<p>Stackでは、Custom Rendererを作成するためにはハックが必要でしたが、React FiberではFlowによって型付けされているため、わかりやすくなりました。</p>

<p>```js</p>

<pre><code>export type HostConfig&lt;T, P, I, TI, PI, C, CX, PL&gt; = {
  getRootHostContext(rootContainerInstance: C): CX,
  getChildHostContext(parentHostContext: CX, type: T): CX,
  getPublicInstance(instance: I | TI): PI,

  createInstance(
    type: T,
    props: P,
    rootContainerInstance: C,
    hostContext: CX,
    internalInstanceHandle: OpaqueHandle,
  ): I,
  appendInitialChild(parentInstance: I, child: I | TI): void,
  finalizeInitialChildren(
    parentInstance: I,
    type: T,
    props: P,
    rootContainerInstance: C,
  ): boolean,

  prepareUpdate(
    instance: I,
    type: T,
    oldProps: P,
    newProps: P,
    rootContainerInstance: C,
    hostContext: CX,
  ): null | PL,
  commitUpdate(
    instance: I,
    updatePayload: PL,
    type: T,
    oldProps: P,
    newProps: P,
    internalInstanceHandle: OpaqueHandle,
  ): void,
  commitMount(
    instance: I,
    type: T,
    newProps: P,
    internalInstanceHandle: OpaqueHandle,
  ): void,

  shouldSetTextContent(props: P): boolean,
  resetTextContent(instance: I): void,
  shouldDeprioritizeSubtree(type: T, props: P): boolean,

  createTextInstance(
    text: string,
    rootContainerInstance: C,
    hostContext: CX,
    internalInstanceHandle: OpaqueHandle,
  ): TI,
  commitTextUpdate(textInstance: TI, oldText: string, newText: string): void,

  appendChild(parentInstance: I | C, child: I | TI): void,
  insertBefore(parentInstance: I | C, child: I | TI, beforeChild: I | TI): void,
  removeChild(parentInstance: I | C, child: I | TI): void,

  scheduleAnimationCallback(callback: () =&gt; void): number | void,
  scheduleDeferredCallback(
    callback: (deadline: Deadline) =&gt; void,
  ): number | void,

  prepareForCommit(): void,
  resetAfterCommit(): void,

  useSyncScheduling?: boolean,
};
</code></pre>

<p>```</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactFiberReconciler.js">https://github.com/facebook/react/blob/master/src/renderers/shared/fiber/ReactFiberReconciler.js</a></li>
</ul>


<p>実際に実装する際には、先ほど紹介した<code>ReactNoop</code> や、Test用のrendererでありReactElementからJSONを返す<code>ReactTestRenderer</code> や<code>ReactART</code> などが参考になると思います。</p>

<ul>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/testing/ReactTestRendererFiber.js">https://github.com/facebook/react/blob/master/src/renderers/testing/ReactTestRendererFiber.js</a></li>
<li><a href="https://github.com/facebook/react/blob/master/src/renderers/art/ReactARTFiber.js">https://github.com/facebook/react/blob/master/src/renderers/art/ReactARTFiber.js</a></li>
</ul>


<p>ただ、Reactはv16からFlat bundleになり、内部ライブラリーを<code>react/lib/xxx</code>のように利用出来なくなったので、Custom Renderer作る人向けに何かが提供されるのかは不明なところです。</p>

<h2>Server Side Rendering</h2>

<p>サーバーサイドレンダリングについては、Facebookで使っていないということもあり後回しになっていて、まだ実装されていません。
ただ、今までの<code>renderToString</code> は完全に同期でしたが、ReactFiberになることでイベントループをブロックしないようにHTML文字列を生成することは簡単になりそうです（v16には入るかどうかは不明）。<code>renderToStream</code> みたいなのは、副作用はcommitWorkでまとめてやるというところからは外れてしまうのでどうなんでしょうね。</p>

<h2>v16でも非同期レンダリングを試したい</h2>

<ul>
<li>現時点では、<code>ReactDOMFeatureFlags</code> に<code>fiberAsyncScheduling</code> というフラグがあるので、それを無理やり<code>true</code> に書き換えることでデフォルトで非同期のレンダリングに出来ます。ただまだそんなにテストされていないと思うのでバグなどはありそうです</li>
<li>または、<code>ReactDOM.unstable_deferredUpdates</code> を使うとその中の更新処理は<code>lowPriority</code> として処理されるため、非同期となります</li>
</ul>


<h2>その他リソース</h2>

<p>Fiberで何が嬉しいのかを知りたい人は、F8のTom OcchinoのTalkがとてもわかりやすいと思います。</p>

<ul>
<li>The Evolution of React and GraphQL at Facebook and Beyond

<ul>
<li><a href="https://developers.facebook.com/videos/f8-2017/the-evolution-of-react-and-graphql-at-facebook-and-beyond/">https://developers.facebook.com/videos/f8-2017/the-evolution-of-react-and-graphql-at-facebook-and-beyond/</a></li>
</ul>
</li>
</ul>


<p>Lin ClarkがReact ConfでCode Cartoonを使ってReact Fiberについて説明していたのもわかりと思います。</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/ZCuYPiUIONs?ecver=1" frameborder="0" allowfullscreen></iframe>


<p>あとはSebastian MarkbågeのReact ConfのキーノートでもReact Fiberについて触れられています。</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/bvFpe5j9-zQ?ecver=1" frameborder="0" allowfullscreen></iframe>


<p>あとは、個人的にReact Fiberについてまとめたリポジトリもあります。</p>

<ul>
<li><a href="https://github.com/koba04/react-fiber-resources">https://github.com/koba04/react-fiber-resources</a></li>
</ul>


<h2>で結局何が嬉しいの？</h2>

<p>React Fiberに変わることで、よくフレームワークのパフォーマンス比較にあるようなベンチマークのスコアがよくなるといったことはおそらくないと思います。
React Fiberになることで、これまで同期的にツリーを処理していくしかなかったものが非同期に、より柔軟に処理出来るようになるのがメリットです。
これにより、アニメーションやユーザーのインタラクションに対して可能な限り早く反応出来るように出来ます。また、このような基盤としてReact Fiberがあるので、今後そういった機能追加が行われていくのではないかと思います。</p>

<p>というで、v16ではそんなに変わりませんが、今後の機能追加を楽しみにしましょう。
また、React Fiberの実装も勉強になるので興味のある人は是非読んでみてください。</p>

<p>ちなみにReact Fiberの最初のPRはこれのようですね。</p>

<ul>
<li><a href="https://github.com/facebook/react/pull/6690">https://github.com/facebook/react/pull/6690</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React v15.5(6) and v16]]></title>
    <link href="http://blog.koba04.com/post/2017/04/14/react-dot-js-v155-and-v16/"/>
    <updated>2017-04-14T14:00:05+09:00</updated>
    <id>http://blog.koba04.com/post/2017/04/14/react-dot-js-v155-and-v16</id>
    <content type="html"><![CDATA[<p>Reactのv15.5がリリースされたので、v15.5での変更点とv16についてのまとめです。</p>

<ul>
<li><a href="https://facebook.github.io/react/blog/2017/04/07/react-v15.5.0.html">https://facebook.github.io/react/blog/2017/04/07/react-v15.5.0.html</a></li>
</ul>


<p>v15.5はバグフィックスとv16での変更点に対する準備なので、可能ならあげておいた方がスムーズにv16がリリースされた時に対応できると思います。</p>

<p>基本的には、v16で色々と廃止するための警告が主になります。
最近のバージョンと同様に、コアから必要なもの以外をどんどん削ぎ落としていく流れです。</p>

<p>この警告に対応するために、Enzymeなどでは利用するために必要なライブラリーが変更されているので更新する際には注意が必要です。</p>

<p>また、当初の予定ではv15.5がv15系の最後のリリースになる予定でしたが、上記のような混乱もあったためフォローアップとしてv15.6もリリースされることになりました。
なので、v15.6がリリースされてから対応するのもアリだと思います。</p>

<p>廃止されるものは色々ありますが、基本的に全てのものに対してマイグレーションのパスは提供されているので対応可能だと思います。
ただ、アクティブにメンテされていないくて15.5対応版をリリースしていないライブラリーを使っていると色々警告が出ると思います。
場合によっては、その警告によってテストが壊れることがあるかもしれません。</p>

<!-- more -->


<h2>Deprecated React.createClass</h2>

<p>廃止されること自体は前から言われていたので、使わないようにしていた人も多いと思いますが、<code>create-react-class</code>として別パッケージとなり、v16では<code>react</code>から削除されます。</p>

<p><code>js
import createReactClass from 'create-react-class';
</code></p>

<p>そのためv15.5では、<code>React.createClass</code>を使おうとすると警告が出ます。</p>

<p>自分の書いたコードで<code>React.createClass</code>を使っている場合は、<code>React.Component</code>を使ったComponent定義かStateless Functional Componentsに書き換える必要があります。</p>

<p>mixinを使っているなど、どうしても<code>React.createClass</code>を使いたい場合は<code>create-react-class</code>を使うこともできますが、可能な限りReact本体が提供する方法を利用する方がいいと思います。</p>

<p><code>React.createClass</code>から<code>React.Component</code>の定義に書き換えるcodemodも提供されているので、使ってみるのもいいかもしれません。</p>

<ul>
<li><a href="https://github.com/reactjs/react-codemod">https://github.com/reactjs/react-codemod</a></li>
</ul>


<p>このcodemodでは、<code>React.createClass</code>が提供するautobindを実現するために、property initializerのシンタックスを利用します。そのため、変換後は<code>babel-plugin-transform-class-properties</code>を使用する必要があります。(Stage 2)</p>

<ul>
<li><a href="http://babeljs.io/docs/plugins/transform-class-properties/">http://babeljs.io/docs/plugins/transform-class-properties/</a></li>
</ul>


<p>v16になった時点で<code>React.createClass</code>を使っているライブラリーを利用している場合には、PR送って対応してもらうか、<code>React.createClass</code>に<code>create-react-class</code>を代入するなどの対応が必要になるかもしれません。
(v15.5では、警告を出すために<code>React.createClass</code>には<code>Object.defineProperty</code>でgetterが設定されており、<code>configurable</code>でないので置き換えることはできません)</p>

<h2>Deprecated React.PropTypes</h2>

<p>これも、<code>React.createClass</code>と同様にずっと言われていましたが、<code>prop-types</code>として別パッケージとなり、v16では<code>react</code>から削除されます。</p>

<p><code>js
import PropTypes from 'prop-types';
</code></p>

<p>そのためv15.5では、<code>React.PropTypes</code>を使おうとすると警告が出るようになりました。</p>

<p>これもcodemodが提供されているので、それを使って一括で変換することができます。</p>

<ul>
<li><a href="https://github.com/reactjs/react-codemod#react-proptypes-to-prop-types">https://github.com/reactjs/react-codemod#react-proptypes-to-prop-types</a></li>
</ul>


<p>PropTypesに関しては、FlowやTypeScriptへの移行が勧められているもののハードルもあるので、別パッケージ化された<code>prop-types</code>をしばらく使い続けるのは選択肢としてあるのかなと思います。
今回別パッケージとなったのは組み込みのPropTypesのvalidationロジックであり、PropTypesのチェック機構自体がなくなることは、まだ予定されていないので。</p>

<p>ちなみに、将来的にAPIの変更が予定されているContextを使う場合にも、変わらず<code>prop-types</code>を使って指定します。
（実際には<code>contextTypes</code>の定義でマスクしているだけなので、<code>prop-types</code>を使う必要はないのですが）</p>

<h2>Deprecated Addons</h2>

<p>React本体がアドオンとして提供していた諸々が、廃止されたり別パッケージ化したり、移動したりしています。
v16では、<code>react-with-addons</code>のUMDビルドも提供されなくなります。</p>

<ul>
<li><code>react-addons-create-fragment</code>は、v16のFiber化により配列を返すことができるようになるため、多くの場面で不要となるので削除されます。</li>
<li><code>react-addons-css-transition-group</code>と<code>react-addons-transition-group</code>は、<code>react-transition-group</code>の別パッケージになりました。<code>CSSTransitionGroup</code>と<code>TransitionGroup</code>して利用できます。ただし、全く実装が一緒というわけではないので移行する際には注意が必要です。すでに修正済みですが下記のようなバグとかもあったりするので&hellip;。

<ul>
<li><a href="https://github.com/reactjs/react-transition-group">https://github.com/reactjs/react-transition-group</a></li>
<li><a href="https://github.com/reactjs/react-transition-group/pull/13">https://github.com/reactjs/react-transition-group/pull/13</a></li>
</ul>
</li>
<li><code>react-addons-linked-state-mixin</code>と<code>react-linked-input</code>は、明示的に<code>value</code>と<code>onChange</code>を指定すればいいので削除されます。</li>
<li><code>react-addons-pure-render-mixin</code>と<code>react-addons-shallow-compare</code>は、<code>React.PureComponent</code>を代わりに利用できます。</li>
<li><code>react-addons-update</code>は<code>immutability-helper</code>が代わりに利用できます。

<ul>
<li><a href="https://github.com/kolodny/immutability-helper">https://github.com/kolodny/immutability-helper</a></li>
</ul>
</li>
</ul>


<p><code>react-addons-test-utils</code>は、<code>react-dom</code>のrendererに依存している部分が多いため、<code>react-dom/test-utils</code>に移動されました。</p>

<p><code>js
import TestUtils from 'react-dom/test-utils';
</code></p>

<p>ShallowRenderに関しては<code>react-dom</code>に依存していないため、<code>react-test-renderer/shallow</code>に移動されました。
ちなみに<code>react-test-renderer</code>はJestがsnapshot testingで使っていたりする、ReactElementをJSONとして返すrendererです。
ShallowRenderは、これのトップレベルのComponentまでしかrenderしない版として考えることができます。</p>

<p><code>js
import {createRenderer} from 'react-test-renderer/shallow';
</code></p>

<p><del><code>react-addons-perf</code>だけは、特に何もなくこのままですが、<code>react-addons-perf</code>は同期的なrenderが前提となっているため、将来的にFiberで非同期的なrenderをする場合には正しく計測できません。</del></p>

<p><strong>[修正]</strong> <code>react-addons-perf</code>は同期的なrenderが前提となっていてFiberへの対応が難しいため、v16(Fiber)への対応は行われません。
Perfに変わる何かについては検討されるので、将来的に何か提供される可能性もありますが、とりあえずは<code>?react_perf</code>によるBrowser Timelineを使った計測が推奨されています。</p>

<ul>
<li><a href="https://facebook.github.io/react/docs/optimizing-performance.html#profiling-components-with-chrome-timeline">https://facebook.github.io/react/docs/optimizing-performance.html#profiling-components-with-chrome-timeline</a></li>
</ul>


<h2>15.6（予定）</h2>

<p><a href="https://github.com/facebook/react/issues/9398">https://github.com/facebook/react/issues/9398</a></p>

<ul>
<li><code>React.DOM.{p, div,...}</code>として提供されていたファクトリ関数が廃止となります。</li>
<li>APIの廃止などの警告は、これまでは<code>console.error</code>として出力されていましたが、<code>console.warn</code>で出力されるようになります。</li>
</ul>


<h2>16に向けて</h2>

<p>v16はすでに<code>@next</code>でインストールできます。
そのため、まだ実装されていないサーバーサイドレンダリングとShallowRenderを使っていない部分では試すことが可能です。</p>

<p><code>
npm i react@next react-dom@next
</code></p>

<h3>Fiber</h3>

<p>v16の一番大きな目玉は、Fiberに内部実装が置き換えられることです。
ただし、v16の時点ではFiberは現在のStackのrendererと互換性のあるモードで動作します。
そのため、Fiberの特徴である<code>requestIdleCallback</code>によってスケジューリングされた非同期なrenderではなく、同期的なrenderとなるため、利用者として大きな違いは感じないかもしれません。
（call stack見ると全く変わっていることがわかると思いますが）</p>

<p>文字列や配列をComponentでラップすることなく直接返すことができるのは嬉しい部分かもしれません。</p>

<p><code>js
const Text = ({text}) =&gt; text;
const List = () =&gt; [1, 2, 3];
</code></p>

<p>ちなみに、v16の時点でも<code>ReactDOM.unstable_deferredUpdates</code>を使うことで、非同期なrenderが出来るようにはなりそうです。
あとは、<code>ReactDOMFiber.js</code>にある<code>useSyncScheduling</code>というフラグを無理やり<code>false</code>にすればデフォルトで非同期なrenderになります。（軽く試した感じだと問題なく動いていた）</p>

<p>非同期のrenderをどのようにユーザー側のAPIとして見せるのかは、まだ明らかになっていなくてこれから議論していくようです。</p>

<p>Fiberについては、下記に集めたリソースを読むとわかると思います。（今後紹介的な何かを書くかも）</p>

<ul>
<li><a href="https://github.com/koba04/react-fiber-resources">https://github.com/koba04/react-fiber-resources</a></li>
</ul>


<p>最初に見るものとしてのおすすめは、Lin ClarkによるA Cartoon Intro to Fiber(React.js Conf 2017)です。</p>

<iframe width="560" height="315" src="https://www.youtube.com/embed/ZCuYPiUIONs?ecver=1" frameborder="0" allowfullscreen></iframe>


<p>互換モードによるFiber自体はfacebook.comでも問題なく動作しているようです。
ただし、サーバーサイドレンダリングに対する対応は、まだ全く入っておらず今後どうなっていくのかは不明です。FiberになるとStreaming renderingもやりやすくなるのではとは思いますが。</p>

<h3>No more direct import!</h3>

<p>v16からは、それぞれのエントリーポイントがRollupを使ってバンドルされたものになります。
なので下のような構造になります。</p>

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">react@next and react-dom@next are flat bundles! 👀 <a href="https://twitter.com/hashtag/reactjs?src=hash">#reactjs</a> <a href="https://t.co/5ezjjf08sd">pic.twitter.com/5ezjjf08sd</a></p>&mdash; Toru Kobayashi (@koba04) <a href="https://twitter.com/koba04/status/850180571653222400">April 7, 2017</a></blockquote>


<script async src="http://blog.koba04.com//platform.twitter.com/widgets.js" charset="utf-8"></script>


<p>これにより、初期ロード時間の短縮やサーバーサイドでのパフォーマンスの向上が見込まれています。
また、利用者側には関係ないですがビルド周りが見直されており、GruntやgulpやBrowserifyのタスクがリポジトリから削除されています。すっきり。</p>

<p>この変更による、一番大きな影響は<code>react/lib/xxxx</code>として直接Reactの内部ライブラリを利用しているライブラリが動作しなくなることです。
<code>enzyme</code>などのメジャーなライブラリはReact側でもケアされていますが、それ以外のライブラリーは壊れてどうにもならなくなることがあるかもしれません。
したがって、そのようなハックをしているライブラリーを利用している場合は注意した方がよさそうです。</p>

<h3>リリース？</h3>

<p>ちなみにv16は、夏くらい(?)をターゲットに考えているようです。</p>

<p>また何か動きがあれば追記するかも。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React.js Links vol.12]]></title>
    <link href="http://blog.koba04.com/post/2016/09/30/reactjs-links-vol12/"/>
    <updated>2016-09-30T14:00:10+09:00</updated>
    <id>http://blog.koba04.com/post/2016/09/30/reactjs-links-vol12</id>
    <content type="html"><![CDATA[<p>これはReactに関する記事や気になるissueなどのリンクを紹介する記事です。</p>

<!-- more -->


<h2>React v15.3.2</h2>

<ul>
<li><a href="https://github.com/facebook/react/releases/tag/v15.3.2">https://github.com/facebook/react/releases/tag/v15.3.2</a></li>
</ul>


<p>React v15.3.2がリリースされています。
細かなバグフィックスなどが中心です。</p>

<h2>Our First 50,000 Stars</h2>

<ul>
<li><a href="https://facebook.github.io/react/blog/2016/09/28/our-first-50000-stars.html">https://facebook.github.io/react/blog/2016/09/28/our-first-50000-stars.html</a></li>
</ul>


<p>ReactのGitHubでのstarが50,000を超えたことを記念するエントリーです。
Reactの前にはFaxJSというのがあって〜など、Reactが誕生するまでの流れの話などとても面白いです。</p>

<h2>Codebase Overview</h2>

<ul>
<li><a href="https://facebook.github.io/react/contributing/codebase-overview.html">https://facebook.github.io/react/contributing/codebase-overview.html</a></li>
</ul>


<p>React本体のコードについての解説です。
Reactを使う人にとってはほとんど知る必要のないことですが、contributeしたい場合にはとても役に立つドキュメントです。
特に<code>Haste</code>とというCommonJSではないFacebook独自のモジュールシステムを使っていたりするので&hellip;。
最初からこれがあれば&hellip;。</p>

<h2>If TypeScript is so great, how come all notable ReactJS projects use Babel?</h2>

<ul>
<li><a href="https://discuss.reactjs.org/t/if-typescript-is-so-great-how-come-all-notable-reactjs-projects-use-babel/4887">https://discuss.reactjs.org/t/if-typescript-is-so-great-how-come-all-notable-reactjs-projects-use-babel/4887</a></li>
</ul>


<p>TypeScriptが最高なら、どうしてReact周りのプロジェクトはみんなBabelを使っているの？という疑問に対するスレッドです。
FlowTypeとTypeScriptの違いなどの話も登場して面白いです。</p>

<h2>Redux Patterns and Anti-Patterns</h2>

<ul>
<li><a href="https://tech.affirm.com/redux-patterns-and-anti-patterns-7d80ef3d53bc">https://tech.affirm.com/redux-patterns-and-anti-patterns-7d80ef3d53bc</a></li>
</ul>


<p>Reduxでのアンチパターンについての記事です。
Immutable.jsと組み合わせた場合や、redux-thunkでのAPIアクセスの書き方について解説されています。</p>

<h2>You Might Not Need Redux</h2>

<ul>
<li><a href="https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367">https://medium.com/@dan_abramov/you-might-not-need-redux-be46360cf367</a></li>
</ul>


<p>Dan Abramov自身によるエントリーで、何も考えずにとりあえずRedux使うのをやめようという記事です。</p>

<h2>Declarative Routing for React</h2>

<ul>
<li><a href="https://react-router-website-uxmsaeusnn.now.sh/">https://react-router-website-uxmsaeusnn.now.sh/</a></li>
</ul>


<p>react-router v4についてのページです。
react-routerでは、Reactのためのルーティングライブラリーではなく、Reactを使ったルーティングライブラリーになっています。
そのため、<code>Match</code>や<code>Redirect</code>といったComponentが登場しており、議論を呼びそうな感じの変わり方をしています。
（反応を見ていると、概ねポジティブに捉えられているのがビックリですが）</p>

<h2>AMA with Redux</h2>

<ul>
<li><a href="https://hashnode.com/ama/with-redux-cisteui6p005gzx53fstg8t6l">https://hashnode.com/ama/with-redux-cisteui6p005gzx53fstg8t6l</a></li>
</ul>


<p>Reduxの作者であるDan Abramovと初期からの開発者であるAndrew ClarkによるAMAです。
Reduxについての実際に作った人たちの考えが説明されているので、興味のある人は読むといいと思います。</p>
]]></content>
  </entry>
  
</feed>

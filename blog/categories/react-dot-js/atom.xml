<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: react.js | blog.koba04.com]]></title>
  <link href="http://blog.koba04.com/blog/categories/react-dot-js/atom.xml" rel="self"/>
  <link href="http://blog.koba04.com/"/>
  <updated>2015-03-05T09:37:23+09:00</updated>
  <id>http://blog.koba04.com/</id>
  <author>
    <name><![CDATA[koba04]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[React.js v0.13 changes]]></title>
    <link href="http://blog.koba04.com/post/2015/03/05/react-js-v013-changes/"/>
    <updated>2015-03-05T09:23:28+09:00</updated>
    <id>http://blog.koba04.com/post/2015/03/05/react-js-v013-changes</id>
    <content type="html"><![CDATA[<p>React.js v0.13のRC2がリリースされたのでまとめてみます。</p>

<ul>
<li><a href="http://facebook.github.io/react/blog/2015/02/24/react-v0.13-rc1.html">http://facebook.github.io/react/blog/2015/02/24/react-v0.13-rc1.html</a></li>
<li><a href="http://facebook.github.io/react/blog/2015/03/03/react-v0.13-rc2.html">http://facebook.github.io/react/blog/2015/03/03/react-v0.13-rc2.html</a></li>
<li><a href="http://facebook.github.io/react/blog/2015/02/24/streamlining-react-elements.html">http://facebook.github.io/react/blog/2015/02/24/streamlining-react-elements.html</a></li>
</ul>


<p>今回のバージョンで何か大きく変更があるというよりもv0.14でやりたいことに向けての布石が多いように感じます。</p>

<p>試すときはこの辺りから。</p>

<p><code>
npm install react@0.13.0-rc2
npm install react-tools@0.13.0-rc2
</code></p>

<p><code>
http://fb.me/react-0.13.0-rc2.js
http://fb.me/react-0.13.0-rc2.min.js
http://fb.me/react-with-addons-0.13.0-rc2.js
http://fb.me/react-with-addons-0.13.0-rc2.min.js
http://fb.me/JSXTransformer-0.13.0-rc2.js
</code></p>

<!-- more -->


<h2>Propを変更するとwarninngが出ます (Breaking Change)</h2>

<p>development環境でPropをelement作成後に変更することはdeprecatedになってwarningが出るようになりました。
つまりimmutableなものとして扱う必要があります。</p>

<p><code>js
var element = &lt;Foo bar={false} /&gt;;
if (shouldUseFoo) {
  element.props.foo = 10;
  element.props.bar = true;
}
</code></p>

<h3>これまでの問題点</h3>

<ul>
<li>Propを直接変更してしまうと元の値を破棄してしまうのでdiffがなくなってしまいます。この場合、<code>shouldComponentUpdate</code>を実装している場合に比較時に差分を検出出来なくてDOM構造に差分があるはずなのに実際には反映されない可能性がありました。</li>
<li>またPropが変更されることがあるためcreateElementの時点でPropTypesのValidationも出来ず、それによってエラー時のstacktraceが深くなったりFlowによる静的解析にとっても都合がよくなかったりという面もありました。</li>
</ul>


<h4>それに対しての提案</h4>

<ul>
<li>動的にしたい場合は↓のような形で書くことでも可能です。</li>
</ul>


<p>```js
if (shouldUseFoo) {
  return <Foo foo={10} bar={true} />;
} else {
  return <Foo bar={false} />;
}</p>

<p>var props = { bar: false };
if (shouldUseFoo) {
  props.foo = 10;
  props.bar = true;
}
return <Foo {...props} />;
```</p>

<ul>
<li>現時点ではネストしたオブジェクトについては変更してもwarningは出ません。基本的にはimmutable.jsなどを使って完全にimmutableに扱った方がいいですが、mutableなオブジェクトは多くの場面で便利だし今回はネストしたオブジェクトはwarningの対象外となりました。</li>
</ul>


<p><code>js
return &lt;Foo nestedObject={this.state.myModel} /&gt;;
</code></p>

<ul>
<li>PropTypesのwarningをReactElementの作成時に行うなうようになりました。Propを変更するために↓のようにcloneしてReactElementにPropに値を追加するのは正しい方法です。</li>
</ul>


<p><code>js
var element1 = &lt;Foo /&gt;; // extra prop is optional
var element2 = React.addons.cloneWithProps(element1, { extra: 'prop' });
</code></p>

<h2>statics内のメソッドに対してautobindingされなくなりました (Breaking Change)</h2>

<p><code>statics</code>に定義したメソッドをonClickなどにバインドした時にcomponentをバインドしなくなりました。</p>

<p>```js
class Hello extends React.Component {
  statics: {</p>

<pre><code>foo() {
  this.bar();  // v0.13では呼べない
},
bar() {
  console.log("bar");
}
</code></pre>

<p>  }
  render() {</p>

<pre><code>return &lt;div&gt;hello &lt;button onClick={Hello.foo}&gt;click&lt;/button&gt;;
</code></pre>

<p>  }
}
```</p>

<h2>refを設定する処理の順番が変わりました (Breaking Change)</h2>

<p><code>ref</code>に指定されたcomponentの<code>componentDidMount</code>が呼ばれた後になります。
これは親componentのcallbackを<code>componentDidMount</code>の中で読んでいる場合だけ気にする必要があります。そもそれもこれはアンチパターンなので避けるべきですが&hellip;。</p>

<ul>
<li><code>componentDidMount</code>は子componentから順番に呼ばれるので下記の<code>refDiv</code>はChildの<code>componentDidMount</code>の時点では設定されていません。</li>
</ul>


<p>```js
class Hello extends React.Component {
  foo() {</p>

<pre><code>console.log(this.refs.refDiv);
</code></pre>

<p>  }
  render() {</p>

<pre><code>return (
  &lt;div&gt;
    &lt;Child foo={this.foo} /&gt;
    &lt;div ref="refDiv"&gt;hello&lt;/div&gt;
  &lt;/div&gt;
);
</code></pre>

<p>  }
}</p>

<p>class Child extends React.Component {
  componentDidMount() {</p>

<pre><code>this.props.foo(); // v0.13 "undefined"
</code></pre>

<p>  }
  render() {</p>

<pre><code>return &lt;div&gt;child&lt;/div&gt;;
</code></pre>

<p>  }
}
```</p>

<h2><code>this.setState()</code>が第1引数に関数を受け取れるようになりました</h2>

<p><code>js
this.setState((state, props) =&gt; ({count: state.count + 1}));
</code></p>

<p>のようにすることで<code>this._pendingState</code>を使うことなくトランザクションが必要とされるstateの更新を行うことが出来ます。</p>

<p>```js
console.log(this.state.count) // 0
this.setState({ count: this.state.count + 1 })
this.setState({ count: this.state.count + 1 })
// state.count will render as 1</p>

<p>console.log(this.state.count) // 0
this.setState(function(state, props) { return { count: state.count + 1 } });
this.setState(function(state, props) { return { count: state.count + 1 } });
// state.count will render as 2
```</p>

<h2>setStateの呼び出しが常に非同期になります (Breaking Change)</h2>

<p>ライフサイクルメソッドの中での<code>setState</code>の呼び出しが常に非同期でバッチとして処理されます。以前は最初のマウント時の呼び出しは同期的に行われていました。</p>

<p><code>
componentDidMount() {
  console.log(this.state.count) // 0
  this.setState({ count: this.state.count + 1 })
  this.setState({ count: this.state.count + 1 })
  console.log(this.state.count) // v0.13 is 2 (v0.12 is 0)
}
</code></p>

<h2>setStateとforceUpdateをunmountされたcomponentに対して呼んだ時に、エラーではなくwarningが出るようになりました (Breaking Change)</h2>

<p>非同期処理の結果を<code>setState</code>して反映させるときに、<code>isMounted</code>でブロックしなくてもよくなったのはいいですね。</p>

<h2>privateなプロパティが整理されました (Breaking Change)</h2>

<p><code>this._pendingState</code>や<code>this._rootNodeID</code>などのprivateなプロパティが削除されました。</p>

<h2>ES6 classesによるReactComponentの作成がサポートされました</h2>

<p>これについては↓に書きましたが、ES6 classesによって作成されたcomponentには<code>createClass</code>にはある<code>getDOMNode</code>、<code>setProps</code>、<code>replaceState</code>が含まれていなかったりmixinが指定出来ないなど注意点がいくつかあります。</p>

<ul>
<li><a href="http://blog.koba04.com/post/2015/01/28/published-react-v0.13.0-beta1/">http://blog.koba04.com/post/2015/01/28/published-react-v0.13.0-beta1/</a></li>
</ul>


<h2><code>React.findDOMNode(component)</code>のAPIが追加されました</h2>

<p>これは既存の<code>component.getDOMNode()</code>を置き換えるAPIです。
<code>getDOMNode()</code>はES6 classesによって作成されたcomponentでは提供されていません。</p>

<h2><code>ref</code>がcallbackスタイルで指定できるようになりました。</h2>

<p><code>js
&lt;Photo ref={(c) =&gt; this._photo = c} /&gt;
</code></p>

<p>この変更はこの後で書く<code>owner</code>の扱いの変更に関係しています。</p>

<h2>childrenにiteratorやimmutable-jsのsequenceを指定出来るようになりました</h2>

<p>immutable-jsを使っている人にとってはいいですね。</p>

<h2><code>ComponentClass.type</code>はdeprecatedになりました</h2>

<p>代わりに<code>ComponentClass</code>をそのまま使ってください。</p>

<h2>ownerベースのcontextを使っていてparentベースのcontextと一致しない場合にwarningが出るようになります</h2>

<p>そもそもowner? parent?という感じかと思うので簡単に説明します。</p>

<h3>owner and parent</h3>

<p>Reactは"parent"と"owner"を持っています。"owner"はReactElementを作ったcomponentです。</p>

<p>```js
class Foo {
  render() {</p>

<pre><code>return &lt;div&gt;&lt;span /&gt;&lt;/div&gt;;
</code></pre>

<p>  }
}
```</p>

<p>この場合、<code>span</code>のownerは<code>Foo</code>でparentは<code>div</code>になります。</p>

<h3>context</h3>

<p>これはdocument化されてないfeatureですが、"owner"から子や孫に渡すことが出来る"context"というものがあります。</p>

<p>簡単にコードを書くとこんな感じです。見てもらえればどんなfeatureなのかわかるかと思います。</p>

<p>```js
var Parent = React.createClass({</p>

<pre><code>childContextTypes: {
  name: React.PropTypes.string,
  age: React.PropTypes.number
},
getChildContext: function() {
  return {
    name: "parent",
    age: 50
  };
</code></pre>

<p>  },
  render: function() {</p>

<pre><code>return &lt;Child /&gt;;
</code></pre>

<p>  }
});</p>

<p>var Child = React.createClass({</p>

<pre><code>contextTypes: {
  name: React.PropTypes.string,
  age: React.PropTypes.number
},
componentDidMount: function() {
  console.log("Child",this.context); // {name: "parent", age: 50}
},
render: function() {
  return &lt;GrandChild /&gt;;
}
</code></pre>

<p>});</p>

<p>var GrandChild = React.createClass({</p>

<pre><code>contextTypes: {
  name: React.PropTypes.string
},
componentDidMount: function() {
  console.log("GrandChild",this.context); // {name: "parent"}
},
render: function() {
  return &lt;div&gt;hello&lt;/div&gt;;
}
</code></pre>

<p>});</p>

<p>React.render(<Parent />, document.body);
```</p>

<p><code>react-router</code>ではparentベースのcontextに依存していたので対応が大変そうでした。</p>

<h3>問題点</h3>

<ul>
<li>ownerは密かにReactElementに追加されているので気づかないうちに挙動が変わることが発生します。↓の場合はそれぞれのinputのownerが異なりますし、<code>React.addons.cloneWithProps</code>を使った場合もownerが変わります。</li>
</ul>


<p>```js
var foo = <input className="foo" />;
class Component {
  render() {</p>

<pre><code>return bar ? &lt;input className="bar" /&gt; : foo;
</code></pre>

<p>  }
}
```</p>

<ul>
<li>ownerは実行時のstackによって決定します。↓の場合、<code>span</code>のonwerは実際は<code>B</code>で<code>A</code>ではありません。これはcallbackが実行されたタイミングに依存するからです。</li>
</ul>


<p>```js
class A {
  render() {</p>

<pre><code>return &lt;B renderer={text =&gt; &lt;span&gt;{text}&lt;/span&gt;} /&gt;;
</code></pre>

<p>  }
}
class B {
  render() {</p>

<pre><code>return this.props.renderer('foo');
</code></pre>

<p>  }
}
```</p>

<ul>
<li>また、JSXが書いているscope内にReactが必要なのは、Reactが現在のownerを保持していてJSXの変換がそれに依存しているからという意外なところに影響があったりもします。</li>
</ul>


<h3>それに対する提案</h3>

<ul>
<li>ownerベースのcontextの代わりにparentベースのcontextの導入を考えているのでそれを使うことです。ほとんどのケースはparentベースのcontextでも問題ないです。</li>
<li>ownerベースのcontextが必要になる場合はほとんどないはずだしコードを見直すべきです。</li>
</ul>


<h3>未解決</h3>

<ul>
<li><code>ref</code>はまだownerベースのままで、これについてはまだ完全に解決出来ていません。

<ul>
<li>v0.13ではcallbackでもrefが定義出来るようなりましたがこれまでの宣言的な定義方法も残されています。宣言的な定義方法に代わる何かいい方法がない限りこのAPIは廃止されません。</li>
</ul>
</li>
</ul>


<h2><code>{key: element}</code>(Keyed Object)の形式でchildに渡すとwarningが出るようになりました</h2>

<p>v0.12では<code>{key: element}</code>の形式でkeyが指定したらelementを渡すことが出来ましたが、これはあまり使われてないし問題となる場合があるので使うべきではないのでwarningが出るようになりました。</p>

<p>```js</p>

<div>{ {a: <span />, b: <span />} }</div>


<p>```</p>

<h3>問題点</h3>

<ul>
<li>列挙される順番はkeyに数値を指定した場合を除いては仕様として定義されてないので実装次第になってしまいます。</li>
<li>一般的にobjectをmapとして扱うことは型システムやVMの最適化やコンパイラーにとって好ましくないし、さらにセキュリティ上のリスクもあって↓のような場合にもし<code>item.title === '__proto__'</code> を指定されたら&hellip;.</li>
</ul>


<p><code>js
var children = {};
items.forEach(item =&gt; children[item.title] = &lt;span /&gt;);
return &lt;div&gt;{children}&lt;/div&gt;;
</code></p>

<h3>それに対する解決</h3>

<ul>
<li>ほとんどの場合、<code>key</code>を設定したReactElementの配列にすれば問題ないはずです。</li>
</ul>


<p>```js
var children = items.map(item => <span key={item.title} />);</p>

<div>{children}</div>


<p>```</p>

<ul>
<li><code>this.props.children</code>を使った場合など、<code>key</code>を指定することが出来ない場合もあるかもしれません。その場合はv0.13で追加された<code>React.addons.createFragment</code>を使うことでKeyed ObjectからReactElementを作成することが出来ます。

<ul>
<li>注意として、これはまだrenderの戻り値として直接渡せるものではないので<div>などでラップしてあげる必要があります。</li>
</ul>
</li>
</ul>


<p>```js</p>

<p><div>{React.addons.createFragment({ a: <div />, b: this.props.children })}</div>
```</p>

<h2><code>React.cloneElement</code>が追加されました</h2>

<p>これはこれまで<code>React.addons.cloneWithProps</code>と似たAPIです。
異なる点としては、<code>style</code>や<code>className</code>のmergeが行われなかったり<code>ref</code>が保持される点があります。
<code>cloneWithProps</code>を使ってchildrenを複製した時に<code>ref</code>が保持されなくて問題となるという報告が多くあったのでこのAPIでは<code>ref</code>を保持するようになりました。
<code>cloneElement</code>時に<code>ref</code>を指定すると上書きされます。</p>

<p><code>js
var newChildren = React.Children.map(this.props.children, function(child) {
  return React.cloneElement(child, { foo: true })
});
</code></p>

<p>このAPIはv0.13でPropがimmutableなものとして扱われるようになったことで、Propを変更するためにelementをcloneする機会が増えたため必要となりました。
<code>React.addons.cloneWithProps</code>はそのうちdeprecateになりますが今回のタイミングではなりません。</p>

<h2><code>React.addons.classSet</code>がdeprecatedになりました</h2>

<p>必要な場合は<a href="https://www.npmjs.com/package/classnames">classnames</a>などを使用してください。</p>

<h2>jsxコマンドで<code>--target</code>optionとしてECMAScript versionを指定出来るようになりました。 (Breaking Change)</h2>

<p><code>es5</code>がデフォルトです。
<code>es3</code>はこれまでの挙動ですが追加で予約語を安全に扱うようになりました(eg <code>this.static</code>は<code>this['static']</code>にIE8での互換性のために変換されます)。</p>

<h2>jsxコマンドでES6 syntaxで変換した際にclassメソッドがdefaultではenumerableではなくなりました</h2>

<p><code>Object.defineProperty</code>を使用しているため、IE8などをサポートしたい場合は<code>--target es3</code>optionを渡す必要があります。</p>

<ul>
<li>Original</li>
</ul>


<p>```js
class Hello extends React.Component {
  foo() {</p>

<pre><code>console.log("foo");
</code></pre>

<p>  }
  render() {</p>

<pre><code>return &lt;div&gt;hello&lt;/div&gt;;
</code></pre>

<p>  }
}
Hello.static = {
  bar() {</p>

<pre><code>console.log("bar");
</code></pre>

<p>  }
};
```</p>

<ul>
<li>ES5</li>
</ul>


<p>```js
var <strong><strong>Class0=React.Component;for(var </strong></strong>Class0<strong><strong>Key in </strong></strong>Class0){if(<strong><strong>Class0.hasOwnProperty(</strong></strong>Class0<strong><strong>Key)){Hello[</strong></strong>Class0<strong><strong>Key]=</strong></strong>Class0[<strong><strong>Class0</strong></strong>Key];}}var <strong><strong>SuperProtoOf</strong></strong>Class0=<strong><strong>Class0===null?null:</strong></strong>Class0.prototype;Hello.prototype=Object.create(<strong><strong>SuperProtoOf</strong></strong>Class0);Hello.prototype.constructor=Hello;Hello.<strong>superConstructor</strong>=<strong><strong>Class0;function Hello(){&ldquo;use strict&rdquo;;if(</strong></strong>Class0!==null){____Class0.apply(this,arguments);}}
  Object.defineProperty(Hello.prototype,&ldquo;foo&rdquo;,{writable:true,configurable:true,value:function() {&ldquo;use strict&rdquo;;</p>

<pre><code>console.log("foo");
</code></pre>

<p>  }});
  Object.defineProperty(Hello.prototype,&ldquo;render&rdquo;,{writable:true,configurable:true,value:function() {&ldquo;use strict&rdquo;;</p>

<pre><code>return React.createElement("div", null, "hello");
</code></pre>

<p>  }});</p>

<p>Hello.static = {
  bar:function() {</p>

<pre><code>console.log("bar");
</code></pre>

<p>  }
};
```</p>

<ul>
<li>ES3</li>
</ul>


<p>```js
var <strong><strong>Class0=React.Component;for(var </strong></strong>Class0<strong><strong>Key in </strong></strong>Class0){if(<strong><strong>Class0.hasOwnProperty(</strong></strong>Class0<strong><strong>Key)){Hello[</strong></strong>Class0<strong><strong>Key]=</strong></strong>Class0[<strong><strong>Class0</strong></strong>Key];}}var <strong><strong>SuperProtoOf</strong></strong>Class0=<strong><strong>Class0===null?null:</strong></strong>Class0.prototype;Hello.prototype=Object.create(<strong><strong>SuperProtoOf</strong></strong>Class0);Hello.prototype.constructor=Hello;Hello.<strong>superConstructor</strong>=<strong><strong>Class0;function Hello(){&ldquo;use strict&rdquo;;if(</strong></strong>Class0!==null){____Class0.apply(this,arguments);}}
  Hello.prototype.foo=function() {&ldquo;use strict&rdquo;;</p>

<pre><code>console.log("foo");
</code></pre>

<p>  };
  Hello.prototype.render=function() {&ldquo;use strict&rdquo;;</p>

<pre><code>return React.createElement("div", null, "hello");
</code></pre>

<p>  };</p>

<p>Hello[&ldquo;static&rdquo;] = {
  bar:function() {</p>

<pre><code>console.log("bar");
</code></pre>

<p>  }
};
```</p>

<h2>JSXによる変換でharmony optionを有効にすることでspread operatorを使えるようになりました</h2>

<p>JSXの中ではこれまでもspread attributesとしてサポートしていましたが、JSのコード内でも使えるようになりました。</p>

<p><code>js
var [a, b, ...other] = [1,2,3,4,5];
</code></p>

<h2>JSXのparseに変更があります (Breaking Change)</h2>

<p>elementの内側に<code>&gt;</code> or <code>}</code> を使った時に以前は文字列として扱われましたがparseエラーになるようになりました。</p>

<p><code>js
render() {
  return &lt;div&gt;} or &gt;&lt;/div&gt;; // parse error!
}
</code></p>

<h2>v0.14に向けて</h2>

<p>今回の変更を踏まえてReact v0.14では静的な要素においていくつかの最適化が可能になります。
これらの最適化は以前はtemplate-baseなフレームワークでのみ可能でしたが、ReactでもJSXと<code>React.createElement/Factory</code>のどちらでも可能になります。</p>

<p>詳細は下記のissueにあります。
まだ議論もされてないので変わる可能性は大きいと思いますが。</p>

<h3>Reuse Constant Value Types</h3>

<ul>
<li><a href="https://github.com/facebook/react/issues/3226">https://github.com/facebook/react/issues/3226</a></li>
</ul>


<p>これは静的なelementに変更できないものとして扱うことでdiffのコストを減らすというものです。</p>

<p>例えばこんな感じにするとか</p>

<p><code>js
function render() {
   return &lt;div className="foo" /&gt;;
}
↓
var foo = &lt;div className="foo" /&gt;;
function render() {
   return foo;
}
</code></p>

<h3>Tagging ReactElements]</h3>

<ul>
<li><a href="https://github.com/facebook/react/issues/3227">https://github.com/facebook/react/issues/3227</a></li>
</ul>


<p>これはReactElementにtag付けをしてそれを使ってdiffアルゴリズムを最適化するというもののようです。</p>

<h3>Inline ReactElements</h3>

<ul>
<li><a href="https://github.com/facebook/react/issues/3228">https://github.com/facebook/react/issues/3228</a></li>
</ul>


<p>これはproductionビルドのときに、React.createElementではなくてinline objectに変換することでReact.createElementのコストを削減するというものです。</p>

<p>こんな感じ</p>

<p><code>js
&lt;div className="foo"&gt;{bar}&lt;Baz key="baz" /&gt;&lt;/div&gt;
↓
{ type: 'div', props: { className: 'foo', children:
  [ bar, { type: Baz, props: { }, key: 'baz', ref: null } ]
}, key: null, ref: null }
</code></p>

<p>こうするとReact.createElementの時に行っているPropTypesやkeyに対するvalidationが出来ないので、developmentビルドの時には適用しないことを想定しているようです。</p>

<hr />

<p>というわけで、React v0.13をダラダラと書いてみました。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[React v0.13.0 Beta1でclassでComponentが作れるようになった]]></title>
    <link href="http://blog.koba04.com/post/2015/01/28/published-react-v0.13.0-beta1/"/>
    <updated>2015-01-28T17:20:35+09:00</updated>
    <id>http://blog.koba04.com/post/2015/01/28/published-react-v0.13.0-beta1</id>
    <content type="html"><![CDATA[<p>React.js Confの前日にv0.13.0 Beta1がnpmにpublishされました。</p>

<p><a href="http://facebook.github.io/react/blog/2015/01/27/react-v0.13.0-beta-1.html">http://facebook.github.io/react/blog/2015/01/27/react-v0.13.0-beta-1.html</a></p>

<p>featureは色々あるみたいですが、↑のブログにはその1つとしてClassによるReact Componentの作成が紹介されていたのでそれについて書きたいと思います。</p>

<p>ちなみに<code>React.createClass</code>を使う場合はこれまでと同じままで大丈夫なはずです。</p>

<!-- more -->


<h2>ES6 Classes</h2>

<p><code>React.createClass</code>ではなくて、ES6のclassを使って↓みたいな感じで書けるようになります。</p>

<p>```js
import {React} from &lsquo;react&rsquo;;</p>

<p>export class Hello extends React.Component {
  constructor(props) {</p>

<pre><code>super(props);
this.state = { val: props.foo * 2 };
</code></pre>

<p>  }
  onClick() {</p>

<pre><code>this.setState({ val: this.state.val * 2 });
</code></pre>

<p>  }
  render() {</p>

<pre><code>return (
  &lt;div&gt;
    &lt;p&gt;state is {this.state.val}. props is {this.props.foo}&lt;/p&gt;
    &lt;button onClick={this.onClick.bind(this)}&gt;click&lt;/button&gt;
  &lt;/div&gt;
);
</code></pre>

<p>  }
}
Hello.propTypes = {
  foo: React.PropTypes.number
};
```</p>

<p>ポイントとしては</p>

<ul>
<li><code>React.Component</code>をextendsします。</li>
<li><code>constructor</code>に<code>props</code>が引数として渡ってくるのでそれを使って必要に応じて<code>state</code>の初期化をする。

<ul>
<li><code>getInitialState</code>は使うことができません。(warnが出ます)</li>
</ul>
</li>
<li>Autobindingはされなくなったので明示的に<code>this.onClick.bind(this)</code>のようにする必要があります。</li>
<li><code>propTypes</code>や<code>defaultProps</code>はconstructorのpropertyとして指定する必要があります。</li>
<li>現時点で<code>mixin</code>はclassで書いた場合は使うことができません。</li>
</ul>


<p>といった辺りです。</p>

<h3>変換</h3>

<p>ES6のコードの変換は、これまで通りreact-toolsでjsxの<code>--harmony</code>optionを有効にしたり6to5使ったりする感じです。</p>

<h3>今後</h3>

<p>今の書き方だと微妙に感じるところも結構あるのですが、最終的には↓のような形で書けるようにしたいみたいです。</p>

<p>```js
import {React} from &lsquo;react&rsquo;;</p>

<p>export class Hello extends React.Component {
  propTypes = { foo: React.PropTypes.number };
  state = { val: this.props.foo * 2 };
  onClick = () => {</p>

<pre><code>this.setState({ val: this.state.val * 2 });
</code></pre>

<p>  };
  render() {</p>

<pre><code>return (
  &lt;div&gt;
    &lt;p&gt;state is {this.state.val}. props is {this.props.foo}&lt;/p&gt;
    &lt;button onClick={this.onClick}&gt;click&lt;/button&gt;
  &lt;/div&gt;
);
</code></pre>

<p>  }
}
```</p>

<p>mixinについてはreact-futureを見る限りこんな感じになるのかもしれないですね。</p>

<p><a href="https://github.com/reactjs/react-future/blob/master/01%20-%20Core/02%20-%20Mixins.js">https://github.com/reactjs/react-future/blob/master/01%20-%20Core/02%20-%20Mixins.js</a></p>

<p>```js
import { mixin } from &ldquo;react-utils&rdquo;;
import { Component } from &ldquo;react&rdquo;;</p>

<p>const A = {
  componentDidMount() {</p>

<pre><code>super();
console.log('A');
</code></pre>

<p>  }
};</p>

<p>class Hello extends mixin(Component, A) {
  render() {</p>

<pre><code>return &lt;div /&gt;;
</code></pre>

<p>  }
}
```</p>

<h3>CoffeeScript &amp; TypeScript</h3>

<p>ちなみにES6だけでなく、CoffeescriptやTypeScriptのClass syntaxでもかけます。</p>

<hr />

<p>React.js自体でやることを減らしてES6、7のfeatureに任せることが出来るところは任せようといった方向性を感じて個人的にはいいんじゃないかと思っています。</p>

<p>React.js Conf行きたかった&hellip;</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A combination of React.js and 6to5]]></title>
    <link href="http://blog.koba04.com/post/2015/01/13/a-combination-of-reactjs-and-6to5/"/>
    <updated>2015-01-13T18:50:28+09:00</updated>
    <id>http://blog.koba04.com/post/2015/01/13/a-combination-of-reactjs-and-6to5</id>
    <content type="html"><![CDATA[<p>In English article is <a href="http://en.blog.koba04.com/2015/02/04/a-combination-of-reactjs-and-6to5/">here</a>.</p>

<p>今までは、react-toolsを使ってjsxのharmony optionを有効にして書くことで一部のES6のfeatureが使えて満足していたのですが、azuさんの記事を見て6to5を試したくなったのでReact.js + 6to5の組み合わせで書いてみました。</p>

<ul>
<li><a href="https://6to5.org/">https://6to5.org/</a></li>
<li><a href="http://efcl.info/2015/01/09/write-es6/">http://efcl.info/2015/01/09/write-es6/</a></li>
</ul>


<p>結論から言うと6to5自体がjsxのサポートもしているので何も意識することなく書けていい感じでした。</p>

<p>コードはこんな感じ。</p>

<p><a href="https://github.com/koba04/react-boilerplate">https://github.com/koba04/react-boilerplate</a></p>

<!-- more -->


<h2>structure</h2>

<h3>browserify + 6to5ify</h3>

<p>変換の流れはbrowserifyのtransformである6to5ifyを使うので、</p>

<p>```
ES6  &ndash;>   CommonJS(ES5)      &ndash;>       bundle.js</p>

<pre><code>6to5                 browserify
</code></pre>

<p>```</p>

<p>な形になっています。</p>

<p>AltJSで書くときと同じ流れです。</p>

<h2>configuration</h2>

<p><a href="https://github.com/koba04/react-boilerplate/blob/master/package.json">https://github.com/koba04/react-boilerplate/blob/master/package.json</a></p>

<h3>bundle.js</h3>

<p>bundle.jsの作成はただ、6to5ifyをtransformとして指定するだけです。</p>

<p>```js
  &ldquo;scripts&rdquo;: {</p>

<pre><code>"watch": "watchify app/index.js -o dist/bundle.js -v",
"build": "browserify app/index.js &gt; dist/bundle.js"
</code></pre>

<p>  },
  &ldquo;browserify&rdquo;: {</p>

<pre><code>"transform": [
  [ "6to5ify" ]
]
</code></pre>

<p>  }
```</p>

<h3>start server</h3>

<p>serverを立ち上げる時は、entry pointとなるserver.jsもES6で書きたいので、6to5に含まれている<code>6to5-node</code>コマンドを利用します。</p>

<p>```
  &ldquo;scripts&rdquo;: {</p>

<pre><code>"start": "6to5-node server"
</code></pre>

<p>  },
```</p>

<p>これによってserver.jsもES6で書くことが出来るようになります。</p>

<p>```js
&lsquo;use strict&rsquo;;</p>

<p>import express  from &lsquo;express&rsquo;;
import React    from &lsquo;react&rsquo;;
import App      from &lsquo;./app/components/App&rsquo;;</p>

<p>let app     = express();
let handler = (name) => {
  return (req, res) => {</p>

<pre><code>let html = React.renderToString(React.createElement(App, {
  path: "/" + name
}));
res.send(html);
</code></pre>

<p>  };
};</p>

<p>app.get(&lsquo;/&rsquo;,        handler(&lsquo;&rsquo;));
app.get(&lsquo;/artist&rsquo;,  handler(&lsquo;artist&rsquo;));
app.get(&lsquo;/country&rsquo;, handler(&lsquo;country&rsquo;));</p>

<p>app.use(express.static(__dirname+&lsquo;/dist&rsquo;));</p>

<p>let port = process.env.PORT || 5000;
console.log(&ldquo;listening&hellip;&rdquo; + port);
app.listen(port);
```</p>

<h3>test by Jest</h3>

<p>Jestのテストについても<code>6to5-jest</code>というmoduleがあるのでそれをinstallして、scriptPreprocessorに指定するだけです。</p>

<p>```js
  &ldquo;jest&rdquo;: {</p>

<pre><code>"scriptPreprocessor": "&lt;rootDir&gt;/node_modules/6to5-jest",
</code></pre>

<p>  }
```</p>

<p>こんな感じで書けます。</p>

<p>```js
&lsquo;use strict&rsquo;;</p>

<p>jest.dontMock(&lsquo;../InputArtist&rsquo;);</p>

<p>import React                    from &lsquo;react/addons&rsquo;;
import InputArtist              from &lsquo;../InputArtist&rsquo;;
import AppTracksActionCreators  from &lsquo;../../actions/AppTracksActionCreators&rsquo;;</p>

<p>describe(&ldquo;inputArtist&rdquo;, () => {
  let inputArtist;
  beforeEach(() => {</p>

<pre><code>inputArtist = React.addons.TestUtils.renderIntoDocument(&lt;InputArtist /&gt;);
</code></pre>

<p>  });</p>

<p>  describe(&ldquo;state&rdquo;,  () => {</p>

<pre><code>it("set inputArtist radiohead", () =&gt; {
  expect(inputArtist.state.inputArtist).toBe("radiohead");
});
</code></pre>

<p>  });</p>

<p>  describe(&ldquo;handleSubmit&rdquo;, () => {</p>

<pre><code>let preventDefault;
beforeEach(() =&gt; {
  preventDefault = jest.genMockFunction();
  inputArtist.setState({ inputArtist: 'travis' });
  React.addons.TestUtils.Simulate.submit(inputArtist.getDOMNode(), {
    preventDefault: preventDefault
  });
});
it ("calls AppTracksActionCreators.fetchByArtist with state.inputArtist", () =&gt; {
  expect(AppTracksActionCreators.fetchByArtist).toBeCalled();
  expect(AppTracksActionCreators.fetchByArtist).toBeCalledWith('travis');
});
it ("calls e.preventDefault", () =&gt; {
  expect(preventDefault).toBeCalled();
});
</code></pre>

<p>  });</p>

<p>});
```</p>

<h2>code</h2>

<h3>JSX</h3>

<p>6to5ではjsxもサポートしているので、何も意識することなくjsxを書いておくことが出来ます。</p>

<p><a href="https://6to5.org/docs/usage/jsx/">https://6to5.org/docs/usage/jsx/</a></p>

<h3>ES6 modules</h3>

<p>今までは、ES6を感じながらcommonJS styleで書くのもちょっとなぁという気持ちがありましたがこれによってES6 modulesのstyleで書くことが出来ていい感じです。</p>

<p>```js
&lsquo;use strict&rsquo;;</p>

<p>import React        from &lsquo;react&rsquo;;
import Nav          from &lsquo;./Nav&rsquo;;
import Footer       from &lsquo;./Footer&rsquo;;
import InputArtist  from &lsquo;./InputArtist&rsquo;;
import Tracks       from &lsquo;./Tracks&rsquo;;
import TrackStore   from &lsquo;../stores/TrackStore&rsquo;;</p>

<p>export default React.createClass({
  displayName: &lsquo;Artist&rsquo;,
  render() {</p>

<pre><code>let style = {
  title: {
    fontFamily: "'Poiret One', cursive"
  }
};
return (
  &lt;div&gt;
    &lt;header className="page-header"&gt;
      &lt;h1 style={style.title}&gt;Artist Top Tracks &lt;small&gt;by Last.FM&lt;/small&gt;&lt;/h1&gt;
    &lt;/header&gt;
    &lt;Nav current="artist" /&gt;
    &lt;article className="main-content"&gt;
      &lt;InputArtist /&gt;
      &lt;Tracks /&gt;
    &lt;/article&gt;
    &lt;Footer /&gt;
  &lt;/div&gt;
);
</code></pre>

<p>  }
});
```</p>

<p>直接export defaultにComponentのClassを渡しているので、displayNameは明示的に指定しています。</p>

<hr />

<p>というわけでReact.jsのコードを6to5使ってES6で簡単に書くことが出来るという話でした。</p>

<p>個人的には今後書くコードはES6で書いていきたい感じです。</p>

<p>6to5シンプルに使えていいですね。</p>
]]></content>
  </entry>
  
</feed>

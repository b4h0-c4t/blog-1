<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: javascript | blog.koba04.com]]></title>
  <link href="http://blog.koba04.com/blog/categories/javascript/atom.xml" rel="self"/>
  <link href="http://blog.koba04.com/"/>
  <updated>2018-04-05T17:22:46+09:00</updated>
  <id>http://blog.koba04.com/</id>
  <author>
    <name><![CDATA[koba04]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[天下一クライアントサイドJS MV*レームワーク武道会で話しました #ten1club]]></title>
    <link href="http://blog.koba04.com/post/2014/07/12/talked-at-ten1club/"/>
    <updated>2014-07-12T23:13:39+09:00</updated>
    <id>http://blog.koba04.com/post/2014/07/12/talked-at-ten1club</id>
    <content type="html"><![CDATA[<p><a href="http://connpass.com/event/6910/">http://connpass.com/event/6910/</a></p>

<p>「天下一クライアントサイドJS MV*フレームワーク武道会」でMarionette.jsについてのLTとパネルディスカッションをさせて頂きました。</p>

<!-- more -->


<p>JavaScriptについて外部で話すの初めてだったのでドキドキしてましたが本当にとても面白いイベントでした。</p>

<p><a href="https://twitter.com/yosuke_furukawa">@yosuke_furukawa</a>さんに感謝です。++</p>

<p>ありがとうございます！</p>

<h2>LT</h2>

<p>Marionette.jsについてを簡単に説明した感じです。面白みがないですが&hellip;。興味があれば見てみてください。</p>

<p><a href="https://speakerdeck.com/koba04/5fen-dewakarumarionette-dot-jsfalseiitokoro">5分でわかるMarionette.jsのいいところ</a></p>

<p>他の方の発表もみんな面白かったです。Reactが気になっていたのでその辺りも少し聞けてよかったです。</p>

<h2>パネルディスカッション</h2>

<p><a href="https://twitter.com/mizchi">@mizchi</a>さん、<a href="https://twitter.com/damele0n">@damele0n</a>さん、<a href="https://twitter.com/hokaccha">@hokaccha</a>さん、<a href="https://twitter.com/teppeis">@teppeis</a>さんという豪華なメンバーに紛れて参加させて頂いたいのですが、うまく伝えられず反省する点もありましたが聞いていてとても楽しくてあっという間の1時間でした。また機会があれば続きをやりたいです。</p>

<h2>懇親会</h2>

<p>色んな方に声を掛けて頂き、面白い話がいっぱい聞けて楽しかったです。ブログ見たと言ってもらえたのが嬉しかったのと、意外とMarionette.js使われていて同じようなところで悩んでるなぁとわかってよかったです。懇親会後のWebComponents話も面白かったです。</p>

<h2>最強のフレームワーク??</h2>

<p>まぁぶっちゃけ、このフレームワーク使っておけばいいというものはなくて、「誰が触るのか」、「どんなアプリなのか」によって全く答えは変わってくるので、選択肢を自分の中で持っておくことが大切なんじゃないかなと思いました。</p>

<h2>蛇足</h2>

<p>ちなみに個人的には、Vue.js、browserify辺りを使って、テストはkarma、mocha、power-assertとか組み合わせるのが今は好きです。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Karma for JavaScript test runner]]></title>
    <link href="http://blog.koba04.com/post/2014/06/23/karma-for-javascript-test-runner/"/>
    <updated>2014-06-23T00:48:32+09:00</updated>
    <id>http://blog.koba04.com/post/2014/06/23/karma-for-javascript-test-runner</id>
    <content type="html"><![CDATA[<p><img src="/images/karma.png" title="&lsquo;karma&rsquo;" ></p>

<p>今まではなんとなくtestemを使っていたのですが、Karmaを検討する必要があったので試してみました。</p>

<p>サンプルの設定などは↓で見ることが出来ます。</p>

<ul>
<li><a href="https://github.com/koba04/backbone-boilerplate">https://github.com/koba04/backbone-boilerplate</a></li>
</ul>


<!-- more -->


<h2>testem to karma</h2>

<p>これまでは業務でもtestemを使っていて、テストの数が少ないうち(1000以下)は問題なかったのですが、
段々テストが増えてくるとCPU100%になってテストが走るブラウザが固まることが増えてきて辛い感じになってきました。</p>

<p>そんなときに下記の記事を見て同じような現象だなと思いKarmaを試してみることにしました。</p>

<ul>
<li><a href="http://developer.cybozu.co.jp/tech/?p=7089">http://developer.cybozu.co.jp/tech/?p=7089</a></li>
</ul>


<h2>Installation</h2>

<p>インストールは<strong>npm install karma</strong>するだけです。</p>

<p>globalでkarmaのコマンドが使いたい場合はgruntのように<strong>npm install -g karma-cli</strong>します。</p>

<ul>
<li>karmaはglobalに入れません。</li>
</ul>


<h2>Easy to use</h2>

<p>テストを読み込むためのHTMLを用意して色々書いたりする必要がなくて、<strong>karma init</strong>してframeworkやテスト対象のファイルを指定して、
<strong>karma start</strong>するだけで変更を監視しての自動テストを行うことが出来ます。簡単です。</p>

<h2>Configration</h2>

<p>最初の設定は、<strong>karma init</strong>することで対話的に作成することが出来て、終了すると<strong>karma.conf.js</strong>が作成されます。</p>

<p>ちなみに<strong>karma init karma.conf.coffee</strong>のように拡張子をcoffeeにして指定することでcoffeescriptで作成することも出来ます。</p>

<p>生成されたファイルはこんな感じで、使うフレームワークや対象ファイル、実行するブラウザ、出力形式、ファイルの変更を監視して自動でテストするか、テスト終了後もプロセスを残すかどうかなどを設定します。</p>

<ul>
<li>設定項目の抜粋</li>
</ul>


<p>```js
module.exports = function(config) {
  config.set({</p>

<pre><code>// ベースとなるパス
basePath: '',

// 使用するフレームワーク。ここから探せる https://npmjs.org/browse/keyword/karma-adapter
frameworks: ['mocha'],

// 読み込むファイル(テスト対象のファイルやテストファイルなど)。
files: ['js/*.js'],

// filesから除外したファイル
exclude: [],

// テストの実行前に差し込む処理。ここから探せる https://npmjs.org/browse/keyword/karma-preprocessor
preprocessors: {}

// テストの結果を出力する形式。ここから探せる https://npmjs.org/browse/keyword/karma-reporter
// 'dots'と'progress'は最初から使える
reporters: ['progress'],

// 使用するport
port: 9876,

// 出力に色を付けるか
colors: true,

// ログレベル: config.LOG_DISABLE || config.LOG_ERROR || config.LOG_WARN || config.LOG_INFO || config.LOG_DEBUG
logLevel: config.LOG_INFO,

// ファイルの変更を監視してテストを自動的に実行するかどうか
autoWatch: true,

// テストするブラウザ。ここから探せる https://npmjs.org/browse/keyword/karma-launcher
browsers: ['Chrome'],

// trueにすると一回テストを実行するとプロセスが終了する
// CIのときに使ったり。
singleRun: false
</code></pre>

<p>  });
};
```</p>

<p>その他では、<strong>autoWatchBatchDelay</strong>を使うと指定したms内での変更をまとめて一つとして扱ってくれるので、監視対象のファイルが短い時間に連続して更新されて複数回テストが実行される場合は、この値を長めにするといいかもしれません(defaultは250ms)。</p>

<h2>Browsers</h2>

<p>ブラウザはChromeやSafariやPhantomJSなど色々ありますので、<strong>karma-xxx-launcher</strong>で探すことが出来ます。</p>

<h2>Frameworks</h2>

<p><strong>mocha</strong>や<strong>jasmine</strong>や<strong>qunit</strong>などの場合は<strong>karma-mocha</strong>のようにすでにadapterが用意されているので、
ここにframeworkを設定に書いてadapterをインストールするだけで使うことが出来ます。</p>

<h3>karma-mocha-debug</h3>

<ul>
<li><a href="https://github.com/maksimr/karma-mocha-debug">https://github.com/maksimr/karma-mocha-debug</a></li>
</ul>


<p><code>js
frameworks: ['mocha-debug', 'mocha'],
</code></p>

<p>testem+mochaでやっている時に、ブラウザで結果を確認してそこから指定したテストだけを再実行出来るのが便利だったので
karmaでも出来ないないかな思って調べるみると、karma-mocha-debugを使うと出来るようでした。
karmaのブラウザからdebugボタンを押してdebug.htmlを開くと見ることが出来ます。素晴らしい！</p>

<p><img src="/images/karma-mocha-debug.png" title="&lsquo;karma mocha debug&rsquo;" ></p>

<h2>Preprocessors</h2>

<p>preprocessorsを指定することで<strong>files</strong>に書いたファイルに対してテストを実行する前に処理を挟むことが出来、柔軟なテストの設定が可能です。</p>

<p>coffeescriptのコンパイルだったりbrowserifyのビルドなどで<strong>karma-xxxx-preprocessor</strong>で探すことが出来ます。</p>

<p><code>js
preprocessors: {
  '**/*.coffee': ['coffee']
}
</code></p>

<h3>karma-html2js-preprocessor</h3>

<ul>
<li><a href="https://github.com/karma-runner/karma-html2js-preprocessor">https://github.com/karma-runner/karma-html2js-preprocessor</a></li>
</ul>


<p>また、karma-html2js-preprocessorというものもあって、これを使うと指定したHTMLを<strong>window.__html__[&lsquo;name.html&rsquo;]</strong>に入れてくれるので、fixtureデータとして使うことが出来ます。アプリのテストだとどうしてもDOMが必要になるので便利です。</p>

<p><code>js
files: [
  '**/*.html'
],
preprocessors: {
  '**/*.html': ['html2js']
},
</code></p>

<p><code>coffeescript
before -&gt;
  $('body').append window.__html__['fixture.html']
</code></p>

<h2>Reporters</h2>

<p>reporterを指定することで、様々な形式でテストの結果を出力したり通知したりすることが出来ます。</p>

<p>karma-xxxx-reporterで探すことが出来て、
nyanやtapやmocha形式のような出力形式のカスタマイズ以外にも、結果をgrowlやmp3で通知したりcoverageを計測したりなどさまざまなreporterがあります。</p>

<h3>karma-nyan-reporter</h3>

<ul>
<li><a href="https://github.com/dgarlitt/karma-nyan-reporter">https://github.com/dgarlitt/karma-nyan-reporter</a></li>
</ul>


<p><code>js
reporters: ["nyan"]
</code></p>

<p>nyanの形式でテストを出力してくれるのでもっとテスト書こうという気持ちになっていいです。(バグってたのpull reqして直してもらいました&hellip;)</p>

<p><img src="/images/karma-nyan-reporter.gif" title="&lsquo;karma nyan reporter&rsquo;" ></p>

<h3>karma-growl-reporter,karma-osx-reporter</h3>

<ul>
<li><a href="https://github.com/petrbela/karma-osx-reporter">https://github.com/petrbela/karma-osx-reporter</a></li>
<li><a href="https://github.com/karma-runner/karma-growl-reporter">https://github.com/karma-runner/karma-growl-reporter</a></li>
</ul>


<p><code>js
reporters: ["growl", "osx"]
</code></p>

<p>GrowlかNotificationCenterでテストの結果を通知してくれるので便利です。</p>

<h3>karma-mp3-reporter</h3>

<p><a href="https://github.com/x2es/karma-mp3-reporter">https://github.com/x2es/karma-mp3-reporter</a></p>

<p>成功したとき、失敗したときに好きな音が流せて楽しいですね。</p>

<p>```js
reporters: [&ldquo;mp3&rdquo;]</p>

<p>mp3Reporter: {
  red: &ldquo;go-to-hell.mp3&rdquo;,
  green: &ldquo;happy.mp3&rdquo;
}
```</p>

<h3>karma-mocha-reporter</h3>

<p><a href="https://github.com/litixsoft/karma-mocha-reporter">https://github.com/litixsoft/karma-mocha-reporter</a></p>

<p>mochaの形式で出力してくれるreporterなのですが、describeとitに与える説明をObjectが持っている関数名にすると"Cannot assign to read only property"というエラーになるので注意が必要です(describe &ldquo;method名"の形式で書いていたのでハマった&hellip;)。</p>

<p>```coffeescript</p>

<h1>Error!!!!</h1>

<p>describe &ldquo;constructor&rdquo;, &ndash;>
  it &ldquo;xxxx&rdquo;, &ndash;></p>

<pre><code>...
</code></pre>

<p>```</p>

<p>原因としては、下記のようにdescriptionをpropertyとして使っているため、constructorやtoStringとかを指定すると関数が取得されて、そこにnameを追加しようとしてエラーになる感じです(use strictが指定されてるためエラーになる)。</p>

<ul>
<li><a href="https://github.com/litixsoft/karma-mocha-reporter/blob/master/index.js#L178-L182">https://github.com/litixsoft/karma-mocha-reporter/blob/master/index.js#L178-L182</a></li>
</ul>


<p>```js</p>

<pre><code>    path.reduce(function (suite, description, depth) {
        var item = suite[description] || {};
        suite[description] = item;

        item.name = description;
</code></pre>

<p>```</p>

<h2>Conclution</h2>

<p>というわけでKarmaを試したのですが、思った以上に簡単に始めることが出来て、<strong>preprocessors</strong>や<strong>reporters</strong>などの仕組みがあってプラガブルな感じがとてもいいなぁと思いました。</p>

<p>今後もっとpluginが増えていくことに期待です。</p>

<h2>おまけ</h2>

<h3>power-assert対応しました</h3>

<p>もともとbrowserifyを使っていたので、transformにespowerifyを指定してあとはテストをassertに書き換えるだけだったのでとても簡単に出来てよかったです！素晴らしい！</p>

<p>コミットログはこの辺り。 <a href="https://github.com/koba04/backbone-boilerplate/commit/2fadec43e46f99cce0d3d828c66d4b12d758f4f0">https://github.com/koba04/backbone-boilerplate/commit/2fadec43e46f99cce0d3d828c66d4b12d758f4f0</a></p>

<p><img src="/images/power-assert.png" title="&lsquo;power-assert&rsquo;" ></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[npmやbowerライブラリのバージョン管理]]></title>
    <link href="http://blog.koba04.com/post/2014/03/03/npm-and-bower-semantic-version/"/>
    <updated>2014-03-03T23:11:37+09:00</updated>
    <id>http://blog.koba04.com/post/2014/03/03/npm-and-bower-semantic-version</id>
    <content type="html"><![CDATA[<h2>npmとbowerライブラリのバージョン管理</h2>

<p>npmやbowerのライブラリをプロジェクトに導入するときは、"npm install &mdash;save xxx"や"bower install &mdash;save xxx"のような形で指定してインストールとpackage(bower).jsonへの記録をしたりします。</p>

<p>その場合、package(bower).jsonには"xxx": &ldquo;~x.y.z"という形式で記録されます。</p>

<p>&ldquo;~x.y.z"という表記は、&rdquo;~1.2.3"だとすると1.2.3 &lt;= x.x.x &lt; 1.3.0 の間での最新バージョンがインストールされます。</p>

<!-- more -->


<ul>
<li><a href="https://www.npmjs.org/doc/misc/semver.html">https://www.npmjs.org/doc/misc/semver.html</a></li>
</ul>


<p>なので"~&ldquo;で指定していると、同じpackage(bower).jsonでもインストールするタイミングによって微妙に異なるバージョンがインストールされることになります。</p>

<p><del>npmやbowerにはGemのGemfile.lockやCartonのcpanfile.snapshotのように依存も含めたバージョンを固定するような仕組みはないと思います。</del></p>

<p><del>かと言ってnode_modulesとかbower_componentsをrepositoryの中にも入れたくないので今のプロジェクトでは"x.y.z"とバージョンを固定しています。</del></p>

<p><del>この辺りはみんなどうしてるんですかね？</del></p>

<p><strong>[追記:2013-03-04] yosuke_furukawaさんに教えていただきました!ありがとうございます！</strong></p>

<blockquote><p>npm shrinkwrapってコマンドがあって、それを使うとライブラリのバージョンを固定できる。bower shrinkwrapは実装待ち <a href="https://github.com/bower/bower/issues/505">https://github.com/bower/bower/issues/505</a></p></blockquote>

<p>というわけでnpmはnpm-shrinkwrapを使って管理することにしました yosuke_furukawa++</p>

<h2>npm-shrinkwrap</h2>

<p><a href="https://www.npmjs.org/doc/cli/npm-shrinkwrap.html">https://www.npmjs.org/doc/cli/npm-shrinkwrap.html</a></p>

<p>node_modulesにライブラリがインストールされている状態でnpm shrinkwrapするとnpm-shrinkwrap.jsonという依存しているライブラリのバージョンが記載されたファイルがつくられます。</p>

<p>devDependenciesも含めたい場合は、&mdash;devオプションを付ける必要があります
```
% npm install
:
% npm shrinkwrap &mdash;dev
wrote npm-shrinkwrap.json</p>

<p>% cat npm-shrinkwrap.json
{
  &ldquo;name&rdquo;: &ldquo;myapp&rdquo;,
  &ldquo;version&rdquo;: &ldquo;0.0.1&rdquo;,
  &ldquo;dependencies&rdquo;: {</p>

<pre><code>"grunt-contrib-concat": {
  "version": "0.3.0",
  "from": "grunt-contrib-concat@"
},
"grunt-remove-logging": {
  "version": "0.1.1",
  "from": "grunt-remove-logging@",
  "resolved": "https://registry.npmjs.org/grunt-remove-logging/-/grunt-remove-logging-0.1.1.tgz"
},
"grunt-contrib-coffee": {
  "version": "0.7.0",
  "from": "grunt-contrib-coffee@",
  "dependencies": {
    "coffee-script": {
      "version": "1.6.3",
      "from": "coffee-script@~1.6.2"
    }
  }
},
"grunt-contrib-compass": {
  "version": "0.6.0",
  "from": "grunt-contrib-compass@",
  "resolved": "https://registry.npmjs.org/grunt-contrib-compass/-/grunt-contrib-compass-0.6.0.tgz",
  "dependencies": {
    "tmp": {
      "version": "0.0.21",
      "from": "tmp@0.0.21"
    },
    "dargs": {
      "version": "0.1.0",
      "from": "dargs@~0.1.0"
    },
    "async": {
      "version": "0.2.9",
      "from": "async@~0.2.0"
    }
  }
},
</code></pre>

<p>:
```</p>

<p>npm-shrinkwrap.jsonがある状態でnpm installするとnpm-shrinkwrap.json記載されてるバージョンでインストールされます。
<code>
% npm install
</code></p>

<p>package.jsonで"x.y.z"指定でバージョン固定した場合でもそのライブラリが依存しているライブラリは"~x.y.z"で指定されているためバージョンがズレることがあったのですが、npm-shrinkwrapを使うと依存しているライブラリのバージョンも固定出来て素晴らしい！</p>

<h2>Semantic Versioning</h2>

<p>上の辺りを調べているときにSemantic Versioningというサイトがあるのをしりました。</p>

<ul>
<li><a href="http://semver.org/">http://semver.org/</a></li>
</ul>


<p>これによるとバージョンニングをMAJOR.MINOR.PATCHと定義していて、</p>

<ul>
<li>MAJORは互換性のない変更</li>
<li>MINORは後方互換性のある追加機能</li>
<li>PATCHは後方互換性のあるBugFix</li>
</ul>


<p>とされています。(1.0.0未満は開発版なので上の限りではない)</p>

<p>さきほどのnpmやbowerの&mdash;saveが"~x.y.z"となっているのも上のバージョニングだと考えると納得がいきます。</p>

<p>ただ、実際その通りになっているライブラリばかりではなく、PATCHバージョンあげたら動かなくなることもありますし、そもそも1.0.0未満だと対象外なので"~x.y.z"の指定で大丈夫というわけにはいきません。</p>

<p>BackboneにもSemantic Versioninigに従うべきというissueがあったりしますが、実際はなかなかむずかしそうです。(jashkenasもその通りにしていたらBackbone 43.0.0になってるとコメントしたりしています)</p>

<p><a href="https://github.com/jashkenas/backbone/issues/2888">https://github.com/jashkenas/backbone/issues/2888</a></p>

<p>普段使っているようなライブラリも依存関係を"~x.y.z"という形式で指定されていることが多いのですが、それによって依存ライブラリのPATCHレベルでの変更で壊れることもあったりして、なかなか難しい&hellip;</p>

<p>(結論なし..)</p>
]]></content>
  </entry>
  
</feed>
